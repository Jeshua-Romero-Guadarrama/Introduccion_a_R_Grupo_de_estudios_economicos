cv.error[p] <- mean((cv.pred - Prestige$prestige)^2)
# cv.error[p] <- median(abs(cv.pred - Prestige$prestige))
}
plot(ventanas, cv.error)
span <- ventanas[which.min(cv.error)]
span
plot(prestige ~ income, Prestige, col = 'darkgray')
fit <- loess(prestige ~ income, Prestige, span = span)
valores <- seq(0, 25000, 100)
pred <- predict(fit, newdata = data.frame(income = valores))
lines(valores, pred)
head(mtcars[1:3])
summary(mtcars[1:3])
hist(mtcars$mpg)
knitr::kable(
head(mtcars),
caption = "Una kable knitr"
)
head(mtcars[1:3])
summary(mtcars[1:3])
hist(mtcars$mpg)
knitr::kable(
head(mtcars),
caption = "Una kable knitr"
)
head(mtcars[1:3])
summary(mtcars[1:3])
hist(mtcars$mpg)
knitr::kable(
head(mtcars),
caption = "Una kable knitr"
)
res <- load("datos/empleados.RData")
res
ls()
# Session > Set Working Directory > To Source...?
datos <- read.table(file = "datos/empleados.txt", header = TRUE)
# head(datos)
str(datos)
library(foreign)
datos <- read.spss(file = "datos/Employee data.sav", to.data.frame = TRUE)
# head(datos)
str(datos)
tipo <- c("A", "B", "C")
longitud <- c(120.34, 99.45, 115.67)
datos <- data.frame(tipo, longitud)
datos
data(cars)
# str(cars)
head(cars)
cars$speed
cars[, 1]  # Equivalente
cars$velocidad <- cars$speed / 0.62137
head(cars)
cars$distancia <- cars$dis / 3.2808
head(cars)
coches <- cars[, c("velocidad", "distancia")]
# head(coches)
str(coches)
x <- c(2.5, 4.3, 1.2, 3.1, 5.0) # valores originales
ii <- order(x)
ii    # vector de ordenación
x[ii] # valores ordenados
ii <- order(cars$dist) # Vector de índices de ordenación
cars2 <- cars[ii, ]    # Datos ordenados por dist
head(cars2)
subset(cars, dist > 85) # datos con dis>85
subset(cars, speed > 10 & speed < 15 & dist > 45) # speed en (10,15) y dist>45
ii <- cars$dist > 85
cars[ii, ]   # dis>85
ii <- cars$speed > 10 & cars$speed < 15 & cars$dist > 45
cars[ii, ]  # speed en (10,15) y dist>45
it <- which(ii)
str(it)
cars[it, 1:2]
# rownames(cars[it, 1:2])
id <- which(!ii)
str(cars[id, 1:2])
# Se podría p.e. emplear cars[id, ] para predecir cars[it, ]$speed
# ?which.min
res <- load("datos/empleados.RData")
res
ls()
# Session > Set Working Directory > To Source...?
datos <- read.table(file = "datos/empleados.txt", header = TRUE)
# head(datos)
str(datos)
library(foreign)
datos <- read.spss(file = "datos/Employee data.sav", to.data.frame = TRUE)
# head(datos)
str(datos)
tipo <- c("A", "B", "C")
longitud <- c(120.34, 99.45, 115.67)
datos <- data.frame(tipo, longitud)
datos
data(cars)
# str(cars)
head(cars)
cars$speed
cars[, 1]  # Equivalente
cars$velocidad <- cars$speed / 0.62137
head(cars)
cars$distancia <- cars$dis / 3.2808
head(cars)
coches <- cars[, c("velocidad", "distancia")]
# head(coches)
str(coches)
x <- c(2.5, 4.3, 1.2, 3.1, 5.0) # valores originales
ii <- order(x)
ii    # vector de ordenación
x[ii] # valores ordenados
ii <- order(cars$dist) # Vector de índices de ordenación
cars2 <- cars[ii, ]    # Datos ordenados por dist
head(cars2)
subset(cars, dist > 85) # datos con dis>85
subset(cars, speed > 10 & speed < 15 & dist > 45) # speed en (10,15) y dist>45
ii <- cars$dist > 85
cars[ii, ]   # dis>85
ii <- cars$speed > 10 & cars$speed < 15 & cars$dist > 45
cars[ii, ]  # speed en (10,15) y dist>45
it <- which(ii)
str(it)
cars[it, 1:2]
# rownames(cars[it, 1:2])
id <- which(!ii)
str(cars[id, 1:2])
# Se podría p.e. emplear cars[id, ] para predecir cars[it, ]$speed
# ?which.min
load("datos/empleados.RData")
data.frame(Etiquetas = attr(empleados, "variable.labels"))  # Listamos las etiquetas
attach(empleados)
attr(empleados, "variable.labels") <- NULL                  # Eliminamos las etiquetas para que no molesten...
table(sexo)
prop.table(table(sexo))
table(sexo,catlab)
prop.table(table(sexo,catlab))
prop.table(table(sexo,catlab), 1)
prop.table(table(sexo,catlab), 2)
table(catlab,educ,sexo)
round(prop.table(table(catlab,educ,sexo)),2)
table(educ)
prop.table(table(educ))
cumsum(table(educ))
cumsum(prop.table(table(educ)))
consumo<-c(6.9, 6.3, 6.2, 6.5 ,6.4, 6.8, 6.6)
mean(consumo)
dotchart(consumo,pch=16)
text(mean(consumo),2.5, pos=3,expression(bar(X)==6.53))
arrows(mean(consumo),0,mean(consumo),2.5,length = 0.15,col='red')
mean(salario)
mean(subset(empleados,catlab=='Directivo')$salario)
tapply(salario, catlab, mean)
var(consumo)
var(salario)
sd(consumo)
sd(salario)
sqrt(var(consumo))
sqrt(var(salario))
sd(consumo)/abs(mean(consumo))
100*sd(consumo)/abs(mean(consumo))
100*sd(salini)/abs(mean(salini))
100*sd(salario)/abs(mean(salario))
100*sd(expprev)/abs(mean(expprev))
diametro <- c(3.88,4.09,3.92,3.97,4.02,3.95, 4.03,3.92,3.98,5.60)
dotchart(diametro,pch=16,xlab="diámetro")
abline(v=mean(diametro),col='red',lwd=2)
abline(v=median(diametro),col='blue',lty=2,lwd=2)
legend("bottomright",c("media","mediana"),
col=c("red","blue"),lty=c(1,2),lwd=c(2,2),box.lty=0,cex=1.5)
mean(salario); median(salario)
mean(salario < mean(salario))
paste('El ', round(100*mean(salario < mean(salario)),0), '%',
' de los empleados tienen un salario inferior al salario medio', sep='')
mean(salario < median(salario))
median(c(1,2,3,4))
quantile(c(1,2,3,4),0.5)
quantile(c(1,2,3,4),0.5,type=1)
quantile(salario)
quantile(salario, probs=c(0.25,0.5,0.75))
quantile(salario, probs=seq(0.1, 0.9, 0.1))
data.frame(Rango=max(salario)-min(salario),
RI=as.numeric(quantile(salario, 0.75) - quantile(salario, 0.25)))
summary(empleados)
summary(subset(empleados,catlab=='Directivo'))
table(catlab)
par(mfrow = c(1, 3))
barplot(table(catlab),main="frecuencia absoluta")
barplot(100*prop.table(table(catlab)),main="frecuencia relativa (%)")
pie(table(catlab))
nj <- table(educ)
fj <- prop.table(nj)
Nj <- cumsum(nj)
Fj <- cumsum(fj)
layout(matrix(c(1,2,5,3,4,5), 2, 3, byrow=TRUE), respect=TRUE)
barplot(nj,main="frecuencia absolutas",xlab='años de estudio')
barplot(fj,main="frecuencia relativas",xlab='años de estudio')
barplot(Nj,main="frecuencia absolutas acumuladas",xlab='años de estudio')
barplot(Fj,main="frecuencia relativas acumuladas",xlab='años de estudio')
pie(nj,col=rainbow(6),main='años de estudio')
par(mfrow = c(1, 1))
table(cut(expprev, breaks=5))
barplot(table(cut(expprev,breaks=5)),xlab="Experiencia previa",
main="Categorización en 5 clases")
tt <- table(cut(expprev, breaks=c(0,40,80,150,250,400)))
barplot(tt,xlab="Experiencia previa", main="Categorización en 5 clases")
dotchart(salario, xlab='salarios')
stripchart(salario~sexo, method='jitter')
stem(salario)
stem(tiempemp)
hist(salario, main='número de clases por defecto')
hist(salario, breaks=3, main='3 intervalos de clase')
hist(salario, breaks=100, main='100 intervalos de clase')
cl1 <- seq(15000,40000,5000)
cl2 <- seq(50000,80000,10000)
cl3 <- seq(100000,140000,20000)
hist(salario, breaks=c(cl1,cl2,cl3),main='intervalos de clase de distinta amplitud')
plot(density(salario))
hist(salario, freq=F, main='')
lines(density(salario), lwd=3, col='red')
library(car)  # help(car)
densityPlot(salario~sexo)
boxplot(salario, horizontal=T, axes=F)
axis(1)
par(mfrow=c(1,2))
boxplot(salario~catlab)
boxplot(salario~sexo)
par(mfrow=c(1,1))
boxplot(salario~sexo*catlab)
boxplot(salini, salario)
hist(salario,probability=T,ylab="",col='grey',axes=F,main=""); axis(1)
lines(density(salario),col='red',lwd=2)
par(new=T)
boxplot(salario,horizontal=T,axes=F,lwd=2)
plot(educ,salario)
plot(tiempemp,salario)
plot(salini,salario)
AirPassengers
plot(AirPassengers)
plot(iris[,3],iris[,4],main="Longitud y anchura de pétalos de lirios",
xlab="Longitud de pétalo",ylab="Anchura de pétalo")
iris.color<-c("red","green","blue")[iris$Species]
plot(iris[,3],iris[,4],col=iris.color,main="Longitud y anchura
de pétalo según especies",xlab="Longitud de pétalo",
ylab="Anchura de pétalo")
legend("topleft",c("Setosa","Versicolor","Virginica"),pch=1,
col=c("red","green","blue"),box.lty=0)
pairs(iris[,1:4],col=iris.color)
load("datos/empleados.RData")
data.frame(Etiquetas = attr(empleados, "variable.labels"))  # Listamos las etiquetas
attach(empleados)
attr(empleados, "variable.labels") <- NULL                  # Eliminamos las etiquetas para que no molesten...
table(sexo)
prop.table(table(sexo))
table(sexo,catlab)
prop.table(table(sexo,catlab))
prop.table(table(sexo,catlab), 1)
prop.table(table(sexo,catlab), 2)
table(catlab,educ,sexo)
round(prop.table(table(catlab,educ,sexo)),2)
table(educ)
prop.table(table(educ))
cumsum(table(educ))
cumsum(prop.table(table(educ)))
consumo<-c(6.9, 6.3, 6.2, 6.5 ,6.4, 6.8, 6.6)
mean(consumo)
dotchart(consumo,pch=16)
text(mean(consumo),2.5, pos=3,expression(bar(X)==6.53))
arrows(mean(consumo),0,mean(consumo),2.5,length = 0.15,col='red')
mean(salario)
mean(subset(empleados,catlab=='Directivo')$salario)
tapply(salario, catlab, mean)
var(consumo)
var(salario)
sd(consumo)
sd(salario)
sqrt(var(consumo))
sqrt(var(salario))
sd(consumo)/abs(mean(consumo))
100*sd(consumo)/abs(mean(consumo))
100*sd(salini)/abs(mean(salini))
100*sd(salario)/abs(mean(salario))
100*sd(expprev)/abs(mean(expprev))
diametro <- c(3.88,4.09,3.92,3.97,4.02,3.95, 4.03,3.92,3.98,5.60)
dotchart(diametro,pch=16,xlab="diámetro")
abline(v=mean(diametro),col='red',lwd=2)
abline(v=median(diametro),col='blue',lty=2,lwd=2)
legend("bottomright",c("media","mediana"),
col=c("red","blue"),lty=c(1,2),lwd=c(2,2),box.lty=0,cex=1.5)
mean(salario); median(salario)
mean(salario < mean(salario))
paste('El ', round(100*mean(salario < mean(salario)),0), '%',
' de los empleados tienen un salario inferior al salario medio', sep='')
mean(salario < median(salario))
median(c(1,2,3,4))
quantile(c(1,2,3,4),0.5)
quantile(c(1,2,3,4),0.5,type=1)
quantile(salario)
quantile(salario, probs=c(0.25,0.5,0.75))
quantile(salario, probs=seq(0.1, 0.9, 0.1))
data.frame(Rango=max(salario)-min(salario),
RI=as.numeric(quantile(salario, 0.75) - quantile(salario, 0.25)))
summary(empleados)
summary(subset(empleados,catlab=='Directivo'))
table(catlab)
par(mfrow = c(1, 3))
barplot(table(catlab),main="frecuencia absoluta")
barplot(100*prop.table(table(catlab)),main="frecuencia relativa (%)")
pie(table(catlab))
nj <- table(educ)
fj <- prop.table(nj)
Nj <- cumsum(nj)
Fj <- cumsum(fj)
layout(matrix(c(1,2,5,3,4,5), 2, 3, byrow=TRUE), respect=TRUE)
barplot(nj,main="frecuencia absolutas",xlab='años de estudio')
barplot(fj,main="frecuencia relativas",xlab='años de estudio')
barplot(Nj,main="frecuencia absolutas acumuladas",xlab='años de estudio')
barplot(Fj,main="frecuencia relativas acumuladas",xlab='años de estudio')
pie(nj,col=rainbow(6),main='años de estudio')
par(mfrow = c(1, 1))
table(cut(expprev, breaks=5))
barplot(table(cut(expprev,breaks=5)),xlab="Experiencia previa",
main="Categorización en 5 clases")
tt <- table(cut(expprev, breaks=c(0,40,80,150,250,400)))
barplot(tt,xlab="Experiencia previa", main="Categorización en 5 clases")
dotchart(salario, xlab='salarios')
stripchart(salario~sexo, method='jitter')
stem(salario)
stem(tiempemp)
hist(salario, main='número de clases por defecto')
hist(salario, breaks=3, main='3 intervalos de clase')
hist(salario, breaks=100, main='100 intervalos de clase')
cl1 <- seq(15000,40000,5000)
cl2 <- seq(50000,80000,10000)
cl3 <- seq(100000,140000,20000)
hist(salario, breaks=c(cl1,cl2,cl3),main='intervalos de clase de distinta amplitud')
plot(density(salario))
hist(salario, freq=F, main='')
lines(density(salario), lwd=3, col='red')
library(car)  # help(car)
densityPlot(salario~sexo)
boxplot(salario, horizontal=T, axes=F)
axis(1)
par(mfrow=c(1,2))
boxplot(salario~catlab)
boxplot(salario~sexo)
par(mfrow=c(1,1))
boxplot(salario~sexo*catlab)
boxplot(salini, salario)
hist(salario,probability=T,ylab="",col='grey',axes=F,main=""); axis(1)
lines(density(salario),col='red',lwd=2)
par(new=T)
boxplot(salario,horizontal=T,axes=F,lwd=2)
plot(educ,salario)
plot(tiempemp,salario)
plot(salini,salario)
AirPassengers
plot(AirPassengers)
plot(iris[,3],iris[,4],main="Longitud y anchura de pétalos de lirios",
xlab="Longitud de pétalo",ylab="Anchura de pétalo")
iris.color<-c("red","green","blue")[iris$Species]
plot(iris[,3],iris[,4],col=iris.color,main="Longitud y anchura
de pétalo según especies",xlab="Longitud de pétalo",
ylab="Anchura de pétalo")
legend("topleft",c("Setosa","Versicolor","Virginica"),pch=1,
col=c("red","green","blue"),box.lty=0)
pairs(iris[,1:4],col=iris.color)
# La familia apply
La familia de funciones `apply` es usada para aplicar una funci?n a cada elemento de una estructura de datos. En particular, es usada para aplicar funciones en matrices, data frames, arrays y listas.
Con esta familia de funciones podemos automatizar tareas complejas usando poca l?neas de c?digo y es una de las caracter?sticas distintivas de R como lenguaje de programaci?n.
La familia de funciones `apply` es una expresi?n de los rasgos del paradigma funcional de programaci?n presentes en R. Sobre esto no profundizaremos demasiado, pero se refiere saber que en R las funciones son "ciudadanos de primera", con la misma importancia que los objetos, y por lo tanto, operamos en ellas.
mi_vector <- 1:10
mi_vector
mi_vector ^ 2
# Creamos un data frame
mi_df <- data.frame(v1 = 1:3, v2 = 4:6)
mi_df
# Coerción a matriz
mi_matriz <- as.matrix(mi_df)
# Verificamos que sea matriz
is.matrix(mi_matriz)
# Resultado
mi_matriz
matriz <- matrix(1:14, nrow = 4)
apply(X = matriz, MARGIN = 1, FUN = sum)
sum(matriz[1, ])
sum(matriz[2, ])
sum(matriz[3, ])
sum(matriz[4, ])
sum(vector_1)
mi_vector <- 1:10
mi_vector
mi_vector ^ 2
# Creamos un data frame
mi_df <- data.frame(v1 = 1:3, v2 = 4:6)
mi_df
# Coerción a matriz
mi_matriz <- as.matrix(mi_df)
# Verificamos que sea matriz
is.matrix(mi_matriz)
# Resultado
mi_matriz
matriz <- matrix(1:14, nrow = 4)
apply(X = matriz, MARGIN = 1, FUN = sum)
sum(matriz[1, ])
sum(matriz[2, ])
sum(matriz[3, ])
sum(matriz[4, ])
sum(vector_1)
mi_vector <- 1:10
mi_vector
mi_vector ^ 2
# Creamos un data frame
mi_df <- data.frame(v1 = 1:3, v2 = 4:6)
mi_df
# Coerción a matriz
mi_matriz <- as.matrix(mi_df)
# Verificamos que sea matriz
is.matrix(mi_matriz)
# Resultado
mi_matriz
matriz <- matrix(1:14, nrow = 4)
apply(X = matriz, MARGIN = 1, FUN = sum)
sum(matriz[1, ])
sum(matriz[2, ])
sum(matriz[3, ])
sum(matriz[4, ])
sum(vector_1)
mi_vector <- 1:10
mi_vector
mi_vector ^ 2
# Creamos un data frame
mi_df <- data.frame(v1 = 1:3, v2 = 4:6)
mi_df
# Coerción a matriz
mi_matriz <- as.matrix(mi_df)
# Verificamos que sea matriz
is.matrix(mi_matriz)
# Resultado
mi_matriz
matriz <- matrix(1:14, nrow = 4)
apply(X = matriz, MARGIN = 1, FUN = sum)
sum(matriz[1, ])
sum(matriz[2, ])
sum(matriz[3, ])
sum(matriz[4, ])
apply(X = matriz, MARGIN = 2, FUN = sum)
apply(matriz, 1, mean)
apply(matriz, 2, mean)
# Desviación estándar
apply(matriz, 1, FUN = sd)
# Máximo
apply(matriz, 1, FUN = max)
# Cuantiles
apply(matriz, 1, FUN = quantile)
matriz2 <- matrix(c(1:2, "a", "b"), nrow = 2)
# Resultado
apply(matriz2, 2, quantile)
apply(X = matriz, MARGIN = 2, FUN = quantile, probs = c(.33, .66))
apply(matriz, 2, quantile, probs = c(.33, .66), names = FALSE)
mat_media <- apply(matriz, 1, mean)
class(mat_media)
mat_cuant <- apply(matriz, 1, quantile)
class(mat_cuant)
trees[1:5, ]
lapply(X = trees, FUN = mean)
arboles <- lapply(X = trees, FUN = mean)
class(arboles)
lapply(X = trees, FUN = quantile, probs = .8)
matriz <- matrix(1:9, ncol = 3)
# Resultado
matriz
lapply(matriz, quantile, probs = .8)
lapply(as.data.frame(matriz), quantile, probs = .8)
matriz_t <- t(matriz)
lapply(as.data.frame(matriz_t), quantile, probs = .8)
mi_vector <- 1:4
lapply(mi_vector, sqrt)
mi_vector <- 6:12
resultado <- NULL
posicion <- 1
for(numero in mi_vector) {
resultado[posicion] <- sqrt(numero)
posicion <- posicion + 1
}
resultado
resultado <- NULL
resultado <- lapply(mi_vector, sqrt)
resultado
as.numeric(resultado)
trees_max <- NULL
i <- 1
columnas <- ncol(trees)
for(i in 1:columnas) {
trees_max[i] <- max(trees[, i])
i <- i +1
}
trees_max
# Fijamos seed
set.seed(seed = 2018)
# Creamos una lista con tres data frames dentro
tablas <- list(
df1 = data.frame(a = rnorm(n = 5), b = rnorm(n = 5), c = rnorm(n = 5)),
df2 = data.frame(d = rnorm(n = 5), e = rnorm(n = 5), f = rnorm(n = 5)),
df3 = data.frame(g = rnorm(n = 5), h = rnorm(n = 5), i = rnorm(n = 5))
)
# Resultado
tablas
cor(iris[1:4])
lapply(X = tablas, FUN = cor)
correlaciones <- lapply(tablas, cor)
# Extraemos el primer elemento de la lista
correlaciones[[1]]
