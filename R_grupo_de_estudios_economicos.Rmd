---
title: "R Grupo de estudios económicos"
cover-image: "images/cover.png"
author: "Jeshua Romero Guadarrama, Kevin Fernández, Apocryfo, Jenn, Daniel, Tifany Jiménez, Ernesto, Ezequiel, Rich Conejo, Angiebaram, Jesmarth, Adolfo Robles, Isaac Flores, Abdeel, Roberto Daniel"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output:
  bookdown::word_document2: default 
  bookdown::pdf_book:
    pandoc_args: ["+RTS", "-K64m", "-RTS", "--csl", "apa-old-doi-prefix.csl"]
    includes:
      in_header: preamble.tex
    citation_package: natbib
    keep_tex: yes
  bookdown::gitbook:
    config:
      toc:
        collapse: subsection
        scroll_highlight: yes
      fontsettings:
        theme: white
        family: serif
        size: 2
    split_by: section+number
    highlight: tango
    includes:
      in_header: [header_include.html]
always_allow_html: yes
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
biblatexoptions:
  - sortcites
link-citations: yes
github-repo: "https://github.com/Jeshua-Romero-Guadarrama/R_grupo_de_estudios_economicos"
description: "Los estudiantes con poca experiencia en el análisis avanzado de estadísticas a menudo tienen dificultades para entender los beneficios de desarrollar habilidades de programación al momento de aplicar diversos métodos descriptivos e inferenciales. 'Análisis estadístico con R para principiantes' por Jeshua Romero Guadarrama (2021), ofrece una introducción interactiva a los aspectos esenciales de la programación por medio del lenguaje y software estadístico R, así como una guía para la aplicación de la teoría económica y econométrica en entornos específicos. En otras palabras, el objetivo es que los estudiantes se adentren al mundo de la economía aplicada mediante ejemplos empíricos presentados en la vida diaria y haciendo uso de las habilidades de programación recién adquiridas. Dicho objetivo se encuentra respaldado por ejercicios de programación interactivos y la incorporación de visualizaciones dinámicas de conceptos fundamentales mediante la flexibilidad de JavaScript, a través de la biblioteca D3.js."
url: 'https\://rgrupodeestudioseconomicos.jeshuanomics.com'
tags: [Academia, Modelos lineales, Econoalgoritmia, Estadística avanzada, Análisis causal, Programación R]
favicon: "images/logo.png"
---

# Prefacio {-}

```{r, echo = F}
options(knitr.duplicate.label = "allow")
```

```{r, child="_setup.Rmd"}
```

```{r, eval=my_output == "html", echo=FALSE, results='asis'}
cat('<hr style="background-color:#03193b;height:2px">')
```

<center><img style = 'width:60%;' src='images/R_grupo_de_estudios_economicos.png'></center>

```{r, eval=my_output == "html", echo=FALSE, results='asis'}
cat('<hr style="background-color:#03193b;height:2px">')
```

<center><img style = 'width:30%;' src='images/cover.jpg'></center>
<br><center><img style='float: center; width:50%' src='images/logo_claim_en_rgb.png'/></center>
<br><center><a href="https://www.jeshuanomics.com/" target="blank">Publicado por Jeshua Romero Guadarrama en colaboración con JeshuaNomics:</a></center>
<br><center><a href="https://github.com/JeshuaNomics" class="fa fa-github"><span class="label">  Git Hub</span></a>
<a href="https://www.facebook.com/JeshuaNomics/" class="fa fa-facebook"><span class="label">  Facebook</span></a>
<a href="https://twitter.com/JeshuaNomics" class="fa fa-twitter"><span class="label">  Twitter</span></a>
<a href="https://www.linkedin.com/in/jeshua-romero-guadarrama/" class="fa fa-linkedin"><span class="label">  Linkedin</span></a>
<a href="https://vk.com/jeshuanomics" class="fa fa-vk"><span class="label">  Vkontakte</span></a>
<a href="https://jeshuanomics.tumblr.com/" class="fa fa-tumblr"><span class="label">  Tumblr</span></a>
<a href="https://www.youtube.com/channel/UCY7f84mJGvMN7TF7XI4-Jgg?view_as=subscriber/" class="fa fa-youtube-play"><span class="label">  YouTube</span></a>
<a href="https://www.instagram.com/JeshuaNomics/" class="fa fa-instagram"><span class="label">  Instagram</span></a></center>

<br> Jeshua Romero Guadarrama es economista y actuario por la <a href="http://www.economia.unam.mx/">Universidad Nacional Autónoma de México</a>, quien ha construido el presente proyecto en colaboración con <a href="https://www.jeshuanomics.com">JeshuaNomics</a>, ubicado en la Ciudad de México, se puede contactar mediante el siguiente correo electrónico: jeshuanomics@gmail.com.
<br>
<br> `r sf <- lubridate::stamp_date('Última actualización el martes 21 del 05 de 2021'); sf(Sys.Date())`
<br>

```{r, eval=knitr::opts_knit$get("rmarkdown.pandoc.to") == "html", results='asis', echo=FALSE}
cat('<hr style="background-color:#03193b;height:2px">')
```

Los estudiantes con poca experiencia en el análisis avanzado de estadísticas a menudo tienen dificultades para entender los beneficios de desarrollar habilidades de programación al momento de aplicar diversos métodos descriptivos e inferenciales. <i>Análisis estadístico con R para principiantes</i> por Jeshua Romero Guadarrama (2021), ofrece una introducción interactiva a los aspectos esenciales de la programación por medio del lenguaje y software estadístico R, así como una guía para la aplicación de la teoría económica y econométrica en entornos específicos. En otras palabras, el objetivo es que los estudiantes se adentren al mundo de la economía aplicada mediante ejemplos empíricos presentados en la vida diaria y haciendo uso de las habilidades de programación recién adquiridas. Dicho objetivo se encuentra respaldado por ejercicios de programación interactivos y la incorporación de visualizaciones dinámicas de conceptos fundamentales mediante la flexibilidad de JavaScript, a través de la biblioteca D3.js.

En los últimos años, el lenguaje de programación estadística R se ha convertido en una parte integral del plan de estudios de las clases de estadística que se imparten en las universidades. Regularmente una gran parte de los estudiantes no han estado expuestos a ningún lenguaje de programación antes y, por lo tanto, tienen dificultades para participar en el aprendizaje de R por sí mismos. Con poca experiencia en el análisis avanzado de estadísticas, es natural que los novicios tengan dificultades para comprender los beneficios de desarrollar habilidades en R para aprender y aplicar la estadística. Estos incluyen particularmente la capacidad de realizar, documentar y comunicar estudios empíricos y tener las facilidades para programar estudios de simulación, lo cual es útil para, por ejemplo, comprender y validar teoremas que generalmente no se asimilan o entienden fácilmente con el estudio de las fórmulas. Al ser un economistas aplicado y econometrista, me gustaría que mis colegas desarrollen capacidades de gran valor; en consecuencia, deseo compartir con las nuevas generaciones de economistas mis conocimientos.

En lugar de confrontar a los estudiantes con ejercicios de codificación puros y literatura clásica complementaria, he pensado que sería mejor proporcionar material de aprendizaje interactivo que combine el código en R con el contenido del curso de texto *Introducción a la Econometría* de @stock2015 que sirve de base para el presente material. El presente trabajo es un complemento empírico interactivo al estilo de un informe de investigación reproducible que permite a los estudiantes no solo aprender cómo los resultados de los estudios de casos se pueden replicar con R, sino que también fortalece su capacidad para utilizar las habilidades recién adquiridas en otras aplicaciones empíricas.

#### Las convenciones usadas en el presente curso {-}

+ El texto *en cursiva* indica nuevos términos, nombres, botones y similares.

+ El texto **en negrita** se usa generalmente en párrafos para referirse al código **R**. Esto incluye comandos, variables, funciones, tipos de datos, bases de datos y nombres de archivos.

+ <code>Texto de ancho constante sobre fondo gris</code> indica un código **R** que usted puede escribir literalmente. Puede aparecer en párrafos para una mejor distinción entre declaraciones de código ejecutables y no ejecutables, pero se encontrará principalmente en forma de grandes bloques de código **R**. Estos bloques se denominan fragmentos de código.

#### Reconocimiento {-}

A mi alma máter: Universidad Nacional Autónoma de México (Facultad de Economía y Facultad de Ciencias). Por brindarme valiosas oportunidades que coadyuvaron a mi formación.

```{r, eval=knitr::opts_knit$get("rmarkdown.pandoc.to") == "html", results='asis', echo=FALSE}
cat('<br>
![Creative Commons License](https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-nc-sa.eu.svg)

Esta obra está autorizado bajo la [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-nc-sa/4.0/).')
```

## Contenido {-}

- Introducción
- Sobre este curso
- Similitud con este curso Otro para principiantes
- Lo que puede omitir con seguridad
- Supuestos tontos
- Cómo está organizado este curso
    + Parte I: Introducción al análisis estadístico con **R**
    + Parte II: Descripción de datos
    + Parte III: Sacar conclusiones a partir de los datos
    + Parte IV: Trabajar con probabilidad
    + Parte V: La parte de diez
    + Apéndice A en línea: Más sobre probabilidad
    + Apéndice B en línea: Estadísticas no paramétricas
    + Apéndice C en línea: Diez temas que simplemente no encajan en ningún otro capítulo
- Iconos utilizados en este curso
- A dónde ir desde aquí

## Índice de contenido {-}

Parte I: Introducción al análisis estadístico con **R**

1. Datos, estadísticas y decisiones
    - Las nociones estadísticas (y relacionadas) que solo debe conocer
        + Muestras y poblaciones
        + Variables: dependientes e independientes
        + Tipos de datos
        + Un poco de probabilidad
    - Estadística inferencial: probando hipótesis
        + Hipótesis nulas y alternativas
        + Dos tipos de error

2. **R**: Qué hace y cómo lo hace
    - Descargando **R** y **RStudio**
    - Una sesión con **R**
        + El directorio de trabajo
        + Así que comencemos, ya
        + Datos faltantes
    - Funciones **R**
    - Funciones definidas por el usuario
    - comentarios
    - **R** Estructuras
        + Vectores
        + Vectores numéricos
        + Matrices
        + Factores
        + Listas
        + Listas y estadísticas
        + Marcos de datos
    - Paquetes
    - Más paquetes
    - **R** Fórmulas
    - Leyendo y escribiendo
        + Hojas de cálculo
        + Archivos CSV
        + Archivos de texto

Parte II: Descripción de datos

3. Obtención de gráficos
    - Encontrar patrones
        + Graficar una distribución
        + Salto de bares
        + Rebanar el pastel
        + La trama de dispersión
        + De cajas y bigotes
    - Gráficos básicos **R**
        + Histogramas
        + Añadiendo características gráficas
        + Parcelas de barras
        + Gráficos circulares
        + Gráficos de puntos
        + Parcelas de barras revisitadas
        + Diagramas de dispersión
        + Diagramas de caja
    - Graduarse a ggplot2
        + Histogramas
        + Parcelas de barras
        + Gráficos de puntos
        + Parcelas de barras revisitadas
        + Diagramas de dispersión
        + Diagramas de caja
    - Terminando

4. Encontrar su centro
    - Medios: el atractivo de los promedios
    - El promedio en **R**: mean()
        + ¿Cuál es tu condición?
        + Eliminar $-signos con with()
        + Explorando los datos
        + Valores atípicos: el defecto de los promedios
        + Otros medios para un fin
    - Medianas: atrapadas en el medio
    - La mediana en **R**: median()
    - Estadísticas à la Mode
    - El modo en **R**

5. Desviarse del promedio
    - Medición de la variación
        + Desviaciones cuadradas promedio: varianza y cómo calcularla
        + Varianza de la muestra
        + Varianza en **R**
    - Regreso a las raíces: desviación estándar
        + Desviación estándar de la población
        + Desviación estándar de la muestra
    - Desviación estándar en **R**
    - Condiciones, condiciones, condiciones

6. Cumplimiento de estándares y posiciones
    - Atrapando algunas Z
        + Características de las puntuaciones z
        + Bonos versus Bambino
        + Puntajes de exámenes
    - Puntuaciones estándar en **R**
    - ¿Cuál es tu posición?
        + Clasificación en **R**
        + Puntuaciones empatadas
        + Nth más pequeño, Nth más grande
        + Percentiles
        + Rangos de porcentaje
    - Resumiendo

7. Resumiendo todo
    - ¿Cuántos?
    - Lo alto y lo bajo
    - Viviendo en los momentos
        + Un momento de enseñanza
        + Volver a descriptivos
        + Asimetría
        + Curtosis
    - Sintonización de la frecuencia
        + Variables nominales: table() et al
        + Variables numéricas: hist()
        + Variables numéricas: stem()
    - Resumiendo un marco de datos

8. ¿Qué es normal?
    - Golpear la curva
        + Profundizando
        + Parámetros de una distribución normal
    - Trabajar con distribuciones normales
        + Distribuciones en **R**
        + Función de densidad normal
        + Función de densidad acumulativa
        + Cuantiles de distribuciones normales
        + Muestreo aleatorio
    - Un miembro distinguido de la familia

Parte III: Sacar conclusiones a partir de los datos

9. El juego de la confianza: estimación
    - Comprensión de las distribuciones de muestreo
    - Una idea EXTREMADAMENTE importante: el teorema del límite central
        + (Aproximadamente) Simulando el teorema del límite central
        + Predicciones del teorema del límite central
    - Confianza: ¡tiene sus límites!
        + Encontrar límites de confianza para una media
    - Encajar en una t

10. Prueba de hipótesis de una muestra
    - Hipótesis, pruebas y errores
    - Pruebas de hipótesis y distribuciones muestrales
    - Coger algo de Z de nuevo
    - Prueba Z en **R**
    - t para uno
    - t Prueba en **R**
    - Trabajar con distribuciones t
    - Visualización de distribuciones t
        + Trazado de t en gráficos **R** base
        + Trazando t en ggplot2
        + Una cosa más sobre ggplot2
    - Probando una varianza
        + Pruebas en **R**
    - Trabajar con distribuciones de chi-cuadrado
    - Visualización de distribuciones de chi-cuadrado
        + Trazado de chi-cuadrado en gráficos **R** base
        + Trazar chi-cuadrado en ggplot2

11. Prueba de hipótesis de dos muestras
    - Hipótesis construidas para dos
    - Distribuciones de muestreo revisadas
        + Aplicación del teorema del límite central
        + Z una vez más
        + Prueba Z para dos muestras en **R**
    - t para dos
    - Como guisantes en una vaina: variaciones iguales
    - Prueba t en **R**
        + Trabajando con dos vectores
        + Trabajar con un marco de datos y una fórmula
        + Visualizando los resultados
        + Como p y q: varianzas desiguales
    - Un conjunto emparejado: prueba de hipótesis para muestras emparejadas
    - Prueba t de muestras pareadas en **R**
    - Prueba de dos variaciones
        + Prueba F en **R**
        + F junto con t
    - Trabajar con distribuciones F
    - Visualización de distribuciones F

12. Prueba de más de dos muestras
    - Probando más de dos
        + Un problema espinoso
        + Una solución
        + Relaciones significativas
    - ANOVA en **R**
        + Visualizando los resultados
        + Después del ANOVA
        + Contrastes en **R**
        + Comparaciones no planificadas
    - Otro tipo de hipótesis, otro tipo de prueba
        + Trabajo con ANOVA de medidas repetidas
        + ANOVA de medidas repetidas en **R**
        + Visualizando los resultados
    - Ponerse de moda
    - Análisis de tendencias en **R**

13. Pruebas más complicadas
    - Rompiendo las combinaciones
        + Interacciones
        + El análisis
    - ANOVA bidireccional en **R**
        + Visualización de los resultados bidireccionales
    - Dos tipos de variables. . . En seguida
        + ANOVA mixto en **R**
        + Visualización de los resultados de ANOVA mixtos
    - Después del análisis
    - Análisis multivariado de varianza
        + MANOVA en **R**
        + Visualización de los resultados de MANOVA
        + Después del análisis

14. Regresión: modelo lineal, múltiple y lineal general
    - La trama de la dispersión
    - Graficar líneas
    - Regresión: ¡Qué línea!
        + Uso de regresión para pronosticar
        + Variación alrededor de la línea de regresión
        + Prueba de hipótesis sobre regresión
    - Regresión lineal en **R**
        + Características del modelo lineal
        + Haciendo predicciones
        + Visualización del diagrama de dispersión y la línea de regresión
        + Graficando los residuales
    - Hacer malabares con muchas relaciones a la vez: regresión múltiple
        + Regresión múltiple en **R**
        + Haciendo predicciones
        + Visualización del diagrama de dispersión 3D y el plano de regresión
    - ANOVA: otra mirada
    - Análisis de covarianza: el componente final del GLM
        + Pero espera, hay más

15. Correlación: el auge y la caída de las relaciones
    - Parcelas de dispersión de nuevo
    - Comprensión de la correlación
    - Correlación y regresión
    - Prueba de hipótesis sobre la correlación
        + ¿Un coeficiente de correlación es mayor que cero?
        + ¿Se diferencian dos coeficientes de correlación?
    - Correlación en **R**
        + Calcular un coeficiente de correlación
        + Prueba de un coeficiente de correlación
        + Prueba de la diferencia entre dos coeficientes de correlación
        + Calcular una matriz de correlación
        + Visualización de matrices de correlación
    - Correlación múltiple
        + Correlación múltiple en **R**
        + Ajuste de R-cuadrado
    - Correlación parcial
    - Correlación parcial en **R**
    - Correlación semiparcial
    - Correlación semiparcial en **R**

16. Regresión curvilínea: cuando las relaciones se complican
    - ¿Qué es un logaritmo?
    - ¿Qué es e?
    - Regresión de potencia
    - Regresión exponencial
    - Regresión logarítmica
    - Regresión polinomial: un poder superior
    - ¿Qué modelo debería utilizar?

Parte IV: Trabajar con probabilidad

17. Introducción a la probabilidad
    - ¿Qué es la probabilidad?
        + Experimentos, ensayos, eventos y espacios de muestra
        + Espacios muestrales y probabilidad
    - Eventos compuestos
        + Unión e intersección
        + Intersección de nuevo
    - La probabilidad condicional
        + Trabajando con las probabilidades
        + La base de la prueba de hipótesis
    - Grandes espacios de muestra
        + Permutaciones
        + Combinaciones
    - **R** Funciones para contar reglas
    - Variables aleatorias: discretas y continuas
    - Distribuciones de probabilidad y funciones de densidad
    - La distribución binomial
    - El binomio binomial y el binomio negativo en **R**
        + Distribución binomial
        + Distribución binomial negativa
    - Prueba de hipótesis con la distribución binomial
    - Más sobre pruebas de hipótesis: **R** versus tradición

18. Introducción al modelado
    - Modelado de una distribución
        + Sumergirse en la distribución de Poisson
        + Modelado con la distribución de Poisson
        + Probando el ajuste del modelo
        + Un comentario sobre chisq.test()
        + Jugando a la pelota con un modelo
    - Una discusión simulada
        + Arriesgarse: el método Monte Carlo
        + Cargando los dados
        + Simulando el teorema del límite central

Parte V: La parte de diez

19. Diez consejos para emigrados de Excel
    - Definir un vector en **R** es como nombrar un rango en Excel
    - Operar en vectores es como operar en rangos con nombre
    - A veces, las funciones estadísticas funcionan de la misma manera
    - Y a veces no
    - Contraste: Excel y **R** funcionan con diferentes formatos de datos
    - Las funciones de distribución son (algo) similares
    - Un marco de datos es (algo) como un rango con nombre de varias columnas
    - La función sapply() es como arrastrar
    - Usar edit() es (casi) como editar una hoja de cálculo
    - Utilice el portapapeles para importar una tabla de Excel a **R**

20. Diez valiosos recursos **R** en línea
    - Sitios web para usuarios **R**
        + **R** - blogueros
        + Red de aplicaciones de Microsoft **R**
        + Rápido - **R**
        + **RStudio** Aprendizaje en línea
        + Desbordamiento de pila
    - Libros y documentación en línea
        + **R** manuales
        + Documentación **R**
        + **RDocumentación**
        + USTED PUEDE analizar
        + El diario **R**

<!--chapter:end:index.Rmd-->

# Introducción: ¿Qué es R y para qué es usado?

R es un lenguaje de programación y entorno computacional dedicado a la estadística. 

Decimos que es un lenguaje de programación porque nos permite dar instrucciones, usando código, a nuestros equipos de cómputo para que realicen tareas específicas (además de que es Turing Completo, pero profundizaremos en ello); para ello sólo necesitamos un intérprete para este código y es a esto a lo que llamamos un entorno computacional. 

Cuando instalamos R en nuestra computadora en realidad lo que estamos instalando es el entorno computacional, y para que podamos hacer algo en ese entorno necesitamos conocer la manera de escribir instrucciones que el software pueda interpretar y ejecutar. Eso es lo que aprenderemos a hacer en este curso.

R es diferente a otros lenguajes de programación que por lo general están diseñados para realizar muchas tareas diferentes; esto es porque fue creado con el único propósito de hacer estadística. Esta característica es la razón de que R sea un lenguaje de programación peculiar, que puede resultar absurdo en algunos sentidos para personas con experiencia en otros lenguajes, pero también es la razón por la que R es una herramienta muy poderosa para el trabajo en estadística, puesto que funciona de la manera que una persona especializada en esta disciplina desearía que lo hiciera.

Para entender mejor estas peculiaridades, nos conviene conocer un poco de los orígenes de este lenguaje de programación.

## Un poco de historia
R tiene sus orígenes en S, un lenguaje de programación creado en los Laboratorios Bell de Estados Unidos. Sí, los mismos laboratorios que inventaron el transistor, el láser, el sistema operativo Unix y algunas otras cosas más. 

Dado que S y sus estándares son propiedad de los Laboratorios Bell, lo cual restringe su uso, Ross Ihaka y Robert Gentleman, de la Universidad de Auckland en Nueva Zelanda, decidieron crear una implementación abierta y gratuita de S. Este trabajo, que culminaría en la creación de R inició en 1992, teniendo una versión inicial del lenguaje en 1995 y en el 2000 una versión final estable.

R hereda muchas características de S, por lo que puedes correr código de este lenguaje usando R sin mayor problema. Para lograr esto, en R frecuentemente existe más de una manera de realizar tareas comunes, una compatible con S y otra diseñada específicamente para R. Lo anterior tiene como resultado inconsistencias, sintaxis poco intuitiva y abundante frustración de cabeza para las personas que quieren aprender R. 

En el presente, el mantenimiento y desarrollo de R es realizado por el R Development Core Team, un equipo de especialistas en ciencias computacionales y estadística provenientes de diferentes instituciones y lugares alrededor del mundo. La versión de R mantenida por este equipo es conocida como “base” y como su nombre indica, es sobre aquella que se crean otras implementaciones de R así como los paquetes que expanden su funcionalidad.

Para lograr que R sea usado sin restricciones es distribuido de manera gratuita, a través de la Licencia Pública General de GNU, por lo que es software libre y de código abierto. Si lo deseas, puedes examinar y estudiar el código que hace que R funcione o puedes crear versiones propias de R que se ajusten a tus necesidades particulares. Esta licencia también te permite usar R para los fines que desees, sin limitaciones, no importando si personales, académicos o comerciales.

En la actualidad, el desarrollo de este lenguaje de programación se mantiene activa. La versión más reciente de R al momento de escribir este documento es la 3.4.2 “Short Summer” fue publicada en septiembre del 2017 y diariamente son publicados nuevos paquetes y sus respectivas actualizaciones.

## ¿Quién usa R?
R es un lenguaje relativamente joven pero que ha experimentado un crecimiento acelerado en su adopción durante los últimos 10 años. 

En septiembre de 2017, de acuerdo al TIOBE programming community index (2017), que es uno de los índices de más prestigio en el mundo en relación popularidad en el uso de lenguajes de programación, R era el lenguaje número 11 en popularidad, después de haber sido el lenguaje número 18 en el 2016. Esto es sobresaliente si consideramos que R es un lenguaje dedicado únicamente a la estadística, mientras que lenguajes como Python (número 5 en 2017) o Java (número 1) son lenguajes que pueden ser usados para todo tipo de tareas, desde crear sitios web hasta programar robots.

La adopción de R se debe en gran medida a que permite responder preguntas mediante el uso de datos de forma efectiva, y como es un lenguaje abierto y gratuito, se facilita compartir código, crear herramientas para solucionar problemas comunes y que todo tipo de personas interesadas en análisis estadísticos puedan participar y contribuir al desarrollo y uso de R, no sólo aquellas que tengan acceso a licencias de software cerrado. 

Incluso compañías e instituciones que no tendrían ninguna dificultad para financiar el costo de licencias de software cerrado utilizan R.

R, por citar un ejemplo, es usado por Facebook para analizar la manera en que sus usuarios interactúan con sus muros de publicaciones para así determinar qué contenido mostrarles. Esta es una tarea muy importante en Facebook, pues las interacciones de los usuarios con publicidad y contenido pagado son la principal fuente de ingreso de esta compañía.  Además de que su división de recursos humanos emplea esta herramienta para estudiar las interacciones entre sus trabajadores. 

Google usa R para analizar la efectividad las campañas de publicidad implementadas en sus servicios, por ejemplo, los anuncios pagados que te aparecen cuando “googleas” algo. Nuevamente, esta es la principal fuente de ingresos de esta compañía. R También es usado para hacer predicciones económicas y otras actividades. 

Microsoft adquirió y ahora desarrolla una versión propia de R llamada OpenR, que ha hecho disponible para uso general del público. OpenR es empleada para realizar todo tipo de análisis estadísticos, por ejemplo, para empatar a jugadores en la plataforma de videojuegos XBOX Live (así que puedes culpar a R cuando te tocan partidas contra jugadores mucho más hábiles que tú). 

Otras compañías que usan R de modo cotidiano son American Express, IBM, Ford, Citibank, HP y Roche, entre  muchas más (Bhalla, 2016; Level, 2017; Microsoft, 2014).

Lo anterior ilustra algunas de las aplicaciones específicas de este lenguaje y de manera general podemos decir que R es usado para procesar, analizar, modelar y comunicar datos. 

Aunque R está diseñado para análisis estadístico, con el paso del tiempo los usuarios de este lenguaje han creado extensiones a R, llamadas paquetes, que han ampliado su funcionalidad. En la actualidad es posible realizar en R minería de textos, procesamiento de imagen, visualizaciones interactivas de datos y  procesamiento de Big Data, entre muchas otras cosas.

Así que, empecemos a usar R.

**Referencias**

* Level (2017). How Big Companies Are Using R for Data Analysis. Recuperado en septiembre de 2017 de: http://www.northeastern.edu/levelblog/2017/05/31/big-companies-using-r-data-analysis/ 
* Microsoft (2014). Companies using R in 2014. Recuperado en septiembre de 2017 de: http://blog.revolutionanalytics.com/2014/05/companies-using-r-in-2014.html 
* Bhalla, D. (2016) Companies using R. Recuperado en septiembre de 2017 de: http://www.listendata.com/2016/12/companies-using-r.html 
* R FAQ. Recuperado en Septiembre de 2017 de: https://cran.r-project.org/doc/FAQ/R-FAQ.html#What-is-R_003f 
* TIOBE Index for September 2017. Recuperado en Septiembre de 2017 de: https://www.tiobe.com/tiobe-index/ 
* Adesanya, T. (2017). A Gentler Introduction to Programming. Recuperado en Septiembre de 2017 de: https://medium.freecodecamp.org/a-gentler-introduction-to-programming-707453a79ee8 

<!--chapter:end:01-intro.Rmd-->

# Instalación
La manera de instalar R cambia dependiendo del sistema operativo utilices pero todas tienen en común el uso de **CRAN**.

[CRAN](https://cran.r-project.org/) es el *The Comprehensive R Archive Network*, una red en la que se archivan todas las versiones de R *base*, así como todos los paquetes para R que han pasado por un proceso de revisión riguroso, realizado por el *CRAN Team*, que se encarga de asegurar su correcto funcionamiento.

CRAN es una red porque existen copias de su contenido en diferentes servidores alrededor del mundo, los cuales se actualizan diariamente. De este modo, no importa de qué servidor de CRAN descargues R o algún paquete, lo que vas a obtener será la versión más reciente de ese recurso, que es igual a la disponible en todos los demás servidores.

Como veremos más adelante, cuando descargamos un paquete de R, lo estamos haciendo desde CRAN, a menos que indiquemos otra cosa.

El sitio oficial de CRAN, en el que encontrarás más información sobre este repositorio es el siguiente:

* https://cran.r-project.org/ 

## Windows
Para instalar R en *Windows*, la forma más simple es descargar la versión más reciente de R *base* desde el siguiente enlace de CRAN:

* https://cran.r-project.org/bin/windows/base/

El archivo que necesitamos tiene la extensión **.exe** (por ejemplo *R-3.5.1-win.exe*). Una vez descargado, lo ejecutamos como cualquier instalable.

Después de la instalación, estamos listos para usar R.

## OSX
Para instalar R en *OSX*, se sigue un procedimiento similar que en *Windows*. Necesitamos descargar los archivos binarios de R base desde CRAN y ejecutarlos.

* https://cran.r-project.org/bin/macosx/ 

Al concluir la instalación, podremos usar R, incluso llamándolo directamente desde la consola.

## Linux
En *Linux*, como suele ser el caso para casi todo, hay una manera fácil y una difícil de instalar R.

La manera fácil depende de la  presencia de R en los repositorios de la distribución de *Linux* que estés usando. Si R se encuentra en los repositorios de tu distribución, sólo es necesario usar el gestor de paquetes de tu preferencia para instalarlo, como cualquier otro *software*.

Si R no se encuentra en los repositorios, debes agregar una entrada a tu lista de fuentes de software. Esta entrada depende de tu distribución. 

También tienes la opción de puedes compilar R directamente desde archivos fuente.

Para todas las opciones anteriores, los detalles de instalación se se encuentran en el siguiente enlace:

* https://cran.r-project.org/bin/linux/ 

Si estás usando *Linux* no te debería ser difícil seguir las instrucciones presentadas.

## RStudio - un IDE para R
Aunque podemos usar R directamente, es recomendable instalar y usar un entorno integrado de desarrollo (*IDE*, por sus siglas en inglés). 

Podemos utilizar R ejecutando nuestro código directamente desde documentos de texto plano, pero esta es una manera poco efectiva de trabajar, especialmente en proyectos complejos.

Un IDE nos proporciona herramientas para escribir y revisar nuestro código, administrar los archivos que estamos usando, gestionar nuestro entorno de trabajo y algunas otras herramientas de productividad. Tareas que serían difíciles o tediosas de realizar de otro modo, son fáciles a través de un IDE.

Hay varias opciones de IDE para R,  y entre ellas mi preferido es [RStudio](https://www.rstudio.com/). Este entorno, además de incorporar las funciones esenciales de una IDE, es desarrollado por un equipo que ha contribuido de manera significativa para lograr que R sea lenguaje de programación más accesible, con un énfasis en la colaboración y la reproducción de los análisis.

Para instalar RStudio, es necesario con descargar y ejecutar alguno de los instaladores disponibles en su sitio oficial. Están disponibles versiones para *Windows*, *OSX* y *Linux*.

* https://www.rstudio.com/products/rstudio/download/ 

Si ya hemos instalado R en nuestro equipo, RStudio lo detectará automáticamente y podremos utilizarlo desde este entorno. Si no instalamos RStudio antes que R, no hay problema, cada vez que iniciamos este programa, verificará la instalación de R.

<!--chapter:end:02-instalacion.Rmd-->

# Conceptos básicos
Para trabajar con R es necesario conocer un poco del vocabulario usado en en este lenguaje de programación. Los siguientes son conceptos básicos que usaremos a lo largo de todo el libro.

## La consola de R
Lo primero que nos encontramos al ejecutar R es una pantalla que nos muestra la versión de este lenguaje que estamos ejecutando y un *prompt*:

`>_                                               ` 

Esta es la consola de R y corresponde al **entorno computacional** de este lenguaje. Es aquí donde nuestro **código** es interpretado.

Podemos escribir código directamente en la consola y R nos dará el resultado de lo pidamos allí mismo. Esta es la razón por la que se dice que R permite el uso interactivo, pues no es necesario compilar nuestro código para ver sus resultados.

Si estás usando RStudio, te encontrarás la consola de R en uno de los paneles de este programa.


## Ejecutar, llamar, correr y devolver
Cuando hablamos de ejecutar, llamar o correr nos referimos a pedir que R realice algo, en otras palabras, estamos dando una instrucción o una *entrada*. 

Cuando decimos que R nos devuelve algo, es que ha realizado algo que le hemos pedido, es decir, nos está dando una *salida*.

Por ejemplo, si escribimos los siguiente en la consola lo siguiente y damos *Enter*, estamos pidiendo que se ejecute esta operación:
`> 1 + 1`

Y nos será devuelto su resultado:
`[1] 2`

## Objetos
En R, todo es un objeto. Todos los datos y estructuras de datos son objetos. Además, todos los objetos tienen un nombre para identificarlos.

La explicación de esto es un tanto compleja y se sale del alcance de este libro. Se relaciona con el paradigma de **programación orientada a objetos** y ese es todo un tema en sí mismo.

Lo importante es que recuerdes que al hablar de un objeto, estamos hablando de cualquier cosa que existe en R y que tiene un nombre.

## Constantes y variables
De manera análoga al uso de estos términos en lenguaje matemático, una constante es un objeto cuyo valor no podemos cambiar, en contraste, una variable es un objeto que puede cambiar de valor.

Por ejemplo, en la siguiente expresión, **$\pi$** y **2** son constantes, mientras que **a** y **r** son variables.

$a = \pi r ^ 2$

Las constantes y variables en R tienen nombres que nos permiten hacer referencia a ellas en operaciones.

Las constantes ya están establecidas por R, mientras que nosotros podemos crear variables, asignándoles valores a nombres.

En R usamos `<-` para hacer asignaciones. De este modo, podemos asignar el valor **3** a la variable **radio**
```{r ejemplo asignar, echo = TRUE}
radio <- 3
```

Hablaremos sobre asignaciones más adelante, en el capítulo de [operadores](##operadores-de-asignacion).

Es recomendable que al crear una variable usemos **nombres claros, no ambiguos y descriptivos**. Esto previene confusión y hace que nuestro código sea más fácil de comprender por otras personas o por nosotros mismos en el futuro.

Los nombres de las variables pueden incluir letras, números, puntos y guiones bajos. Deben empezar siempre con una letra o un punto y si empiezan con un punto, a este no le puede seguir un número.

Finalmente, cuando te encuentres con un renglón de código que inicia con un gato (hashtag), esto representa un comentario, es código que no se ejecutará, sólo se mostrará.
```{r, echo=TRUE}
# Este es un comentario
```

## Funciones (introducción básica)
Una función es **una serie de operaciones a la que les hemos asignados un nombre**. Las funciones aceptan **argumentos**, es decir, especificaciones sobre cómo deben funcionar.

Cuando llamamos una función, se realizan las operaciones que contiene, usando los argumentos que hemos establecido.

En R reconocemos a una función usando la notación: `nombre_de_la_función()`. Por ejemplo:

* `mean()`
* `quantile()`
* `summary()`
* `density()`
* `c()`

Al igual que con las variables, se recomienda que los nombres de las funciones sean claros, no ambiguos y descriptivos. Idealmente, el nombre de una función  describe lo que hace. De hecho, es probable que adivines qué hacen casi todas funciones de la lista de arriba a partir de su nombre.

Aunque estrictamente hablando una función es un objeto, para fines de explicación, en este libro nos referiremos a ambos como si fueran cosas diferentes.

Las funciones son un tema que revisamos más adelante. Por el momento, recuerda que una función realiza operaciones y nos pide argumentos para poder llevarlas a cabo.

## Documentación
Las funciones de R *base* y aquellas que forman parte de paquete tienen un archivo de documentación.

Este archivo describe qué hace la función, sus argumentos, detalles sobre las operaciones que realiza,los resultados que devuelve y ejemplos de uso.

Para obtener la documentación de una función, escribimos el `?` antes de su nombre y lo ejecutamos. También podemos usar la función `help()`, con el nombre de la función.

Los dos procedimientos siguientes son equivalentes.
```{r ayuda, echo=TRUE, eval=FALSE}
?mean()

help("mean")
```

Si usas RStudio, la documentación de la función se mostrará en uno de los paneles de este IDE. Si estas usando R directamente, se abrirá una ventana de tu navegador de Internet.

También podemos obtener la documentación de un paquete, si damos el argumento `package` a la función `help()`, con el nombre de un paquete.

Por ejemplo, la documentación del paquete **stats**, instalado por defecto en R *base*.
```{r, echo=TRUE, eval=FALSE}
help(package = "stats")
```


## Directorio de trabajo
El directorio o carpeta de trabajo es el lugar en nuestra computadora en el que se encuentran los archivos con los que estamos trabajando en R. Este es el lugar donde R buscara archivos para importarlos y al que serán exportados, a menos que indiquemos otra cosa.

Puedes encontrar cuál es tu directorio de trabajo con la función `getwd()`. Sólo tienes que escribir la función en la consola y ejecutarla.
```{r, echo = TRUE}
getwd()
```
Se mostrará en la consola la ruta del directorio que está usando R.

Puedes cambiar el directorio de trabajo usando la función `setwd()`, dando como argumento la ruta del directorio que quieres usar.
```{r, echo = TRUE, eval = FALSE}
setwd("C:\otro_directorio")
```

Por último, si deseas conocer el contenido de tu directorio de trabajo, puedes ejecutar. la función `list.files()`, sin argumentos, que devolverá una lista con el nombre de los archivos de tu directorio de trabajo. La función `list.dirs()`, también sin argumentos` te dará una lista de los directorios dentro del directorio de trabajo.

```{r list files y dirs, echo=TRUE, eval=FALSE}
# Ver archivos
list.files()

# Ver directorios
list.dirs()
```

### Sesión
Los objetos y funciones de R son almacenados en la memoria RAM de nuestra computadora.

Cuando ejecutamos R, ya sea directamente o a través de RStudio, estamos creando una instancia del entorno del entorno computacional de este lenguaje de programación. **cada instancia es una sesión**.

Todos los objetos y funciones creadas en una sesión, permanecen sólo en ella, no son compartidos entre sesiones, sin embargo una sesión puede tener el mismo directorio de trabajo que otra sesión.

Es posible tener más de una sesión de R activa en la misma computadora. Aunque ambas

Cuando cerramos R, también cerramos nuestra sesión. Se nos preguntará si deseamos guardar el contenido de nuestra sesión para poder volver a ella después. Esto se guarda en un archivo con extensión **.Rdata* en tu directorio de trabajo.

Para conocer los objetos y funciones que contiene nuestra sesión, usamos la función `ls()`, que nos devolverá una lista con los nombres de todo lo guardado en la sesión.
```{r, echo = TRUE, EVAL=FALSE}
ls()
```

De manera más precisa, nuestra sesión es un **entorno** de trabajo y los objetos pertenecen a un entorno específico. 

Los entornos son un concepto importante al hablar de lenguajes de programación, pero también son un tema que sale del alcance de este libro. 

Con que recuerdes que **cada sesión de R tiene su propio entorno global**, eso será suficiente.

## Paquetes
R puede ser expandido con **paquetes**. Cada paquete es una colección de funciones diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, minería de datos, interacción con servicios de Internet y muchas otras cosas más.

Estos paquetes se encuentran alojados en **CRAN**, así que pasan por un control riguroso antes de estar disponibles para su uso generalizado.

Podemos instalar paquetes usando la función `install.packages()`, dando como argumento el nombre del paquete que deseamos instalar, entre comillas.

Por ejemplo, para instalar el paquete **readr**, corremos lo siguiente.
```{r, echo=TRUE, eval=FALSE}
install.packages("readr")
```

Hecho esto, aparecerán algunos mensajes en la consola mostrando el avance de la instalación

Una vez concluida la instalación de un paquete, podrás usar sus funciones con la función `library()`. Sólo tienes que llamar esta función usando como argumento el nombre del paquete que quieres utilizar
```{r,echo=TRUE, eval=FALSE}
library(readr)
```

Cuando haces esto, R importa las funciones contenidas en el paquete al entorno de trabajo actual. 

Es importante que tengas en mente que debes hacer una llamada a  `library()` cada que inicies una sesión en R. Aunque hayas importado las funciones de un paquete con anterioridad, las sesiones de R se inician "limpias", sólo con los objetos y funciones de *base*.

Este comportamiento es para evitar problemas de compatibilidad y  para propiciar buenas prácticas de colaboración. 

Si importamos paquetes automáticamente y usamos sus funciones sin indicar de donde provienen, al compartir nuestro código con otras personas, estas no tendrán la información completa para entender qué estamos haciendo. R, al pedirnos que cada sesión indiquemos qué estamos importando, nos obliga a ser explícito con todo lo que estamos haciendo. Es un poco latoso, pero te acostumbras a ello.

En caso de escribir en `install.packages()` el nombre de un paquete no disponible en **CRAN**, se nos mostrará una advertencia y no se instalará nada.
```{r, echo=TRUE, eval=FALSE}
install.packages("un_paquete_falso")
```

Los paquetes que hemos importado en nuestra sesión actual aparecen al llamar `sessionInfo()`.

También podemos ver qué paquetes tenemos ya instalados ejecutando la función `installed.packages()` sin ningún argumento. Una instalación nueva de R tiene pocos paquetes instalados, pero esta lista puede crecer considerablemente con el tiempo.

## Scripts
Los *scripts* son documentos de texto con la extensión de archivo **.R**, por ejemplo `mi_script.R`.

Estos archivos son iguales a cualquier documentos de texto, pero R los puede leer y ejecutar el código que contienen.

Aunque R permite el uso interactivo, es recomendable que guardes tu código en un archivo .R, de esta manera puedes usarlo después y compartirlo con otras personas. En realidad, en proyectos complejos, es posible que sean necesarios múltiples *scripts* para distintos fines.

Podemos abrir y ejecutar *scripts* en R usando la función `source()`, dándole como argumento la ruta del archivo .R en nuestra computadora, entre comillas. 

Por ejemplo.
```{r source, echo=TRUE, eval=FALSE}
source("C:/Mis scripts/mi_script.R")
```

Cuando usamos RStudio y abrimos un *script* con extensión .R, este programa nos abre un panel en el cual podemos ver su contenido. De este modo podemos ejecutar todo el código que contiene o sólo partes de él.

<!--chapter:end:03-conceptos-basicos.Rmd-->

# Tipos de datos
En R los datos pueden ser de diferentes tipos. Cada tipo tiene características particulares que lo distinguen de los demás. Entre otras cosas algunas operaciones sólo pueden realizarse con tipos de datos específicos

En este capítulo revisaremos los tipos de datos más comunes en R y sus propiedades, así como la coerción entre tipos de dato.

## Datos más comunes
Los tipos de datos de uso más común en R son los siguientes.

Tipo            | Ejemplo | Nombre en inglés
-----           | -----   |----
Entero          | 1       | integer
Numérico        | 1.3     | numeric
Cadena de texto | "uno"   | character
Factor          | uno     | factor
Lógico          | TRUE    | logical
Perdido         | `NA`    | NA
Vacío           | `NULL`  | null

Además de estos tipos, en R también contamos con datos complejos numéricos complejos (con una parte real y una imaginaria), **raw** (bytes), fechas y *raster*, entre otros. Estos tipos tiene aplicaciones muy específicas, por ejemplo, los datos de tipo fecha son ampliamente usados en economía, para análisis de series de tiempo.

Revisemos las principales características de estos tipos de dato.

## Entero y numérico
Como su nombre lo indica, los datos enteros representan números enteros, sin una parte decimal o fraccionaria, que pueden ser usados en operaciones matemáticas. 

Por su parte, como su nombre lo indica, los datos numéricos representan números, la diferencia de estos con los datos enteros es que tiene una parte decimal o fraccionaria.

Los datos numéricos también son llamados *doble* o *float* (flotantes). Este nombre se debe a que, en realidad, son números de doble precisión, pues tienen una parte entera y una fraccionaria decimal, y son llamados *float* debido a que se usa un punto flotante para su representación computacional. 

Para fines prácticos, estos términos son sinónimos. En este libro, siempre que hablemos de datos numéricos, nos referimos a este tipo. 

## Cadena de texto
El tipo *character* representa texto y es fácil reconocerlo porque un dato siempre esta rodeado de comillas, simples o dobles. De manera convencional, nos referimos a este tipo de datos como cadenas de texto, es decir, secuencias de caracteres.

Este es el tipo de datos más flexible de R, pues una cadena de texto puede contener letras, números, espacios, signos de puntuación y símbolos especiales.

## Factor
Un factor es un tipo de datos específico a R. Puede ser descrito como un dato numérico representado por una etiqueta. 

Supongamos que tenemos un conjunto de datos que representan el sexo de personas encuestadas por teléfono, pero estos se encuentran capturados con los números 1 y 2. El número 1 corresponde a **femenino** y  el 2 a **masculino**. 

En R, podemos indicar que se nos muestre, en la consola y para otros análisis, los 1 como `femenino` y los 2 como `masculino`. Aunque para nuestra computadora, `femenino` tiene un valor de 1, pero a nosotros se nos muestra la palabra `femenino`. De esta manera reducimos el espacio de almacenamiento necesario para nuestros datos.

Este comportamiento es similar a lo que ocurre con paquetes estadísticos comerciales como *SPSS Statistics*, en los que podemos asignar etiquetas a los datos, dependiendo de su valor. La diferencia se encuentra en que R trata a los factores de manera diferente a un dato numérico.

Por último, cada una de las etiquetas o valores que puedes asumir un factor se conoce como **nivel**. En nuestro ejemplo con `femenino` y `masculino`, tendríamos dos niveles.

## Lógico
Los datos de tipo lógico sólo tienen dos valores posibles: verdadero (`TRUE`) y falso (`FALSE`). Representan si una condición o estado se cumple, es verdadero, o no, es falso.

Este tipo de dato es, generalmente, el resultado de operaciones relacionales y lógicas, son esenciales para trabajar con **álgebra Booleana**, lo cual revisaremos en el (capítulo 5)(#-operadores).

Como este tipo de dato sólo admite dos valores específicos, es el más restrictivo de R.

## `NA` y `NULL`
En R, usamos `NA` para representar datos perdidos, mientras que `NULL` representa la ausencia de datos.

La diferencia entre las dos es que un dato `NULL` aparece sólo cuando R intenta recuperar un dato y no encuentra nada, mientras que `NA` es usado para representar de modo explícito datos perdidos, omitidos o que por alguna razón son faltantes.

Por ejemplo, si tratamos de recuperar la edad de una persona encuestada que no existe, obtendríamos un `NULL`, pues no hay ningún dato que corresponda con ello. En cambio, si tratamos de recuperar su estado civil, y la persona encuestada no contestó esta pregunta, obtendríamos un `NA`.

`NA` además puede aparecer como resultado de una operación realizada, pero no tuvo éxito en su ejecución.

## Coerción
En R, los datos pueden ser coercionados, es decir, forzados, para transformarlos de un tipo a otro.

La coerción es muy importante. Cuando pedimos a R ejecutar una operación, intentará coercionar de manera **implícita**, sin avisarnos, los datos de su tipo original al tipo correcto que la permita realizar. Habrá ocasiones en las que R tenga éxito y la operación ocurra sin problemas, y otras en las que falle y obtengamos un error.

Lo anterior ocurre porque no todos los tipos de datos pueden ser transformados a los demás, para ello se sigue una regla general.

**La coerción de tipos se realiza de los tipos de datos más restrictivos a los más flexibles.**

Las coerciones ocurren en el siguiente orden.

`lógico -> entero -> numérico -> cadena de texto`
(`logical -> integer -> numeric -> character`)

Las coerciones no pueden ocurrir en orden inverso. Podemos coercionar un dato de tipo entero a uno numérico, pero uno de cadena de texto a numérico.

Como los datos de tipo lógico sólo admiten dos valores (`TRUE` y `FALSE`), estos son los más restrictivos; mientras que los datos de cadena de texto, al admitir cualquier cantidad y combinación de caracteres, son los más flexibles. 

Los factores son un caso particular para la coerción. Dado que son valores numéricos con etiquetas, pueden ser coercionados a tipo numérico y cadena de texto; y los datos numéricos y cadena de texto pueden ser coercionados a factor. Sin embargo, al coercionar un factor tipo numérico, perdemos sus niveles.

### Coerción explícita con la familia `as()`
También podemos hacer coerciones **explícitas** usando la familia de funciones `as()`.

Función           | Tipo al que hace coerción
-----             | -----
`as.integer()`    | Entero
`as.numeric()`    | Numérico
`as.character()`  | Cadena de texto
`as.factor()`     | Factor
`as.logical()`    | Lógico
`as.null()`       | `NULL`

Todas estas funciones aceptan como argumento datos o vectores (veremos qué es un vector en el [capítulo 6](#estructuras-de-datos)). 

Cuando estas funciones tienen éxito en la coerción, nos devuelven datos del tipo pedido. Si fallan, obtenemos `NA` como resultado.

Por ejemplo, intentemos convertir el número 5 a una cadena de texto. Para ello usamos la función `as.character()`.
```{r number_as_character, echo=TRUE}
as.character(5)
```

Esta es una coerción válida, así que tenemos éxito. Pero, si intentamos convertir la palabra "cinco" a un dato numérico, obtendremos una advertencia y `NA`.
```{r char_as_num, echo=TRUE}
as.numeric("cinco")
```

Comprobemos el comportamiento especial de los factores. 

Podemos coercionar al número 5 y la palabra "cinco" en un factor. 

```{r chnum_asfactor, echo=TRUE}
as.factor(5)
as.factor("cinco")
```

Asignamos la palabra "cinco" como factor al objeto `factor_cinco`.
```{r, echo =TRUE}
factor_cinco <- as.factor("cinco")

#Resultado
factor_cinco
```

Ahora podemos coercionar `factor_cinco` a cadena de texto y a numérico.
```{r, echo=TRUE}
# Cadena de texto
as.character(factor_cinco)

# Numérico
as.numeric(factor_cinco)
```

Si coercionamos un dato de tipo lógico a numérico, `TRUE` siempre devolverá 1 y `FALSE` dará como resultado 0.
```{r logic_asnum, echo=TRUE}
as.numeric(TRUE)
as.numeric(FALSE)
```

Por último, la función `as.null()` siempre devuelve `NULL`, sin importar el tipo de dato que demos como argumento.

```{r asnull, echo=TRUE}
# Lógico
as.null(FALSE)
# Numérico
as.null(457)
# Cadena de texto
as.null("palabra")
```

## Verificar el tipo de un dato
En ocasiones, tenemos datos pero no sabemos de simple vistazo de qué tipo son. Para esto casos, podemos usar la función `class()` para determinar el tipo de un dato. Esto es de utilidad para asegurarnos que las operaciones que deseamos realizar tendrán los datos apropiados para llevarse a cabo con éxito.

`class()` recibe como argumento un dato o vector y devuelve el nombre del tipo al que pertenece, en inglés.

Por ejemplo, verificamos el tipo de datos que son 3, "3" y `TRUE`.
```{r class, echo=TRUE}
class(3)
class("3")
class(TRUE)
```

### Verificación con la familia de funciones `is()`
También podemos verificar si un dato es de un tipo específico con la familia de funciones `is()`. 

Función           | Tipo que verifican
-----             | -----
`is.integer()`    | Entero
`is.numeric()`    | Numérico
`is.character()`  | Cadena de texto
`is.factor()`     | Factor
`is.logical()`    | Lógico
`is.na()`         | `NA`
`is.null()`       | `NULL`

Estas funciones toman como argumento un dato, si este es del tipo que estamos verificando, nos devolverán `TRUE` y en caso contrario devolverán `FALSE`.

Por ejemplo, verificamos que 5 sea numérico.
```{r is_num, echo=TRUE}
is.numeric(5)
```
Obtenemos `TRUE`, pues es verdadero que este es un dato numérico.

Verificamos que `5` sea de tipo cadena de texto.
```{r is_char, echo=TRUE}
is.character(5)
```
El resultado es `FALSE`, por lo tanto este no es un dato de cadena de texto.

Conociendo el tipo de datos con los que estamos trabajando, nos aseguramos de que obtendremos los resultados esperados para las operaciones que estemos realizando.

<!--chapter:end:04-datos.Rmd-->

# Operadores
Los operadores son los símbolos que le indican a R que debe realizar una tarea. Combinando datos y operadores es que logramos que R haga su trabajo.

Existen operadores específicos para cada tipo de tarea. Los tipos de operadores principales son los siguientes:

* Aritméticos
* Relacionales
* Lógicos
* De asignación

Familiarizarnos con los operadores nos permitirá manipular y transformar datos de distintos tipos. 

## Operadores aritméticos
Como su nombre lo indica, este tipo de operador es usado para operaciones aritméticas.

En R tenemos los siguientes operadores aritméticos:

Operador  | Operación       | Ejemplo | Resultado
----      |----             |----     |----
`+`       | Suma            | `5 + 3` | 8
`-`       | Resta           | `5 - 3` | 2
`*`       | Multiplicación  | `5 * 3` | 18
`/`       | División        | `5 /3`  | 1.666667
`^`       | Potencia        | `5 ^ 3` | 125
`%%`      | División entera | `5 %% 3`| 2

Es posible realizar operaciones aritméticas con datos de tipo **entero** y **numérico**. 

Si escribes una operación aritmética en la consola de R y das *Enter*, esta se realiza y se devuelve su resultado.
```{r, echo=TRUE}
15 * 3
```

Cuando intentas realizar una operación aritmética con otro tipo de dato, R primero intentará coercionar ese dato a uno numérico. Si la coerción tiene éxito se realizará la operación normalmente, si falla, el resultado será un error.

Por ejemplo, `4 + "tres"` devuelve: `Error in 4 + "tres" : non-numeric argument for binary operator."`
```{r, echo=TRUE, error=TRUE}
4 + "tres"
```
  
El mensaje *"non-numeric argument for binary operator"* aparece siempre que intentas realizar una operación aritmética con un argumento no numérico. Si te encuentras un un error que contiene este mensaje, es la primera pista para que identifiques donde ha ocurrido un problema.

Cualquier operación aritmética que intentemos con un dato `NA`, devolverá `NA` como resultado.
```{r, echo = TRUE}
NA - 66

21 * NA

NA ^ 13
```

### La división entera
Entre los operadores aritméticos, el de división entera o **módulo** requiere una explicación adicional sobre su uso. La operación que realiza es una división de un número entre otro, pero en lugar de devolver el cociente, nos devuelve el residuo.

Por ejemplo, si hacemos una división entera de 4 entre 2, el resultado será 0. Esta es una división exacta y no tiene residuo.
```{r, echo =TRUE}
4 %% 2
```

En cambio, si hacemos una división entera de 5 entre 2, el resultado será 1, pues este es el residuo de la operación.
```{r, echo =TRUE}
5 %% 2
```

## Operadores relacionales
Los operadores lógicos son usados para hacer comparaciones y siempre devuelven como resultado `TRUE` o `FALSE` (verdadero o falso, respectivamente).

Operador| Comparación           | Ejemplo   | Resultado
----    |----                   |----       |----
`<`     | Menor que             | `5 < 3`   | `FALSE`
`<=` 	  | Menor o igual que     | `5 <= 3`  | `FALSE`
`>`     |	Mayor que             | `5 > 3`   | `TRUE`
`>=` 	  | Mayor o igual que     | `5 >= 3`  | `TRUE`
`==` 	  | Exactamente igual que | `5 == 3`  | `FALSE`
`!=` 	  | No es igual que       | `5 != 3`  | `TRUE`

Es posible comparar cualquier tipo de dato sin que resulte en un error.

Sin embargo, al usar los operadores `>`, `>=`, `<` y `<=` con cadenas de texto, estos tienen un comportamiento especial. 

Por ejemplo, `"casa" > "barco"` nos devuelve `TRUE`.
```{r}
"casa" > "barco"
```

Este resultado se debe a que se ha hecho una comparación por orden alfabético. En este caso, la palabra "casa" tendría una posición posterior a "barco", pues empieza con "c" y esta letra tiene una posición posterior a la "b" en el alfabeto. Por lo tanto, es verdadero que sea "mayor".

Cuando intentamos comparar factores, siempre obtendremos como resultado `NA` y una advertencia acerca de que estos operadores no son significativos para datos de tipo factor.
```{r, echo=TRUE}
as.factor("casa") > "barco"
```

## Operadores lógicos
Los operadores lógicos son usados para operaciones de **álgebra Booleana**, es decir, para describir relaciones lógicas, expresadas como verdadero (`TRUE`) o falso (`FALSO`).
  
Operador    | Comparación                   | Ejemplo         | Resultado
----        |----                           |----             |----
`x | y`     |	x Ó y es verdadero            | `TRUE | FALSE`  | `TRUE`
`x & y`     |	x Y y son verdaderos          | `TRUE & FALSE`  | `FALSE`
`!x`        |	x no es verdadero (negación)  | `!TRUE`         | `FALSE`
`isTRUE(x)` |	x es verdadero (afirmación)   | `isTRUE(TRUE)`  | `TRUE`

Los operadores `|` y `&` siguen estas reglas:

* `|` devuelve `TRUE` si alguno de los datos es `TRUE`
* `&` solo devuelve `TRUE` si ambos datos es `TRUE`
* `|` solo devuelve `FALSE` si ambos datos son `FALSE`
* `&` devuelve `FALSE` si alguno de los datos es `FALSE`

Estos operadores pueden ser usados con estos con datos de tipo **numérico**, **lógico** y **complejo**. Al igual que con los operadores relacionales, los operadores lógicos siempre devuelven `TRUE` o `FALSE`.

Para realizar operaciones lógicas, todos los valores numéricos y complejos distintos a `0` son coercionados a `TRUE`, mientras que `0` siempre es coercionado a `FALSE`. 

Por ejemplo, `5 | 0` resulta en `TRUE` y `5 & FALSE` resulta en `FALSE`. Podemos comprobar lo anterior con la función `isTRUE()`.
```{r, echo=TRUE}
5 | 0

5 & 0

isTRUE(0)

isTRUE(5)
```

Estos operadores se pueden combinar para expresar relaciones complejas.

Por ejemplo, la negación `FALSE` Y `FALSE` dará como resultado `TRUE`.
```{r, }
!(FALSE | FALSE)
```

También podemos combinar operadores lógicos y relacionales, dado que esto últimos dan como resultado `TRUE` y `FALSE`.
```{r, echo=FALSE}
(4 < 6) | (6 == 6)
```

## Operadores de asignación
Este es probablemente el operador más importante de todos, pues nos permite asignar datos a variables.

Operador  | Operación   
----      |----         
`<-`      | Asigna un valor a una variable
`=`       | Asigna un valor a una variable

Aunque podemos usar el signo igual para una asignación, a lo largo de este libro utilizaremos `<-`, por ser característico de R y fácil de reconocer visualmente.

Después de realizar la operación de asignación, podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya habíamos asignado datos, nuestra variable conserva el valor más reciente.

Además, esta operación nos permite "guardar" el resultado de operaciones, de modo que los podemos recuperar sin necesidad de realizar las operaciones otra vez. Basta con llamar el nombre de la variable en la consola

En este ejemplo, asignamos valores a las variables `estatura` y `peso`.
```{r, echo=TRUE}
estatura <- 1.73
peso <- 83
```
Llamamos a sus valores asignados
```{r, echo=TRUE}
estatura
peso
```

Usamos los valores asignados para realizar operaciones.
```{r, echo=TRUE}
peso / estatura ^ 2
```

Cambiamos el valor de una variable a uno nuevo y realizamos operaciones
```{r, echo=TRUE}
peso <- 76

peso

peso / estatura ^ 2

estatura <- 1.56
peso <- 48

peso / estatura ^ 2
```

Asignamos el resultado de una operación a una variable nueva.
```{r, echo = TRUE}
bmi <- peso / estatura ^ 2

bmi
```

Como podrás ver, es posible asignar a una variable valores de otra variable o el resultado de operaciones con otras variables.
```{r, echo=TRUE}
velocidad_inicial <- 110
velocidad_final <- 185

tiempo_inicial <- 0
tiempo_final <- 15

variacion_velocidad <- velocidad_final - velocidad_inicial
variacion_tiempo <- tiempo_final - tiempo_inicial

variacion_velocidad / variacion_tiempo
```

## Orden de operaciones
En R, al igual que en matemáticas, las operaciones tienen un orden de evaluación definido. 

Cuanto tenemos varias operaciones ocurriendo al mismo tiempo, en realidad, algunas de ellas son realizadas antes que otras y el resultado de ellas dependerá de este orden.

El orden de operaciones incluye a las aritméticas, relacionales, lógicas y de asignación.

En la tabla siguiente se presenta el orden en que ocurren las operaciones que hemos revisado en este capítulo.

Orden | Operadores
---   |---
1     | `^`          
2     | `*` `/`
3     | `+` `-`
4     | `<` `>` `<=` `>=` `==` `!=`
5     | `!`
6     | `&`
7     | `|`
8     | `<-`

Si deseamos que una operación ocurra antes que otra, rompiendo este orden de evaluación, usamos paréntesis.


```{r}

```


Podemos tener paréntesis anidados.
```{r}

```



<!--chapter:end:05-operadores.Rmd-->

# Estructuras de datos
Las estructuras de datos son objetos que contienen datos. Cuando trabajamos con R, lo que estamos haciendo es manipular estas estructuras.

Las estructuras tienen diferentes características. Entre ellas, las que distinguen a una estructura de otra son su número de **dimensiones** y si son **homogeneas** o **hereterogeneas**.

La siguiente tabla muestra las principales estructuras de control que te encontrarás en R.

Dimensiones| Homogéneas| Heterogéneas
----       |----       |----
1          | Vector    | Lista
2          | Matriz    | Data frame 
n          | Array     | 
*Adaptado de Wickham (2016).*

Veamos las características de cada una de ellas.

## Vectores
Un vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo.

Todos los vectores tienen tres propiedades:

* **Tipo**. Un vector tiene el mismo tipo que los datos que contiene. Si tenemos un vector que contiene datos de tipo numérico, el vector será también de tipo numérico. Los vectores son **atómicos**, pues sólo pueden contener datos de un sólo tipo, no es posible mezclar datos de tipos diferentes dentro de ellos.
* **Largo**. Es el número de elementos que contiene un vector. El largo es la única **dimensión** que tiene esta estructura de datos.
* **Atributos**. Los vectores pueden tener metadatos de muchos tipos, los cuales describen características de los datos que contienen. Todos ellos son incluidos en esta propiedad. En este libro no se usarán vectores con metadatos, por ser una propiedad con usos van más allá del alcance de este libro.

Cuando una estructura únicamente puede contener datos de un sólo tipo, como es el caso de los vectores, decimos que es **homogénea**, pero no implica que necesariamente sea **atómica**. Regresaremos sobre esto al hablar de matrices y arrays.

Como los vectores son la estructura de datos más sencilla de R, datos simples como el número **3**, son en realidad vectores. En este caso, un vector de tipo numérico y largo igual a 1.
```{r, echo=TRUE}
3
```

Verificamos que  el **3** es un vector con la función `is.vector()`.
```{r, echo=TRUE}
is.vector(3)
```

Y usamos la función `length()` para conocer su largo.
```{r, echo=TRUE}
length(3)
```

Lo mismo ocurre con los demás tipos de datos, por ejemplo, con cadenas de texto y datos lógicos.
```{r, echo=TRUE}
is.vector("tres")
is.vector(TRUE)
```

### Creación de vectores
Creamos vectores usando la función `c()` (*combinar*). 

Llamamos esta función y le damos como argumento los elementos que deseamos combinar en un vector, separados por comas.
```{r, echo=TRUE}
# Vector numérico
c(1, 2, 3, 5, 8, 13)

# Vector de cadena de texto
c("arbol", "casa", "persona")

# Vector lógico
c(TRUE, TRUE, FALSE, FALSE, TRUE)
```

Si deseamos agregar un elemento a un vector ya existente, podemos hacerlo combinando nuestro vector original con los elementos nuevos y asignando el resultado a nuestro vector original.
```{r, echo=TRUE}
mi_vector <- c(TRUE, FALSE, TRUE)

mi_vector <- c(mi_vector, FALSE)

mi_vector
```

Naturalmente, podemos crear vectores que son combinación de vectores.
```{r, echo=TRUE}
mi_vector_1 <- c(1, 3, 5)
mi_vector_2 <- c(2, 4, 6)

mi_vector_3 <- c(mi_vector_1, mi_vector_2)

mi_vector_3
```

Si intentamos combinar datos de diferentes tipos en un mismo vector, R realizará coerción automáticamente. El vector resultante será del tipo más flexible entre los datos que contenga, siguiendo las reglas de ***coerción***.

Creamos un vector numérico.
```{r, echo=TRUE}
mi_vector <- c(1, 2, 3)

class(mi_vector)
```

Si intentamos agregar un dato de tipo cadena de texto, nuestro vector ahora será de tipo cadena de texto.
```{r}
mi_vector_nuevo <- c(mi_vector, "a")

class(mi_vector_nuevo)
```

Como las cadenas de texto son el tipo de dato más flexible, siempre que creamos un vector que incluye un dato de este tipo, el resultado será un vector de texto.
```{r}
mi_vector_mezcla <- c(FALSE, 2, "tercero", 4.00)

class(mi_vector_mezcla)
```

Podemos crear vectores de secuencias numéricas usando `:`. De un lado de los dos puntos escribimos el número de inicio de la secuencia y del otro el final.

Por ejemplo, creamos una secuencia del 1 al 10.
```{r dos puntos, echo=TRUE}
1:10
```

También podemos crear una secuencia del 10 al 1.
```{r dos puntos dec, echo=TRUE}
10:1
```

Las secuencias creadas con `:` son consecutivas con incrementos o decrementos de 1. Estas secuencias pueden empezar con cualquier número, incluso si este es negativo o tiene cifras decimales

```{r dos puntos otros, echo=TRUE}
# Número negativo
-43:-30

# Número con cifras decimales
67.23:75
```

Si nuestro número de inicio tiene cifras decimales, estas serán respetadas al hacer los incrementos o decrementos de uno en uno. En contraste, si es nuestro número de final el que tiene cifras decimales, este será redondeado.
```{r dos puntos dec 2, echo=TRUE}
# Se conservan los decimales del inicio
-2.48:2

56.007:50

# Se redondean los decimales del final
166:170.05

968:960.928
```

### Vectorización de operaciones
Existen algunas operaciones al aplicarlas a un vector, se aplican a cada uno de sus elementos. A este proceso le llamamos **vectorización**.

Las operaciones aritméticas y relacionales pueden vectorizarse. Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene.

Por ejemplo, creamos un vector numérico.
```{r mi_vector_vectorizacion, echo=TRUE}
mi_vector <- c(2, 3, 6, 7, 8, 10, 11)
```

Si aplicamos operaciones aritméticas, obtenemos un vector con un resultado por cada elemento.
```{r vecotirzacion_arit, echo=TRUE}
# Operaciones aritméticas
mi_vector + 2
mi_vector * 2
mi_vector %% 2
```

Al aplicar operaciones relacionales, obtenemos un vector de `TRUE`y `FALSE`, uno para cada elemento comparado.
```{r vectorizacion_rela, echo=TRUE}
mi_vector > 7
mi_vector < 7
mi_vector == 7
```

Esta manera de aplicar una operación es muy eficiente. Comparada con otros procedimientos, requiere de menos tiempo de cómputo, lo cual a veces es considerable, en particular cuando trabajamos con un número grande de datos.

Aunque el nombre de este proceso es **vectorización**, también funciona, en ciertas circunstancias, para otras estructuras de datos.

## Matrices y arrays
Las matrices y arrays pueden ser descritas como **vectores multidimensionales**. Al igual que un vector, únicamente pueden contener datos de un sólo tipo, pero además de largo, tienen más dimensiones.

En un sentido estricto, las matrices son una caso especial de un array, que se distingue por tener **específicamente dos dimensiones**, un "largo"" y un "alto". Las matrices son, por lo tanto, una estructura con forma rectangular, con renglones y columnas.

Como las matrices son usadas de manera regular en matemáticas y estadística, es una estructura de datos de uso común en R común y en la que nos enfocaremos en este libro.

Los arrays, por su parte, pueden tener un número arbitrario de dimensiones. Pueden ser cubos, hipercubos y otras formas. Su uso no es muy común en R, aunque a veces es deseable contar con objetos n-dimensionales para manipular datos. Como los arrays tienen la restricción de que todos sus datos deben ser del mismo tipo, no importando en cuántas dimensiones se encuentren, esto limita sus usos prácticos. 

En general, es preferible usar listas en lugar de arrays, una estructura de datos que además tienen ciertas ventajas que veremos más adelante.

### Creación de matrices
Creamos matrices en R con la función `matrix()`. La función `matrix()` acepta dos argumentos, `nrow` y `ncol`. Con ellos especificamos el número de renglones y columnas que tendrá nuestra matriz.
```{r, echo=TRUE}
# Un vector numérico del uno al doce
1:12

# matrix() sin especificar renglones ni columnas
matrix(1:12)

# Tres renglones y cuatro columnas
matrix(1:12, nrow = 3, ncol = 4)

# Cuatro columnas y tres columnas
matrix(1:12, nrow = 4, ncol = 3)

# Dos renglones y seis columnas
matrix(1:12, nrow = 4, ncol = 3)
```

Los datos que intentemos agrupar en una matriz serán acomodados en orden, de arriba a abajo, y de izquierda a derecha, hasta formar un rectángulo.

Si multiplicamos el número de renglones por el número de columnas, obtendremos el número de celdas de la matriz. En los ejemplo anteriores, el número de celdas es igual al número de elementos que queremos acomodar, así que la operación ocurre sin problemas.

Cuando intentamos acomodar un número diferente de elementos y celdas, ocurren dos cosas diferentes. 

Si el número de elementos es mayor al número de celdas, se acomodarán todos los datos que sean posibles y los demás se omitirán. 
```{r, echo=TRUE}
matrix(1:12, nrow = 3, ncol = 3)
```

Si, por el contrario, el número de celdas es mayor que el número de elementos, estos se **reciclaran**. En cuanto los elementos sean insuficientes para acomodarse en las celdas, R nos devolverá una advertencia y se empezaran a usar los elementos a partir del primero de ellos
```{r, echo=TRUE}
matrix(1:12, nrow = 5, ncol = 4)
```

Otro procedimiento para crear matrices es la unión vectores con las siguientes funciones:

* `cbind()` para unir vectores, usando cada uno como una columna.
* `rbind()` para unir vectores, usando cada uno como un renglón.

De este modo podemos crear cuatro vectores y unirlos para formar una matriz. Cada vector será un renglón en esta matriz.

Creamos cuatro vectores, cada uno de largo igual a cuatro.
```{r, echo = TRUE}
vector_1 <- 1:4
vector_2 <- 5:8
vector_3 <- 9:12
vector_4 <- 13:16
```

Usamos `rbind()` para crear un matriz, en la que cada vector será un renglón.
```{r, echo = TRUE}
matriz <- rbind(vector_1, vector_2, vector_3, vector_4)

# Resultado
matriz
```

Si utilizamos `cbind()`, entonces cada vector será una columna.
```{r, echo = TRUE}
matriz <- cbind(vector_1, vector_2, vector_3, vector_4)

# Resultado
matriz
```

Al igual que con `matrix()`, los elementos de los vectores son reciclados para formar una estructura rectangular y se nos muestra un mensaje de advertencia.
```{r, echo = TRUE}
# Elementos de largo diferente
vector_1 <- 1:2
vector_2 <- 1:3
vector_3 <- 1:5

matriz <- cbind(vector_1, vector_2, vector_3)

# Resultado
matriz
```

Finalmente, las matrices pueden contener `NA`s.

Creamos dos vectores con un `NA` en ellos.
```{r, echo=TRUE}
vector_1 <- c(NA, 1, 2)
vector_2 <- c(3,  4, NA)
```

Creamos una matriz con `rbind()`.
```{r}
matriz <- rbind(vector_1, vector_2)

# Resultados
matriz
```

Como `NA` representa datos perdidos, puede estar presente en compañía de todo tipo de de datos.

### Propiedades de las matrices
No obstante que las matrices y arrays son estructuras que sólo pueden contener un tipo de datos, no son atómicas. Su clase es igual a **matriz (matrix)** o **array** según corresponda.

Verificamos esto usando la función `class()`.
```{r, echo=TRUE}
mi_matriz <- matrix(1:10)

class(mi_matriz)
```

Las matrices y arrays pueden tener más de una dimensión.

Obtenemos el número de dimensiones de una matriz o array con la función `dim()`. Esta función nos devolverá varios números, cada uno de ellos indica la cantidad de elementos que tiene una dimensión.
```{r, echo=TRUE}
mi_matriz <- matrix(1:12, nrow = 4, ncol = 3)
dim(mi_matriz)
```

Cabe señalar que si usamos `dim()` con un vector, obtenemos `NULL`. Esto ocurre con todos los objetos unidimensionales 
```{r, echo=TRUE}
mi_vector <- 1:12

dim(mi_vector)
```

Finalmente, las operaciones aritméticas también son vectorizadas al aplicarlas a una matriz. La operación es aplicada a cada uno de los elementos de la matriz.

Creamos una matriz.
```{r, echo=TRUE}
mi_matriz <- matrix(1:9, nrow = 3, ncol = 3)

# Resultado
mi_matriz
``` 

Intentemos sumar, multiplicar y elevar a la tercera potencia.
```{r}
# Suma
mi_matriz + 1

# Multiplicación
mi_matriz * 2

# Potenciación
mi_matriz ^ 3
```

Si intentamos vectorizar una operación utilizando una matriz con `NA`s, esta se aplicará para los elementos válidos, devolviendo `NA` cuando corresponda.

Creamos una matriz con `NA`s.
```{r, echo=TRUE}
vector_1 <- c(NA, 2, 3)
vector_2 <- c(4, 5, NA)

matriz <- rbind(vector_1, vector_2)

# Resultado
matriz
```

Intentamos dividir sus elementos entre dos.
```{r, echo=T}
matriz / 2
```

Finalmente, podemos usar la función `t()` para transponer una matriz, es decir, rotarla 90°.

Creamos una matriz con tres renglones y dos columnas.
```{r, echo=TRUE}
matriz <- matrix(1:6, nrow = 3)

# Resultado
matriz
```

Usamos `t()` para transponer.
```{r, echo=TRUE}
matriz_t <- t(matriz)

# Resultado
matriz_t
```

Obtenemos una matriz con dos renglones y dos columnas.

## Data frames
Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas. Esta estructura de datos es la más usada para realizar análisis de datos y seguro te resultará familiar si has trabajado con otros paquetes estadísticos.

Podemos entender a los data frames como una versión más flexible de una matriz. Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo.

En términos generales, los renglones en un data frame representan casos, individuos u observaciones, mientras que las columnas representan atributos, rasgos o variables. 
Por ejemplo, así lucen los primeros cinco renglones del objeto **iris**, el famoso conjunto de datos  *Iris de Ronald Fisher*, que está incluido en todas las instalaciones de R.
```{r, echo=FALSE}
head(iris, 5)
```

Los primeros cinco renglones corresponden a cinco casos, en este caso flores. Las columnas son variables con los rasgos de cada flor: largo y ancho de sépalo, largo y ancho de pétalo, y especie.

Para crear un data frame usamos la función `data.frame()`. Esta función nos pedirá un número de vectores igual al número de columnas que deseemos. Todos los vectores que proporcionemos deben tener el mismo largo. 

Esto es muy importante: **Un data frame está compuesto por vectores**.

Más adelante se hará evidente porque esta característica de un data frame es sumamente importante y también, cómo podemos sacarle provecho.

Además, podemos asignar un nombre a cada vector, que se convertirá en el nombre de la columna. Como todos los nombres, es recomendable que este sea claro, no ambiguo y descriptivo.
```{r, echo = TRUE}
mi_df <- data.frame(
  "entero" = 1:4, 
  "factor" = c("a", "b", "c", "d"), 
  "numero" = c(1.2, 3.4, 4.5, 5.6),
  "cadena" = as.character(c("a", "b", "c", "d"))
)

mi_df

# Podemos usar dim() en un data frame
dim(mi_df)

# El largo de un data frame es igual a su número de columnas
length(mi_df)

# names() nos permite ver los nombres de las columnas
names(mi_df)

# La clase de un data frame es data.frame
class(data.frame) 
```

Si los vectores que usamos para construir el data frame no son del mismo largo, los datos **no se reciclaran**. Se nos devolverá un error.
```{r, echo=TRUE, error=TRUE}
data.frame(
  "entero" = 1:3, 
  "factor" = c("a", "b", "c", "d"), 
  "numero" = c(1.2, 3.4, 4.5, 5.6),
  "cadena" = as.character(c("a", "b", "c", "d"))
)
```

También podemos coercionar esta matriz a un data frame.

Creamos una matriz.
```{r}
matriz <- matrix(1:12, ncol = 4)
```

Usamos `as.data.frame()` para coercionar una matriz a un data frame.
```{r}
df <- as.data.frame(matriz)
```

Verificamos el resultado
```{r}
class(df)

# Resultado
df
```

### Propiedades de un data frame
Al igual que con una matriz, si aplicamos una operación aritmética a un data frame, esta se vectorizará. 

Los resultados que obtendremos dependerán del tipo de datos de cada columna. R nos devolverá todas las advertencias que ocurran como resultado de las operaciones realizadas, por ejemplo, aquellas que hayan requerido una coerción.
```{r, echo=TRUE}
mi_df <- data.frame(
  "entero" = 1:4, 
  "factor" = c("a", "b", "c", "d"), 
  "numero" = c(1.2, 3.4, 4.5, 5.6),
  "cadena" = as.character(c("a", "b", "c", "d"))
)

# mi_df * 2
```

## Listas
Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero a diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase, por lo que son estructuras heterogéneas.

Podemos tener listas que contengan datos atómicos, vectores, matrices, arrays, data frames u otras listas. Esta última característica es la razón por la que una lista puede ser considerada un vector recursivo, pues es un objeto que puede contener objetos de su misma clase.

Para crear una lista usamos la función `list()`, que nos pedirá los elementos que deseamos incluir en nuestra lista. Para esta estructura, no importan las dimensiones o largo de los elementos que queramos incluir en ella. 

Al igual que con un data frame, tenemos la opción de poner nombre a cada elemento de una lista.

Por último, no es posible vectorizar operaciones aritméticas usando una lista, se nos devuelve un error como resultado.
```{r, echo = TRUE, error=TRUE}
mi_vector <- 1:10
mi_matriz <- matrix(1:4, nrow = 2)
mi_df     <- data.frame("num" = 1:3, "let" = c("a", "b", "c"))

mi_lista <- list("un_vector" = mi_vector, "una_matriz" = mi_matriz, "un_df" = mi_df)

mi_lista
```

Creamos una lista que contiene otras listas.
```{r, echo=TRUE}
lista_recursiva <- list("lista1" = mi_lista, "lista2" = mi_lista)

# Resultado
lista_recursiva
```

### Propiedades de una lista
Una lista es unidimensional, sólo tiene largo.

El largo de una lista es igual al número de elementos que contiene, sin importar de qué tipo o clase sean. Usamos la lista recursiva que creamos en la sección anterior para ilustrar esto.
```{r, echo=TRUE}
length(lista_recursiva)
```

Dado que una lista siempre tiene una sola dimensión, la función `dim()` nos devuelve `NULL`.
```{r, echo=TRUE}
dim(lista_recursiva)
```

Las listas tienen clase **list**, sin importar qué elementos contienen.
```{r, echo=TRUE}
class(lista_recursiva)
```

Finalmente, no es posible vectorizar operaciones aritméticas usando listas. Al intentarlo nos es devuelto un error.
```{r, echo=TRUE, error=TRUE}
mi_lista / 2
```

Si deseamos aplicar una función a cada elemento de una lista, usamos `lapply()`, como veremos en el [capítulo 10](#apply).

## Coerción
Al igual que con los datos, cuando intentamos hacer operaciones con una estructura de datos, R intenta coercionarla al tipo apropiado para poder llevarlas a cabo con éxito.

También podemos usar alguna de las funciones de la familia `as()` coercionar de un tipo de estructura de datos. A continuación se presentan las más comunes.

Función           | Coerciona a | Coerciona exitosamente a
----              |----         | ----
`as.vector()`     | Vector      | Matrices
`as.matrix()`     | Matrices    | Vectores, Data frames
`as.data.frame()` | Data frame  | Vectores, Matrices              
`as.list()`       | Lista       | Vectores, Matrices, Data frames

Como podrás ver, las estructuras de datos más sencillas, (unidimensionales, homogéneas) pueden ser coercionadas a otras más complejas (multidimensionales, heterogéneas), pero la operación inversa casi nunca es posible.

Veamos algunos ejemplos.

Creamos un vector, una matriz, un data frame y una lista.
```{r crear_estructuras, echo=TRUE}
mi_vector <- c("a", "b", "c")
mi_matriz <- matrix(1:4, nrow = 2)
mi_df <- data.frame("a" = 1:2, "b" = c("a", "b"))
mi_lista <- list("a" = mi_vector, "b" = mi_matriz, "c" = mi_df)
```

Intentemos coercionar a vector con `as.vector()`.
```{r as_vector, echo=TRUE}
as.vector(mi_matriz)
as.vector(mi_df)
as.vector(mi_lista)
```

La coerción que intentamos sólo tuvo éxito para una matriz. Para data frame y lista, nos devolvió los mismos objetos.

Nota que `as.vector()` **no devolvió un error o una advertencia a pesar de que no tuvo éxito** al coercionar, en este caso un data frame o una lista. Esto es importante, pues no puedes confiar que `as.vector()` tuvo éxito porque corrió sin errores, es necesaria una verificación adicional. Como R intenta coercionar automáticamente, esto puede producir resultados inesperados si no tenemos cuidado.

Intentemos coercionar a matriz con `as.matrix()`.
```{r, echo=TRUE}
as.matrix(mi_vector)
as.matrix(mi_df)
as.matrix(mi_lista)
```
El vector fue coercionado a una matriz con una sola columna. 

Por su parte, al correr la función con un data frame, coercionamos también todos los datos que contiene, siguiendo las reglas de coerción de tipos de dato que vimos en el [capítulo 4](## coercion).

Al coercionar una lista a una matriz, efectivamente obtenemos un objeto de este tipo, sin embargo perdemos toda la información que contiene, por lo tanto, no podemos considerar que esta es una coerción exitosa. Del mismo modo que con `as.vector()`, no nos es mostrado ningún error ni advertencia.

Intentemos coercionar a matriz con `as.data.frame()`.
```{r as_dataframe, echo=TRUE, error=TRUE}
as.data.frame(mi_vector)
as.data.frame(mi_matriz)
as.data.frame(mi_lista)
```

Tuvimos éxito al coercionar vectores y matrices. 

El vector, al igual que cuando fue coercionado a matriz, devolvió como resultado un objeto con una sola columna, mientras que la matriz conservó sus renglones y columnas.

En este caso, al intentar la coerción de lista a data frame, obtenemos un error. Esta es la única situación en la que esto ocurre utilizando las funciones revisadas en esta sección.

Por último, intentemos coercionar a matriz con `as.list()`.
```{r as_list, echo=TRUE}
as.list(mi_vector)
as.list(mi_matriz)
as.list(mi_df)
```

Dado que las listas son el tipo de objeto más flexible de todos, hemos tenido éxito en todos los casos con nuestra coerción.

Nota que para los vectores y matrices, cada uno de los elementos es transformado en un elemento dentro de la lista resultante. Si tuviéramos una matriz con cuarenta y ocho celdas, obtendríamos una lista con ese mismo número de elementos.

En cambio, para un data frame, el resultado es una lista, en la que cada elemento contiene los datos de una columna del data frame original. Un data frame con diez columnas resultará en una lista de diez elementos.

Conocer cómo ocurre la coerción de estructuras de datos te ayudará a entender mejor algunos resultados devueltos por funciones de R, además de que te facilitará la manipulación y procesamiento de datos.

<!--chapter:end:06-estructuras-datos.Rmd-->

# Subconjuntos
En R, podemos obtener subconjuntos de nuestras estructuras de datos. Es decir, podemos extraer partes de una estructura de datos (nuestro conjunto).

Hacemos esto para seleccionar datos que tienen características específicas, por ejemplo, todos los valores mayores a cierto número o aquellos que coinciden exactamente con un valor de nuestro interés.

Para realizar esta operación haremos uso de índices, operadores lógicos y álgebra Booleana. Algunos procedimientos para obtener subconjuntos pueden usarse con cualquier estructura de datos, mientras que otras sólo funcionan con algunas de ellas.

En este capítulo revisaremos cómo extraer subconjuntos de vectores, matrices, data frames y listas, usando índices, nombres y condicionales.

## Índices
Usar índices para obtener subconjuntos es el procedimiento más universal en R, pues funciona para todas las estructuras de datos.

Un índice en R representa una **posición**. Cuando usamos índices le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas dentro de ella.

A diferencia de la mayoría de los lenguajes de programación, los índices en R empiezan en **1**, no en **0**. El índice del primer elemento de una estructura de datos siempre es 1, el segundo 2, y así sucesivamente.

Un aspecto muy importante de este procedimiento es que, para data frames y listas, **cuando extraemos un subconjunto de un objeto usando corchetes, obtenemos como resultado un objeto de la misma clase que el objeto original**. Si extraemos un subconjunto de un data frame, obtenemos un vector; y si extraemos de una lista, obtenemos una lista.

El uso de índices tiene además otras características particulares para las distintas estructuras de datos, así que veremos este procedimiento para cada una de ellas.

### Vectores
Empecemos creando un vector que contiene los nombres de distintos niveles educativos. 
```{r vector_niveles, echo=TRUE}
nivel <- c("Preescolar", "Primaria", "Secundaria", "Educación Media Superior",
           "Educación Superior")

nivel
```

Este es un vector de largo igual a cinco.
```{r}
length(nivel)
```

¿Cómo obtendríamos el tercer elemento de este vector usando índices? ¿O del primer al cuarto elemento? ¿O el segundo y quinto elemento?

Para obtener subconjuntos con índices escribimos corchetes `[]` después del nombre de un objeto.  Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto.

Por ejemplo:

* `objeto[3]`
* `lista[4:5]` 
* `dataframe[c(2, 7), ]`

Entonces, para extraer el tercer elemento de nuestro vector `nivel` hacemos lo siguiente.
```{r, echo=TRUE}
nivel[3]
```

Para extraer del primer al cuarto elemento de un vector, usamos un vector con una secuencia numérica del 1 al 4 creada con `:`.
```{r, echo=TRUE}
nivel[1:4]
```

Sin embargo, si intentamos extraer el segundo y quinto elemento del vector `nivel` corriendo lo siguiente, obtendremos un error.
```{r, echo = TRUE, error = TRUE}
nivel[2, 5]
```

¿Porqué no ha funcionado lo anterior? 

El mensaje de error nos da una pista muy importante. Al usar una coma dentro de los corchetes estamos dando la instrucción a R de buscar los índices solicitados en más de una dimensión. El número antes de la coma será buscado en la primera dimensión del objeto, y el segundo número, en su segunda dimensión.

Entonces, al llamar `nivel[2, 5]`, lo que estamos pidiendo es que R extraiga el elemento que se encuentra en la posición **2** de la primera dimensión del vector, y el elemento en la posición **5** de su segunda dimensión.  Como los vectores son unidimensionales, es imposible cumplir esta instrucción y se produce un error.

Recuerda que en R, un número sencillo es también un vector, por lo tanto, cuando escribimos `vector[3]`, en realidad estamos dando como índice un vector que contiene al número 3.

Por lo tanto, si deseamos extraer elementos en posiciones no consecutivas, debemos usar vectores generados con `c()`. De este modo damos un vector, de más de un número de largo al corchete, pero todos se encuentran en una misma dimensión.

Aplicando lo anterior, si escribimos dentro de los corchetes `c(2, 5)`, entonces tendremos éxito al extraer el segundo y quinto elemento de `nivel`.
```{r, echo=TRUE}
nivel[c(2, 5)]
```

Para estructuras de dos dimensiones, como son matrices y data frames, **el primer vector de un índice, antes de una coma, es la posición en los renglones y el segundo es la posición las columnas**. 

Obtener subconjuntos por renglones y columnas es un tipo de operación muy común al trabajar con data frames y matrices.

### Data frames
Creamos un data frame llamado `mi_df`. 
```{r mi_df, echo=TRUE}
mi_df <- data.frame("nombre" = c("Armando", "Elsa", "Ignacio", "Olga"),
                    "edad" = c(20, 24, 22, 30),
                    "sexo" = c("H", "M", "M", "H"),
                    "grupo" = c(0, 1, 1, 0))

# Resultado
mi_df
```

Usamos `dim()` para confirmar que nuestro objeto tiene dos dimensiones: tres renglones y tres columnas.
```{r dim_mi_df, echo=TRUE}
dim(mi_df)
```

Si usamos un índice con un sólo número, extraemos una columna completa, con todos sus renglones.
```{r mi_df_columna}
mi_df[1]
```

Si usamos un vector, sin comas, obtenemos varias columnas.
```{r mi_df_doscol, echo=TRUE}
mi_df[c(1, 3)]
```

Al usar comas, el vector antes de la coma nos devolverá un renglón completo.

```{r, echo=TRUE}
mi_df[3,]
```

Nota que si dejamos vació el espacio después de la coma, se nos devuelven todas las columnas del data frame.

Si el espacio que dejamos vacío es el que se encuentra después de la coma, obtenemos columnas. Esto es equivalente a usar un solo vector dentro de los corchetes.
```{r columna_coma, echo=TRUE}
mi_df[ ,1]
```

Al combinar índices para renglones y columnas, obtenemos los datos que se encuentran en una posición específica.

Por ejemplo, el dato en el tercer renglón y la tercer columna.
```{r, echo=TRUE}
mi_df[3, 3]
```

El segundo y tercer dato de la tercera columna.
```{r, echo = TRUE}
mi_df[2:3, 3]
```

El cuarto renglón de la tercera y cuarta columna.
```{r, echo = TRUE}
mi_df[4, 3:4]
```

También podemos usar vectores de más de un número. Por ejemplo, los datos en en el primer y segundo renglón, y en la segunda y cuarta columna.
```{r, echo=TRUE}
mi_df[1:2, c(2, 4)]
```

Por último, en todos los casos anteriores, hemos obtenido como resultado un data frame.

```{r, echo=TRUE}
sub_df <- mi_df[1:2, c(2, 4)]

class(sub_df)
```

Si damos un índice inválido para las columnas, es decir, un número de columna que no exista, se nos devuelve un renglón.

Intentemos obtener la séptima columna de `mi_df`.
```{r, echo = TRUE, error=TRUE}
mi_df[7]
```

Sin embargo, para los renglones simplemente se nos devuelve `NA`.

```{r, echo = TRUE}
mi_df[7, ]
```

### Matrices
El procedimiento anterior para data frames funciona de la misma manera para las matrices, con una excepción.

Si usamos como índice un sólo número, entonces obtendremos el valor que se encuentre en esa posición, contando celdas de arriba a abajo y de izquierda a derecha.

Creamos una matriz con 4 renglones y dos columnas.
```{r, echo=TRUE}
mi_matriz <- matrix(1:8, nrow = 4)

# Resultado
mi_matriz
```

Si damos como índice el número 8, R no intentará devolvernos la octava columna de la matriz, sino la octava celda.
```{r, echo=TRUE}
mi_matriz[8]
```

Fuera de este caso, los índices de renglones y columna tienen el mismo comportamiento que en un data frame.
```{r, echo=TRUE}
# Tercer renglón
mi_matriz[3, ]

# Segunda columna
mi_matriz[ ,2]

# Tercer renglón y segunda columna
mi_matriz[3, 2]
```

Nota que en este caso obtenemos vectores al extraer un subconjunto.

### Arrays
Para objetos de tres o más dimensiones se siguen las mismas reglas que con las matrices, aunque ya no es tan fácil hablar de renglones y columnas. 

Creamos un array de cuatro dimensiones.
```{r, echo=TRUE}
mi_array <- array(data = 1:16, dim = c(2, 2, 2, 2))
```

Veamos nuestro resultado y comprobamos con `dim()` su número de dimensiones.
```{r, echo=TRUE}
mi_array

# Comprobamos el número de dimensiones de nuestro objeto
dim(mi_array)
```

Intentemos extraer varios subconjuntos, sólo para ilustrar cómo funcionan los índices con arrays.
```{r}
mi_array[1, , , ]
mi_array[1, 2, , ]
mi_array[1, 2, 1, ]
mi_array[1, 2, 1, 2]
```

Nota que como resultados obtenemos matrices, a menos que hagamos una extraigamos el contenido de una sola celda.

## Nombres
Un segundo método para extraer subconjuntos es usar los nombres de los elementos en una estructura de datos. Este forma de obtener subconjuntos es usada principalmente con data frames y listas. 

De manera similar a los índices, usamos corchetes cuadrados `[]` después del nombre de un objeto, pero en lugar de escribir un número, escribimos el nombre del elemento que deseamos extraer como una cadena de texto, es decir, entre comillas.

### Data frames
Los elementos de un data frame son sus columnas y cada una de ellas tiene un nombre, lo que estamos pidiendo a R con este método es que nos devuelva los elementos cuyo nombre coincida con el que hemos proporcionado

Para mostrar el uso de este método, utilizaremos el mismo data frame que en la sección anterior.

Si escribimos entre corchetes "nombre", obtendremos toda la columna **nombre**.
```{r, echo=TRUE}
mi_df["nombre"]
```

Al escribir "grupo", nos es devuelta toda la columna con ese nombre.
```{r, echo=TRUE}
mi_df["grupo"]
```

De igual manera que con los índices, al escribir una coma dentro de los corchetes, estamos pidiendo con ello extraer elementos en más de una dimensión. Lo que está antes escrito antes de la coma corresponde a renglones, y lo que está después, a columnas.

Si ejecutamos lo siguiente, obtendremos `NA` en lugar de obtener las columnas **edad** y **sexo**.
```{r, echo=TRUE}
mi_df["edad", "sexo"]
```

Lo anterior ocurre porque R intenta encontrar un renglón llamado "edad" y una columna llamada "sexo", al no encontrarlas, nos devuelve `NA`. Recuerda que aunque no es lo más común, los renglones de un data frame pueden tener nombres.

Al igual que con los índices, si damos el nombre de un renglón que existe, obtenemos `NA`. Es sólo al solicitar un nombre de columna no válido que se nos devuelve un error.

Pedimos un nombre de renglón inexistente y obtenemos `NA`.
```{r, echo =TRUE}
mi_df["localidad", ]
```

Pero si pedimos un nombre inválido de columna, nos es devuelto un error.
```{r, echo=TRUE, error=TRUE}
mi_df[, "localidad"]
```

Para extraer más de una columna, escribimos un vector de texto entre los corchetes.
Por ejemplo
```{r, echo = TRUE}
mi_df[c("edad", "sexo")]
```

Además, las columnas son devueltas en el orden que las pedimos, lo cual es conveniente cuando estamos procesando y recodificando datos.
```{r, echo=TRUE}
mi_df[c("sexo", "edad")]
```

### Listas
Para una lista, el procedimiento es prácticamente el mismo que para un data frame, pero en lugar de obtener columnas, obtenemos los elementos contenidos en ella.

La primera diferencia con los data frame es que, dado que las listas son unidimensionales, si usamos una coma dentro de los corchetes, nos será devuelto un error.

Creamos una lista llamada `mi_lista`.
```{r, echo=TRUE}
mi_lista <- list("uno" = 1, "dos" = "2", "tres" = as.factor(3), 
                 "cuatro" = matrix(1:4, nrow = 2))
```

Intentamos obtener un subconjunto con una coma.
```{r, echo=TRUE, error=TRUE}
mi_lista["uno", "dos"]
```

Si pedimos un nombre que no existe en la lista, se nos devuelve `NULL` en lugar de un error.
```{r, echo=TRUE}
mi_lista["cinco"]
```

Para todo lo demás, los nombres tienen el mismo comportamiento que para los data frames.

Extremos un elemento de la lista.
```{r, echo = TRUE}
mi_lista["dos"]
```

Extraemos más de un elemento de la lista.
```{r, echo=TRUE}
mi_lista[c("cuatro", "tres")]
```

## Subconjuntos por índice y nombre
Al extraer subconjuntos podemos combinar índices con nombres dentro del mismo corchete para objetos multidimensionales, por ejemplo, usando un índice antes de la coma y un nombre después de ella. 

Esto nos da una gran flexibilidad para hacer subconjuntos con data frames y matrices. En particular, es útil al definir funciones y al trabajar con conjuntos de datos de los tenemos información incompleta.

Por ejemplo, extraemos el tercer y cuarto renglón de la columna **nombre** en nuestro data frame `mi_df`.
```{r, echo=TRUE}
mi_df[3:4, "nombre"]
```

También podemos usar vectores dentro de los corchetes. 

Extraemos los renglones con los nombres "48" y "100" de las primera y cuarta columna de `iris`.
```{r, echo=TRUE}
iris[c("48", "100"), c(1, 4)]
```

## El signo de dolar `$` y los corchetes dobles `[[]]`
Otra manera en la que podemos extraer subconjuntos usando nombres, es con el signo de dólar `$`.

Para usar este método, escribir el signo `$` después del nombre de un objeto de la siguiente forma: `objeto$nombre`.

Este método permite extraer un sólo elemento a la vez, funciona para data frames y listas, y para el caso de los data frame, el elemento extraído siempre será una columna.

Por ejemplo, extraemos la columna **nombre** del data frame `mi_df`.
```{r, echo = TRUE}
mi_df$nombre
```

También podemos escribir el nombre del elemento que deseamos entre comillas, esto es útil si el nombre tiene espacios.
```{r, echo = TRUE}
mi_df$"nombre"
```

Si intentamos dar más de un nombre después del signo `$`, nos es devuelto un error.
```{r, echo = TRUE, eval=FALSE}
mi_df$c("nombre", "edad")
```

El resultado de las operaciones anteriores no es un data frame, sino un vector. 
```{r, echo =TRUE}
class(mi_df$nombre)
```

Esta es una característica distintiva de este método, **al usar el signo `$` para extraer un elemento de un data frame o una lista, obtenemos un objeto de la clase que ese elemento era originalmente**.

Recuerda que **un data frame está formado por vectores**. Como vimos en el [capítulo 6](##data-frames), una manera de generar data frames es combinar vectores. Estos vectores, aunque estén contenidos dentro de un data frame, conservan todas las características de un vector y es posible extraerlos como tales.

Cuando usamos el signo `$`, le pedimos a R que extraiga de un objeto un subconjunto con sus propiedades originales. Por esta razón, para los data frame, siempre son devueltos vectores, mientras que para las listas lo que obtenemos depende del tipo de objeto contenido en ellas.

Por ejemplo, si extraemos el elemento **uno** de `mi_lista` usando corchetes, obtenemos una lista.
```{r, echo=TRUE}
class(mi_lista["uno"])
```

Pero si usamos el signo `$`, el resultado es un vector numérico, pues esta es su clase original.
```{r, echo=TRUE}
class(mi_lista$uno)
```

Si intentamos  extraer el elemento **cuatro**, obtendremos una matriz.
```{r, echo=TRUE}
class(mi_lista$"cuatro")
```

De manera similar, podemos extraer elementos de un objeto, con su clase original,  usando índices y corchetes dobles `[[]]`. 

La ventaja de usar corchetes dobles es no sólo podemos usar índices, sino que los podemos combinar con nombres, lo cual nos da acceso a una mayor flexibilidad para extraer subconjuntos y permite usarlos en estructuras de datos con elementos sin nombre.

Por ejemplo, para extraer la columna **edad** de `mi_df` con corchetes dobles, podemos usar su índice, 2, o su nombre.
```{r, echo=TRUE}
# Usando un índice
mi_df[[2]]

# Usando un nombre
mi_df[["edad"]]
```

A diferencia de los corchetes sencillos, no podemos extraer más de una columna de un data frame usando corchetes dobles y un vector.

Si escribimos un vector numérico dentro de corchetes dobles, será interpretado como si cada número estuviera separado por una coma, indicando las dimensiones de las cuales se extraerán datos.

Por ejemplo, intentamos extraer las columnas uno y tres de `mi_df`.
```{r, echo=TRUE}
mi_df[[c(1, 3)]]
```

El resultado que obtenemos no es el esperado.

Lo que ocurre es que cuando escribimos lo siguiente.

`mi_df[[c(1, 3)]]`

R lo interpreta como:

`mi_df[[1, 3]]`

Es decir,  R extraerá el dato en el renglón uno y la columna tres, en lugar de las columnas uno y tres.
```{r, echo=TRUE}
mi_df[[1, 3]]
```

Por lo tanto si escribimos lo siguiente:

`mi_df[[1:3]]`

R lo interpretará como buscar el dato uno en la primera dimensión, el dato dos, en la segunda dimensión, y el dato tres en la tercera dimensión. Como un data frame solo tiene dos dimensiones, se nos devolverá un error
```{r, echo=TRUE, error=TRUE}
mi_df[[1:3]]
```

Lo mismo ocurre con vectores que contienen nombres de columnas.
```{r, echo =TRUE, error=TRUE}
mi_df[[c("nombre", "edad")]]
```

Como las listas son unidimensionales, sólo podemos extraer un elemento a la vez usando corchetes dobles `[[]]`
```{r, echo=TRUE}
mi_lista[[1]]
```

Si damos más de un índice o nombre, siempre obtendremos un error.
```{r, echo=TRUE, error=TRUE}
# Más de un índice
mi_lista[[1:2]]

# Más de un nombre
mi_lista[["uno", "dos"]]
```

### Los data frames y listas son como cajas de manzanas
Para comprender mejor el comportamiento comportamiento del signo `$` y los corchetes dobles, imagina que los data frames y listas son cajas que contienen manzanas. Los data frame contienen las manzanas en bolsas, y estas bolsas serían vectores, en los cuales cada manzana sería un elemento. 

Por su parte, las listas pueden tener manzanas en diferentes presentaciones: bolsas, manzanas sueltas o incluso otras cajas de manzana.

Cuando usamos corchetes, estamos sacando manzanas de una caja, usando una caja más pequeña, otro data frame o lista. Así, con un data frame, obtenemos otra caja que contiene bolsas de manzanas, y con una lista obtenemos otra caja con manzanas en las presentaciones que se encuentren.

En contraste, al usar el signo `$` o corchetes dobles, estamos sacando bolsas de manzana directamente en un data frame, y en las listas estamos sacando las manzanas en su presentación original, sin que haya de por medio otra caja en ninguno de estos casos.

Dado lo anterior, podemos extraer subconjuntos de subconjuntos combinando diferentes tipos de corchetes. 
```{r}
# Subconjunto de un subconjunto: Data frame.
mi_df[[2]][3]

# Subconjunto de un subcojunto: Lista.
mi_lista[["cuatro"]][2]
```

No te preocupes mucho si lo anterior te parece confuso, lo es. No profundizaremos sobre este tema específico de los subconjuntos en este libro, pero ten en cuenta que si te encuentras con código como el del ejemplo anterior, lo que está ocurriendo es la extracción de subconjuntos de subconjuntos.

## Condicionales
Las condicionales nos permiten obtener subconjuntos que para los que una o más condiciones son verdaderas (`TRUE`). 

Para este procedimiento usamos operadores lógicos y condicionales, como revisamos en el [capítulo 5](#operadores) y lo podemos aplicar a **data frames**.

Con este procedimiento, podemos extraer todos los datos de una encuesta que corresponden a mujeres, o a personas que viven en una entidad específica, o que tienen un ingreso superior a la media, o cualquier otra condición que se verificable con **álgebra Booleana**.

Realizamos la extracción de subconjuntos mediante operaciones relacionales y lógicas dentro de corchetes.

Esta operación tiene la siguiente estructura.

```{r, echo=TRUE, eval=FALSE}
objeto[condicion, columnas_devueltas]
```

En donde:

* `objeto`: es un data frame.
* `condición`: un subconjunto de `objeto`, que devuelva un columna como vector, al que se le aplica una o más operaciones lógicas o relacionales.
* `columnas_devueltas`: los índices o nombres de las columnas que deseamos sean devueltas como resultado.

Dentro del corchete escribimos, antes de una coma, el código para obtener un subconjunto que extraiga una columna, del data frame al que queremos extraer un subconjunto usando un subconjunto.

Este primer subconjunto debe ser extraído con alguno de los dos procedimientos que da como resultado un vector, ya sea el signo `$` o corchetes dobles `[[]]`.

Necesitamos extraer un vector, porque aplicaremos a todos los elementos de esa columna una operación relacional, usando vectorización, como lo vimos en el [capítulo 6](###vectorizacion-de-operaciones).

Todos los elementos para los que el resultado de esta operación sea **TRUE**, formarán parte de nuestro subconjunto usando condicionales. Como cada elemento de una columna de un data frame está ubicado en su propio renglón, podemos decir que nos serán devueltos los renglones para los que la condición sea verdadera.

Si dejamos el espacio para `columnas_devueltas` vacío, nuestro resultado será un data frame con las mismas columnas que el data frame original. Si damos un índice o un nombre, entonces obtendremos un data frame sólo con las columnas solicitadas. De este modo, podemos extraer renglones y columnas específicas.

Veamos esto en práctica, extrayendo subconjuntos de los datos `iris`.

### Usando condicionales
Intentaremos extraer todos los datos en `iris` en los que el largo del sépalo, columna **Petal.Width**, sea mayor que 7.5.

Primero, obtenemos el subconjunto de esta columna de `iris`. Usaremos el signo `$`
```{r, echo=TRUE}
iris$Sepal.Length
```

Si aplicamos la operación relacional `> 7` a este subconjunto, obtenemos un vector, con `TRUE` o `FALSE` para cada elemento de `iris$Petal.Width`.
```{r, echo=TRUE}
iris$Sepal.Length > 7.5
```

Escribimos esta operación dentro de los corchetes, antes de una coma. No escribimos nada después de la coma, para obtener un subconjunto con todas las columnas de `iris`.
```{r, echo = TRUE}
iris[iris$Sepal.Length > 7.5, ]
```

Podemos pedir que se nos devuelvan sólo los datos de la columna **Species**, escribiendo el índice o nombre de esta columna después de la coma.
```{r, echo = TRUE}
# Usando índice
iris[iris$Sepal.Length > 7.5, 5]

#USando nombres
iris[iris$Sepal.Length > 7.5, "Species"]
```

Nota que si pedimos una sola columna en nuestros resultado, el resultado será un vector en lugar de un data frame.
```{r, echo=TRUE}
class(iris[iris$Sepal.Length > 7.5, "Species"])
```

Podemos realizar más de una operación relacional antes de la coma, usando operadores lógicos. 

Por ejemplo, extraemos todos los datos para los que el ancho del pétalo (**Sepal.Width**) sea menor que 3 y la especie (**Species**) sea "setosa".
```{r, echo=TRUE}
iris[iris$Sepal.Width < 3 & iris$Species == "setosa", ]
```

Recuerda que puedes usar el operados `!` para negaciones. De este modo puedes extraer todos los datos que no son de la especie virginica o su largo sea menor a 4.7.
```{r, echo=TRUE}
iris[!(iris$Petal.Length < 4.7 | iris$Species == "virginica"), ]
```

En realidad podemos usar un vector lógico para extraer subconjuntos, sin necesidad de realizar una operación relacional.

Por ejemplo, para obtener los dato en el primer y cuarto renglón de `mi_df`.
```{r, echo=TRUE}
mi_df[c(TRUE, FALSE, FALSE, TRUE), ]
```

Si damos un vector lógico de largo menor que el número de renglones en un data frame, el vector es reciclado. 

Al utilizar vector `c(FALSE, TRUE)`, nos serán devueltos el segundo y cuarto renglón de `mi_df`.
```{r, echo=TRUE}
mi_df[c(FALSE, TRUE), ]
```

Si proporcionamos una condición que no se cumple en ningún caso, es decir, devuelve un vector que consiste sólo de `FALSE`, el subconjunto que obtenemos es una data frame sin renglones.
```{r, echo=TRUE}
iris[iris$Species == "oceanica", ]
```

Finalmente, si no escribimos una coma dentro del corchete después de la condicional, obtendremos un data frame sin columnas, que para fines prácticos es un objeto sin utilidad.
```{r, echo=TRUE}
iris[iris$Petal.Width >= 5]
```

### La función `subset()`
Una alternativa para usar condicionales, sin necesidad de corchetes, es la función `subset()`.

Esta función tiene los siguientes argumentos:

* `x`: Un objeto, generalmente un data frame.
* `subset`: Una condición, expresada como operaciones relacionales o condicionales, que se aplicarán a una columna de `x`.
* `select`: Un vector con los nombres de las columnas a conservar en el resultado. Si no asignamos un valor a este argumento, se nos devuelven todas las columnas de `x`.

Puedes leer la documentación completa llamando `?subset`.

Como podrás ver, `subset()` necesita como argumentos los mismos elementos que usamos para extraer subconjuntos con corchetes. La principal diferencia se encuentra en el argumento `subset`.

Al usar corchetes, necesitamos aplicar una operación relacional a un vector, extraído de nuestro objeto original, por ejemplo `iris[iris$Species == "setosa", ]`. Con `subset()`, basta proporcionar el nombre del elemento al que aplicaremos las operaciones relacionales y condicionales. Para este caso, escribimos `Species == "setosa"`. Nota que el nombre de la columna está escrito sin comillas.

Por ejemplo, para extraer de iris todos los datos en los que el largo del sépalo es mayor que 7.5, damos a `iris` como argumento `x` y `Sepal.Lenght` como argumento `subset`. Dejamos sin definir el argumento `select`, para obtener todas las columnas.
```{r, echo=TRUE}
subset(x = iris, subset = Sepal.Length > 7.5)
```

Obtenemos el mismo resultado que al llamar `iris[iris.Sepal.Length > 7.5, ]`.

Damos además `c("Sepal.Length", "Species")` como argumento a `select` y con ello sólo nos serán devueltas las columnas con estos nombres.
```{r, echo=TRUE}
subset(x = iris, subset = Sepal.Length > 7.5, select = c("Sepal.Length", "Species"))
```

Desde luego, esto es equivalente a llamar `iris[iris.Sepal.Length > 7.5, c("Sepal.Length", "Species")]`.

También podemos usar operaciones lógicas para el argumento `subset`. 

Por ejemplo, los datos para los que el largo del sépalo sea mayor que 7.5 y el ancho del pétalo sea igual a 3.

```{r, echo=TRUE}
subset(x = iris, subset = Sepal.Length > 7.5 & Sepal.Width == 3)
```

Si damos como argumento a subset una comparación con un nombre de columna no válido, obtenemos un error.
```{r, echo=TRUE, error=TRUE}
subset(x = iris, subset = Sepal.Weight > 7.5 )
```

Al igual que si usamos corchetes, si pedimos una condición que para ningún caso es verdadera, nuestro resultado es un data frame sin renglones.
```{r subset_sinrenglones, echo=TRUE}
subset(x = iris, subset = Sepal.Length > 9 )
```

Si damos como argumento `select` el nombre de una columna inválida, también se nos devuelve un error.
```{r subset_col_invalida, echo=TRUE, error=TRUE}
subset(x = iris, subset = Sepal.Length > 7, select = "Sepal.Weight")
```


Finalmente, también podemos dar un vector lógico como argumento `subset` para obtener subconjuntos. Por ejemplo, el segundo y cuarto renglón de `mi_df `.
```{r, subset_logicos, echo=TRUE, error=TRUE}
subset(x = mi_df, subset = c(TRUE, FALSE, FALSE, TRUE))
```

La función `subset()` casi siempre resulta en código más breve y es más fácil de interpretar por el usuario que los subconjuntos condicionales con corchetes. Sin embargo, la mayor parte de las veces, usar uno u otro procedimiento depende de tu preferencia personal y de las necesidades de los proyectos en los que colaboras.

<!--chapter:end:07-subconjuntos.Rmd-->

# Funciones
La instalación base de R tiene suficientes funciones para que realicemos todas las tareas básicas de análisis de datos, desde importar información hasta crear documentos para comunicarla (¡este libro ha sido creado con R!).

Sin embargo, es común que necesitemos realizar tareas para las que no existe una función específica o que para encontrar solución necesitemos combinar o utilizar funciones en sucesión, lo cual puede complicar nuestro código.

Ilustremos lo anterior con un ejemplo.

## ¿Por qué necesitamos crear nuestrar propias funciones?
Supongamos que tenemos un jefe que nos ha pedido crear un histograma con datos de edad que hemos recogido en una encuesta. 

Esto es sencillo de resolver pues contamos con la función `hist()` que hace exactamente esto. Sólo tenemos que dar un vector numérico como argumento para generar una gráfica (veremos esto con más detalle en el [capítulo 12](#graficas)).

Primero, generaremos datos aleatorios sacados de una distribución normal con la función `rnorm()`. Esta función tiene los siguientes argumentos:

* `n`: Cantidad de números a generar.
* `mean`: Media de la distribución de la que sacaremos nuestros números.
* `sd`: Desviación estándar de la distribución de la que sacaremos nuestros números.

Además, llamaremos `set.seed()` para que estos resultados sean replicables. Cada que llamamos `rnorm()` se generan número aleatorios diferentes, pero si antes llamamos a `set.seed()`, con un número específico como argumento obtendremos los mismos resultados.

Obtendremos 1500 números con media 15 y desviación estándar .75.
```{r rnorm_edad, echo=TRUE}
set.seed(173)
edades <- rnorm(n = 1500, mean = 15, sd = .75)
```

Veamos los primero diez números de nuestro objeto.
```{r rnorm_10, echo=TRUE}
edades[1:10]
```

Ahora, sólo tenemos que ejecutar `hist()` con el argumento `x` igual a nuestro vector y obtendremos un histograma.
```{r primer_hist, echo=TRUE}
# Histograma
hist(x = edades)
```

Estupendo. Hemos logrado nuestro objetivo.

Nuestro jefe está satisfecho, pero le gustaría que en el histograma se muestre la media y desviación estándar de los datos, que tenga un título descriptivo y que los ejes estén etiquetados en español, además de que las barras sean de color dorado.

Suena complicado, pero podemos calcular la media de los datos usando la función `mean()`, la desviación estándar con `sd()` y podemos agregar los resultados de este cálculo al histograma usando la función `abline()`. Para agregar título, etiquetas en español y colores al histograma sólo basta agregar los argumentos apropiados a la función `hist()`.

No te preocupes mucho por los detalles de todo esto, lo veremos más adelante.

Calculamos media y desviación estándar de nuestros datos.
```{r hist media sd, echo=TRUE}
media <- mean(edades)
desv_est <- sd(edades)
```

Agregamos líneas con `abline()`, para la media de rojo y desviación estándar con azul. También ajustamos los argumentos de `hist()`.
```{r hist}
hist(edades, main = "Edades", xlab = "Datos", ylab = "Frecuencia", col = "gold")
abline(v = media, col = "red")
abline(v = media + (desv_est * c(1, -1)), col = "blue")
```

Con esto nuestro jefe ahora sí ha quedado complacido. Tanto, que nos pide que hagamos un histograma igual para todas las variables numéricas de esa encuesta. Que son cincuenta en total.

Para cumplir con esta tarea podríamos usar el código que ya hemos escrito. Simplemente lo copiamos y pegamos cincuenta veces, cambiando los valores para cada una de variables que nos han pedido.

Pero hacer las cosas de este modo propicia errores y es difícil de corregir y actualizar.

Para empezar, si copias el código anterior cincuenta veces, tendrás un *script* con más de **400 líneas**. Si en algún momento te equivocas porque escribiste "Enceusta" en lugar de "Encuesta", incluso con las herramientas de búsqueda de RStudio, encontrar donde está el error será una tarea larga y tediosa.

Y si tu jefe en esta ejemplo quiere que agregues, quites o modifiques tu histograma, tendrás que hacer el cambio cincuenta veces, una para cada copia del código. De nuevo, con esto se incrementa el riesgo de que ocurran errores.

Es en situaciones como esta en las que se hace evidente la necesidad de crear nuestras propias funciones, capaces de realizar una tarea específica a nuestros problemas, y que pueda usarse de manera repetida. Así reducimos errores, facilitamos hacer correcciones o cambios y nos hacemos la vida más fácil, a nosotros y a quienes usen nuestro código después.

## Funciones definidas por el usuario
Una función tiene un nombre, argumentos y un cuerpo. Las funciones definidas por el usuario son creadas usando la siguiente estructura.
```{r, echo=TRUE, eval=FALSE}
nombre <- function(argumentos) {
  operaciones
}
```

Cuando asignamos una función a un nombre decimos que hemos **definido una función**.

El **nombre** que asignamos a una función nos permite ejecutarla y hacer referencias a ella. Podemos asignar la misma función a diferentes nombres o cambiar una función a la que ya le hemos asignado un nombre. Es recomendable elegir nombres claros, no ambiguos y descriptivos. 

Una vez que la función tiene nombre, podemos llamarla usando su nombre, al igual que con las funciones por defecto de R.

Los **argumentos** son las variables que necesita la función para realizar sus operaciones. Aparecen entre paréntesis, separados por comas. Los valores son asignados al nombre del argumento por el usuario cada vez que ejecuta una función. Esto permite que usemos nuestras funciones en distintas situaciones con diferentes datos y especificaciones.

Los argumentos pueden ser datos, estructuras de datos, conexiones a archivos u otras funciones y todos deben tener nombres diferentes.

El **cuerpo** de la función contiene, entre llaves, todas las operaciones que se ejecutarán cuando la función sea llamada. El cuerpo de una función puede ser tan sencillo o complejo como nosotros deseemos, incluso podemos definir funciones dentro de una función (y definir funciones dentro de una función dentro de otra función, aunque esto se vuelve confuso rápidamente). 

Si el código del cuerpo de la función tiene errores, sus operaciones no se realizarán y nos será devuelto un mensaje de error **al ejecutarla**. R no avisa si nuestra función va a funcionar o no hasta que intentamos correrla. 

Una ventaja de usar RStudio es que nos indica errores de sintaxis en nuestro código, lo cual puede prevenir algunos errores. Sin embargo, hay alguno que no detecta, como realizar operaciones o coerciones imposibles.

Para ver esto en acción, crearemos una función sencilla para obtener el área de un cuadrilátero.

## Nuestra primera función
Partimos del algoritmo para calcular el área de un cuadrilátero: `lado x lado`.

Podemos convertir esto a operaciones de R y asignarlas a una función llamada `area_cuad` de la siguiente manera:
```{r, echo=TRUE}
area_cuad <- function(lado1, lado2) {
  lado1 * lado2
}
```

Las partes de nuestra función son:

* **Nombre**: `area_cuad`. 
* **Argumentos**: `lado1`, `lado2`. Estos son los datos que necesita la función para calcular el área, representan el largo de los lados de un cuadrilátero.
* **Cuerpo**: La operación `lado1 * lado2`, escrita de manera que R pueda interpretarla.

Ejecutaremos nuestra función para comprobar que funciona. Nota que lo único que hacemos cada que la llamamos es cambiar la medida de los lados del cuadrilátero para el que calcularemos un área, en lugar de escribir la operación `lado1 * lado2` en cada ocasión.

```{r area_cuad_test, echo=TRUE}
area_cuad(lado1 = 4, lado2 = 6)

area_cuad(lado1 = 36, lado2 = 36)
```

En cada llamada a nuestra función estamos asignando valores distintos a los argumentos usando el signo de igual. Si no asignamos valores a un argumento, se nos mostrará un error

```{r area_cuad_error, echo=TRUE, error=TRUE}
area_cuad(lado1 = 14)
```

En R, podemos especificar los argumentos por posición. El orden de los argumentos se determina cuando creamos una función. 

En este caso, nosotros determinamos que el primer argumento que recibe `area_cuad` es `lado1` y el segundo es `lado2.` Así, podemos escribir lo siguiente y obtener el resultado esperado.
```{r area_cuad_posicion, echo=TRUE}
area_cuad(128, 64)
```
Esto es equivalente a escribir `lado1 = 128, lado2 = 64` como argumentos.

Podemos crear ahora una función ligeramente más compleja para calcular el volumen de un prisma rectangular 

Siguiendo la misma lógica de transformar un algoritmo a código de R, podemos crear una función con el  algoritmo: `arista x arista x arista`.

Definimos la función `area_prisma()`.
```{r area_prisma, echo=TRUE}
area_prisma <- function(arista1, arista2, arista3) {
  arista1 * arista2 * arista3
}
```

Probemos nuestra función.
```{r area_prisma_prueba, echo=TRUE}
area_prisma(arista1 = 3, arista2 = 6, arista3 = 9)
```

También podríamos escribir esta función aprovechando nuestra función `area_cuad`.
```{r, echo=TRUE}
area_prisma <- function(arista1, arista2, arista3) {
  area_cuad(arista1, arista2) * arista3
}

# Probemos la función
area_prisma(3, 6, 9)
```

Con esto estamos listos para definir una función para crear histogramas con las características que nos pidió nuestro jefe hipotético.

## Definiendo la función `crear_histograma()`
Definiremos una función con el nombre `crear_histograma()` para generar un gráfico con las especificaciones que se nos han pedido. 

Partimos de una función sin argumentos y el cuerpo vacío.
```{r crear_histograma vacio, echo=TRUE}
crear_histograma <- function() {

}
```

Para que esta función realice lo que deseamos necesitamos:

* Los datos que serán graficados.
* El nombre de la variable graficada

Por lo tanto, nuestros argumentos serán:

* `datos`
* `nombre`

```{r crear_histograma args, echo=TRUE}
crear_histograma <- function(datos, nombre) {
  
}
```

Ya sabemos las operaciones realizaremos, sólo tenemos que incluirlas al cuerpo de nuestro función.

Reemplazaremos las variables que hacen referencia a un objeto en particular por el nombre de nuestros argumentos. De esta manera será generalizable a otros casos.

En este ejemplo, cambiamos la referencia a la variable **edades** por referencias al argumento `datos` y la referencia a **Edades**, que usaremos como título del histograma, por una referencia al argumento `nombre`.
```{r crear_histograma cuerpo, echo=TRUE}
crear_histograma <- function(datos, nombre) {
  media <- mean(datos)
  desv_est <- sd(datos)
  
  hist(datos, main = nombre, xlab = "Datos", ylab = "Frecuencia", col = "gold")
  abline(v = media, col = "red")
  abline(v = media + (desv_est * c(1, -1)), col = "blue")
}
```

Probemos nuestra función usando datos distintos, generados de manera similar a las edades, con la función `rnorm()`. 

Generaremos datos de ingreso, con una media igual a 15000 y una desviación estándar de 4500.
```{r rnorm_ingreso, echo=TRUE}
ingreso <- rnorm(1500, mean = 15000, sd = 4500)

# Resultado
ingreso[1:10]
```

Corremos nuestra función.
```{r crear_histograma ingreso, echo=TRUE}
crear_histograma(ingreso, "Ingreso")
```

Luce bien. Probemos ahora con datos sobre el peso de las personas. siguiendo el mismo procedimiento.
```{r crear_hist peso, echo=TRUE}
peso <- rnorm(75, mean = 60, sd = 15)

crear_histograma(peso, "Peso")
```

Las funciones definidas por el usuario pueden devolvernos errores. Por ejemplo, si introducimos datos que no son apropiados para las operaciones a realizar, nuestra función no se ejecutará correctamente.
```{r crear_hist error, echo=TRUE, error = TRUE}
crear_histograma("Cuatro", ingreso)
```

Por esta razón es importante crear **documentación** para las funciones que hayas creado. Puede ser tan sencilla como una explicación de qué hace la función y qué tipo de datos necesita para realizar sus operaciones.

La primera persona beneficiada por esto eres tu, pues tu yo de un mes en el futuro puede haber olvidado por completo la lógica de una función específica, así que la documentación es una manera de recordar tu trabajo.

Una manera simple de documentar tus funciones es con comentarios.
```{r, echo=TRUE}
# crear_histograma
# Devuelve un histograma con lineas indicando la media y desviación estándar de un vector de datos numérico
# Argumentos:
# - datos: Un vector numérico.
# - nombre: Una cadena de texto.
```

### Ejecutando 
Ahora, podremos cumplir con la solicitud de nuestro jefe ficticio usando cincuenta llamadas a una función en lugar de correr más de cuatrocientas líneas de código y que hemos reducido la probabilidad de cometer errores. 

Además, si a nuestro jefe se le ocurren nuevas características para los histogramas, basta con cambiar el cuerpo de nuestra función una vez y esto se verá reflejado en nuestro cincuenta casos al correr de nuevo el código.

Por ejemplo, supongamos que nuestro jefe también quiere que el histograma muestre la mediana de nuestros datos y que las barras sean de color naranja. Basta con hacer un par de cambios.
```{r crear_hist_naranja, echo=TRUE}
crear_histograma <- function(datos, nombre) {
  media <- mean(datos)
  desv_est <- sd(datos)
  mediana <- median(datos)
  
  hist(datos, main = nombre, xlab = "Datos", ylab = "Frecuencia", col = "orange")
  abline(v = media, col = "red")
  abline(v = media + (desv_est * c(1, -1)), col = "blue")
  abline(v = mediana, col = "green")
}

# Resultado
crear_histograma(peso, "Peso con mediana")
```

Quizás estés pensando que escribir una función cincuenta veces de todos modos es demasiada repetición y aún se presta a cometer errores. Lo cual es cierto, pero podemos hacer más breve nuestro código y menos susceptible a equivocaciones con la familia de funciones **apply**, que revisaremos en el [capítulo 10](#la-familia-apply).

<!--chapter:end:08-funciones.Rmd-->

# Estructuras de control
Como su nombre lo indica, las estructuras de control nos permiten controlar la manera en que se ejecuta nuestro código. 

Las estructuras de control establecen **condicionales** en nuestros código. Por ejemplo, qué condiciones deben cumplirse para realizar una operación o qué debe ocurrir para ejecutar una función.

Esto es de gran utilidad para determinar la lógica y el orden en que ocurren las operaciones, en especial al definir funciones.

Las estructuras de control más usadas en R son las siguientes.

| Estructura de control | Descripción
| ---                   |---
| `if`, `else`          | Si, de otro modo
| `for`                 | Para cada uno en
| `while`               | Mientras
| `break`               | Interrupción
| `next`                | Siguiente

## if, else
`if` (si) es usado cuando deseamos que una operación se ejecute únicamente cuando una condición se cumple. 

`else` (de otro modo) es usado para indicarle a R qué hacer en caso de la condición de un `if` no se cumpla. 

Un `if` es la manera de decirle a R: 

* **SI** esta condición es cierta, **ENTONCES** haz estas operaciones.

El modelo para un `if` es:
```{r, eval=FALSE}
if(Condición) {
  operaciones_si_la_condición_es_TRUE
}
```

Si la condición se cumple, es decir, es verdadera (`TRUE`), entonces se realizan las operaciones. En caso contrario, no ocurre nada y el código con las operaciones no es ejecutado.

Por ejemplo, le pedimos a R que nos muestre el texto "Verdadero" si la condición se cumple.
```{r, echo=TRUE}
# Se cumple la condición y se muestra "verdadero"
if(4 > 3) {
  "Verdadero"
}

# No se cumple la condición y no pasa nada
if(4 > 5) {
  "Verdadero"
}
```

`else` complementa un `if`, pues indica qué ocurrirá cuando la condición no se cumple, es falsa (`FALSE`), en lugar de no hacer nada.

Un `if` con `else` es la manera de decirle a R:

* **SI** esta condición es es cierta, **ENTONCES** haz estas operaciones, **DE OTRO MODO** haz estas otras operaciones.

El modelo para un **if** con un **else** es:
```{r, eval=FALSE}
if(condición) {
  operaciones_si_la_condición_es_TRUE
} else {
  operaciones_si_la_condición_es_FALSE
}
```

Usando los ejemplos anteriores, podemos mostrar "Falso" si no se cumple la condición, en lugar de que no ocurra nada.

```{r, echo=TRUE}
# Se cumple la condición y se muestra "Verdadero"
if(4 > 3) {
  "Verdadero"
} else {
  "Falso"
}

# No se cumple la condición y se muestra "Falso"
if(4 > 5) {
  "Verdadero"
} else {
  "Falso"
}
```

### Usando if y else
Para ilustrar el uso de `if` `else` definiremos una función que calcule el promedio de calificaciones de un estudiante y, dependiendo de la calificación calculada, nos devuelva un mensaje específico.

Empezamos definiendo una función para calcular promedio. En realidad, sólo es la aplicación de la función `mean()` ya existente en R *base*, pero la ampliaremos después.
```{r, echo=TRUE}
promedio <- function(calificaciones) {
  mean(calificaciones)
}

promedio(c(6, 7, 8, 9, 8))
promedio(c(5, 8, 5, 6, 5))
```

Ahora deseamos que esta función nos muestre si un estudiante ha aprobado o no.

Si asumimos que un estudiante necesita obtener 6 o más de promedio para aprobar, podemos decir que:

* **SI** el promedio de un estudiante es igual o mayor a 6, **ENTONCES** mostrar "Aprobado", **DE OTRO MODO**, mostrar "Reprobado".

Aplicamos esta lógica con un `if`,  `else` en la función `promedio()`.
```{r, echo=TRUE}
promedio <- function(calificaciones) {
  media <- mean(calificaciones)
  
  if(media >= 6) {
    print("Aprobado")
  } else {
    print("Reprobado")
  }
}
```

Probemos nuestra función
```{r, echo=TRUE}
promedio(c(6, 7, 8, 9, 8))
promedio(c(5, 8, 5, 6, 5))
```

Está funcionando, aunque los resultados podrían tener una mejor presentación.

Usaremos la función `paste0()` para pegar el promedio de calificaciones, como texto, con el resultado de "Aprobado" o "Reprobado". Esta función acepta como argumentos cadenas de texto y las pega (concatena) entre sí, devolviendo como resultado una nueva cadena.

Primero concatenaremos la palabra "Calificación: " a la media obtenida con la función `promedio()` y después el resultado de esta operación con la palabra "aprobado" o "reprobado", según corresponda.
```{r, echo=TRUE}
promedio <- function(calificaciones) {
  media <- mean(calificaciones)
  texto <- paste0("Calificación: ", media, ", ")
  
  if(media >= 6) {
    print(paste0(texto, "aprobado"))
  } else {
    print(paste0(texto, "reprobado"))
  }
}
```

Pongamos a prueba nuestra función.
```{r}
promedio(c(6, 7, 8, 9, 8))
promedio(c(5, 8, 5, 6, 5))
```

Por supuesto, como lo vimos en el capítulo sobre [funciones](#funciones), podemos hacer aún más compleja a `promedio()`, pero esto es suficiente para conocer mejor las aplicaciones de `if` `else`.

### ifelse
La función `ifelse( )` nos permite vectorizar `if, else`. En lugar de escribir una línea de código para cada comparación, podemos usar una sola llamada a esta función, que se aplicará a todos los elementos de un vector.

Si intentamos usar `if` `else` con un vector, se nos mostrará una advertencia.
```{r}
if(1:10 < 3) {
  "Verdadero"
}
```
Este mensaje nos dice que sólo se usará el primer elemento del vector para evaluar su la condición es verdadera y lo demás será ignorado.

En cambio, con `ifelse` se nos devolverá un valor para cada elemento de un vector en el que la condición sea `TRUE`, además nos devolverá otro valor para los elementos en que la condición sea `FALSE`. 

Esta función tiene la siguiente forma.
```{r, echo=TRUE, eval=FALSE}
ifelse(vector, valor_si_TRUE, valor_si_FALSE)
```

Si intentamos el ejemplo anterior con `ifelse()`, se nos devolverá un resultado para cada elemento del vector, no sólo del primero de ellos.
```{r, echo=FALSE}
ifelse(1:10 < 3, "Verdadero", "Falso")
```
De este modo podemos usar `ifelse()` para saber si los números en un vector son pares o nones.
```{r, echo=TRUE}
num <- 1:8

ifelse(num %% 2 == 0, "Par", "Non")
```

También tenemos la opción de crear condiciones más complejas usando operadores Booleanos.

Por ejemplo, pedimos sólo los números que son exactamente divisibles entre 2 y 3.
```{r, echo=TRUE}
num <- 1:20

ifelse(num %% 2 == 0 & num %% 3, "Divisible", "No divisible")
```

Desde luego, esto es particularmente útil para recodificar datos.
```{r, echo = TRUE}
num <- c(0, 1, 0, 0, 0, 1, 1)

num <- ifelse(num == 0, "Hombre", "Mujer")

num
```


## for 
La estructura `for` nos permite ejecutar un bucle (*loop*), realizando una operación para cada elemento de un conjunto de datos.

Su estructura es la siguiente:
```{r, echo=TRUE, eval=FALSE}
for(elemento in objeto) {
  operacion_con_elemento
}
```

Con lo anterior le decimos a R:

* **PARA** cada elemento **EN** un objeto, haz la siguiente operación.

Al escribir un bucle `for` la parte que corresponde al **elemento** la podemos llamar como nosotros deseemos, pero la parte que corresponde al **objeto** debe ser el nombre de un objeto existente.

Los dos bucles siguientes son equivalentes, sólo cambia el nombre que le hemos puesto al **elemento**.
```{r, eval = FALSE}
objeto <- 1:10

for(elemento in objeto) {
  operacion_con_elemento
}

for(i in objeto) {
  operacion_con_elemento
}
```

Tradicionalmente se usa la letra **i** para denotar al elemento, pero nosotros usaremos nombres más descriptivos en este capítulo.


### Usando for
Vamos a obtener el cuadrado de cada uno de los elementos en un vector numérico del 1 al 6, que representa las caras de un dado.
```{r, echo=TRUE} 
dado <- 1:6

for(cara in dado) {
  dado ^ 2 
}
```

Notarás que al ejecutar el código anterior parece que no ha ocurrido nada. En realidad, sí se han realizado las operaciones, pero R no ha devuelto sus resultados.

Las operaciones en un `for` se realizan pero sus resultados nunca son devueltos automáticamente, es necesario pedirlos de manera explícita.

A diferencia de otros lenguajes de programación en los que pedimos los resultados de un bucle con `return()`, en R este procedimiento sólo funciona con funciones.

Una solución para mostrar los resultados de un bucle `for` es usar la función `print()`.
```{r, echo=TRUE}
for(cara in dado) {
  print(cara ^ 2)
}
```

Comprobamos que la operación ha sido realizada a cada elemento de nuestro objeto. Sin embargo, usar `print()` sólo mostrará los resultados de las operaciones en la consola, no los asignará a un objeto.

Si deseamos asignar los resultados de un bucle `for` a un objeto, usamos [índices](##indices). 

Aprovechamos que el primer elemento en un bucle siempre es identificado con el número **1** y que continuará realizando operaciones hasta llegar al total de elementos que hemos especificado.
```{r, echo=TRUE}
for(numero in 1:10) {
  print(numero)
}
```

En nuestro ejemplo, pasamos por los valores de dado, cara por cara. La primera cara será igual a **1**, la segunda a **2**, y así sucesivamente hasta el **6**. 

Podemos usar estos valores para asignar cada valor resultante de nuestras operaciones a una posición específica en un vector, incluso si este está vacío.

Creamos un vector vacío, asignándole como `NULL` como valor.
```{r, echo=TRUE}
mi_vector <- NULL
```

Ejecutamos nuestro bucle.
```{r, echo=TRUE}
for(cara in dado) {
  mi_vector[cara] <- cara ^ 2
}
```

Aunque no fueron mostrados en la consola, los resultados han sido asignados al objeto `mi_vector`.
```{r, echo=TRUE}
mi_vector
```

### for y vectorización
Notarás que el resultado que obtuvimos usando **for** es el mismo que si vectorizamos la operación.
```{r, echo=TRUE}
dado ^ 2
```

Dado que en R contamos con vectorización de operaciones, que podemos usar las funciones de [la familia apply](#la-familia-apply) (discutido en siguiente capítulo) en objetos diferentes a vectores y que la manera de recuperar los resultados de un `for` es un tanto laboriosa, este tipo de bucle no es muy popular en R. 

En R generalmente hay opciones mejores, en cuanto a simplicidad y velocidad de cómputo, que un bucle `for`.

Sin embargo, es conveniente que conozcas esta estructura de control, pues hay ocasiones en la que es la mejor herramienta para algunos problemas específicos.

## while
Este es un tipo de bucle que ocurre **mientras** una condición es verdadera (`TRUE`). La operación se realiza hasta que se se llega a cumplir un criterio previamente establecido.

El modelo de **while** es:
```{r, echo=TRUE, eval=FALSE}
while(condicion) {
  operaciones
}
```

Con esto le decimos a R:

* **MIENTRAS** esta condición sea **VERDADERA**, haz estas operaciones.

La condición generalmente es expresada como el resultado de una o varias operaciones de comparación, pero también puede ser el resultado de una función.

### Usando while
Probemos sumar `+1` a un valor, mientras que este sea menor que 5. Al igual que con `for`, necesitamos la función `print()` para mostrar los resultados en la consola.
```{r, echo=TRUE}
umbral <- 5
valor <- 0

while(valor < umbral) {
  print("Todavía no.")
  valor <- valor + 1
}
```

¡Ten cuidado con crear bucles infinitos! Si ejecutas un `while` con una condición que nunca será `FALSE`, este nunca se detendrá.

Si corres lo siguiente, presiona la tecla **ESC** para detener la ejecución, de otro modo, correrá por siempre y puede llegar a congelar tu equipo.
```{r, echo=TRUE, eval=FALSE}
while(1 < 2) {
  print("Presiona ESC para detener")
}
```

El siguiente es un error común. Estamos sumando 1 a `i` con cada iteración del bucle, pero como no estamos asignando este nuevo valor a `i`, su valor se  mantiene igual, entonces la condición nunca se cumplirá y el bucle será infinito.

De nuevo, si corres lo siguiente, presiona la tecla **ESC** para detener la ejecución.
```{r, echo=TRUE, eval=FALSE}
i <- 0
while(i < 10) {
  i + 1
}
```

Un uso común de **while** es que realice operaciones que queremos detener cuando se cumple una condición, pero desconocemos cuándo ocurrirá esto.

Supongamos que, por alguna razón queremos sumar calificaciones, del 1 al 10 al azar, hasta llegar a un número que mayor o igual a 50. Además nos interesa saber cuántas calificaciones sumaron y cuál fue el resultado al momento de cumplir la condición.

Para obtener números al azar del 1 al 10, usamos la función `sample()`. Esta función va a tomar una muestra al azar de tamaño igual a 1 (argumento `size`) de un vector del 1 al 10 (argumento `x`) cada vez que se ejecute.

Por lo tanto, cada vez que corras el ejemplo siguiente obtendrás un resultado distinto, pero siempre llegarás a un valor mayor a 50.

Creamos dos objetos, `conteo` y `valor`. Les asignamos el valor 0.
```{r, echo=TRUE}
conteo <-  0
valor <- 0
```

Nuestro `while` hará dos cosas. 

Primero, tomará un número al azar del 1 al 10, y lo sumará a `valor`. Segundo, le sumará 1 a `conteo` cada que esto ocurra, de esta manera sabremos cuántas iteraciones ocurrieron para llegar a un valor que no sea menor a 50.
```{r,echo=TRUE}
while(valor < 50) {
  valor <- valor + sample(x = 1:10, size = 1)
  conteo <- conteo + 1
}
```

Aunque no son mostrados en la consola los resultados son asignados a los objetos `valor`y `conteo`
```{r, echo=TRUE}
valor
conteo
```

Por último, si intentamos ejecutar un `while` para el que la condición nunca es igual a `TRUE`, este no realizará ninguna operación.
```{r, echo=TRUE}
conteo <- 0

while("dado" == "ficha") {
  conteo <- conteo + 1
}

conteo
```

## break y next
`break` y `next`  son  **palabras reservadas** en R, no podemos asignarles nuevos valores y realizan una operación específica cuando aparecen en nuestro código.

`break` nos permite **interrumpir** un bucle, mientras que `next` nos deja avanzar a la **siguiente** iteración del bucle, "saltándose" la actual. Ambas funcionan para `for` y `while`.

### Usando break
Para interrumpir un bucle con `break`, necesitamos que se cumpla una condición. Cuando esto ocurre, el bucle se detiene, aunque existan elementos a los cuales aún podría aplicarse.

Interrumpimos un `for` cuando `i` es igual a 3, aunque aún queden 7 elementos en el objeto.
```{r, echo=TRUE}
for(i in 1:10) {
  if(i == 3) {
    break
  }
  print(i)
}
```

Interrumpimos un `while` antes de se cumpla la condición de que `numero` sea mayor a 5, en cuanto este tiene el valor de 15.
```{r, echo=TRUE}
numero <- 20

while(numero > 5) {
  if(numero == 15) {
    break
  }
  numero <- numero - 1
}

numero
```

Como habrás notado, la  aplicación de `break` es muy similar a `while`, realizar una operación hasta que se cumple una condición, y ambos pueden usarse en conjunto.

### Usando next
Por su parte, usamos next para "saltarnos" una iteración en un bucle. Cuando la condición se cumple, esa iteración es omitida. 
```{r, echo=TRUE}
for(i in 1:4) {
  if(i == 3) {
    next
  }
  print(i)
}
```

Estas dos estructuras de control nos dan un control fino sobre nuestro código. aunque los dos ejemplos de arriba son con **for**, también funcionan con **while** y **repeat**. 

En realidad, **break** es indispensable para **repeat**.

## repeat
Este es un bucle que se llevará a cabo el número de veces que especifiquemos, usando un `break` para detenerse. `repeat` asegura que las operaciones que contiene sean iteradas al menos en una ocasión.

La estructura de **repeat** es el siguiente:
```{r, echo=TRUE, eval=FALSE}
repeat {
  operaciones
  
  un_break_para_detener
}
```

Si no incluimos un `break`, el bucle se repetirá indefinidamente y sólo lo podremos detener pulsando la tecla ESC, así que hay que tener cuidado al usar esta estructura de control.

Por ejemplo, el siguiente `repeat` sumará `+1` a `valor` hasta que este sea igual a cinco, entonces se detendrá.
```{r, echo=TRUE}
valor <-  0
mi_vector <- NULL

repeat{
  valor <- valor + 1
  if(valor == 5) {
    break
  }
}

# Resultado
valor
```

Este tipo de bucle es quizás el menos utilizado de todos, pues en R existen alternativas para obtener los mismos resultados de manera más sencilla y sin el riesgo de crear un bucle infinito. Sin embargo, puede ser la mejor alternativa para problemas específicos.

<!--chapter:end:09-estructuras-control.Rmd-->

# La familia apply
La familia de funciones `apply` es usada para aplicar una función a cada elemento de una estructura de datos. En particular, es usada para aplicar funciones en matrices, data frames, arrays y listas.

Con esta familia de funciones podemos automatizar tareas complejas usando poca líneas de código y es una de las características distintivas de R como lenguaje de programación.

La familia de funciones `apply` es una expresión de los rasgos del paradigma funcional de programación presentes en R. Sobre esto no profundizaremos demasiado, pero se refiere saber que en R las funciones son "ciudadanos de primera", con la misma importancia que los objetos, y por lo tanto, operamos en ellas. 

La familia de funciones apply no sólo recibe datos como argumentos, también recibe funciones.

### Un recordatorio sobre vectorización
Para entender más fácilmente el uso de la familia 0, recordemos la [vectorización de operaciones](###vectorización-de-operaciones).

Hay operaciones que, si las aplicamos a un vector, son aplicadas a todos sus elementos.
```{r recordar vectorizacion, echo=TRUE}
mi_vector <- 1:10

mi_vector

mi_vector ^ 2
```

Lo anterior es, generalmente, preferible a escribir una operación para cada elemento o a usar un bucle **for**, como se describió en  el capítulo sobre [estructuras de control](#estructuras-de-control).

Como todo lo que ocurre en R es una función, podemos decir que **al vectorizar estamos aplicando una función a cada elemento de un vector**. La familia de funciones **apply** nos permite implementar esto en estructuras de datos distintas a los vectores.

### Las funciones de la familia apply
La familia apply esta formada por las siguientes funciones:

* `apply()`
* `eapply()`
* `lapply()`
* `mapply()`
* `rapply()`
* `sapply()`
* `tapply()`
* `vapply()`

Es una familia numerosa y esta variedad de funciones se debe a que varias de ellas tienen aplicaciones sumamente específicas.

Todas las funciones de esta familia tienen una característica en común: **reciben como argumentos a un objeto y al menos una función**. 

Hasta ahora, todas las funciones que hemos usado han recibido como argumentos estructuras de datos, sean vectores, data frames o de otro tipo. Las funciones de la familia apply tienen la particularidad que pueden recibir a otra función como un argumento. Lo anterior puede sonar confuso, pero es más bien intuitivo al verlo implementado.

Nosotros trabajaremos con las funciones más generales y de uso común de esta familia:

* `apply()`
* `lapply()`

Estas dos funciones nos permitirán solucionar casi todos los problemas a los que nos encontremos. Además, conociendo su uso, las demás funciones de la familia **apply** serán relativamente fáciles de entender.

## apply
`apply` aplica una función a todos los elementos de una **matriz**.

La estructura de esta función es la siguiente.
```{r, eval = F}
apply(X, MARGIN, FUN)

```

`apply` tiene tres argumentos:

* `X`: Una matriz o un objeto que pueda coercionarse a una matriz, generalmente, un data frame.
* `MARGIN`: La dimensión (margen) que agrupará los elementos de la matriz `X`, para aplicarles una función. Son identificadas con números, **1** son renglones y **2** son columnas.
* `FUN`: La función que aplicaremos a la matriz `X` en su dimensión `MARGIN`.

### ¿Qué es X
`X` es una matriz o cualquier otro objeto que sea posible coercionar a una matriz. Esto es, principalmente, vectores y data frames. 

Recuerda que puedes coercionar objetos a matriz usando `as.matrix()` y puedes comprobar si un objeto es de esta clase con `is.matrix()`.
```{r, echo = TRUE}
# Creamos un data frame
mi_df <- data.frame(v1 = 1:3, v2 = 4:6)

mi_df

# Coerción a matriz
mi_matriz <- as.matrix(mi_df)

# Verificamos que sea matriz
is.matrix(mi_matriz)

# Resultado
mi_matriz
```

Aunque también podemos coercionar listas y arrays a matrices, los resultados que obtenemos no siempre son apropiados para `apply()`, por lo que no es recomendable usar estos objetos como argumentos.

### ¿Qué es MARGIN?
Recuerda que las matrices y los data frames están formadas por vectores y que estas estructuras tienen dos dimensiones, ordenadas en renglones y columnas. Esto lo vimos en en [Matrices y arrays](##matrices-y-arrays) y [Data frames](##data-frames).

Para `MARGIN`:

* 1 es renglones.
* 2 es columnas.

Por ejemplo, podemos usar `apply()` para obtener la sumatoria de los elementos de una matriz, por renglón.

Creamos una matriz de cuatro renglones.
```{r, echo=TRUE}
matriz <- matrix(1:14, nrow = 4) 
```

Aplicamos `apply()`, dando la función `sum()` el argumento `FUN`, nota que sólo necesitamos el nombre de la función, sin paréntesis.

Por último, damos el argumento `MARGIN = 1`, para aplicar la función por renglón.
```{r, echo=TRUE}
apply(X = matriz, MARGIN = 1, FUN = sum)
```

Esto es equivalente a hacer lo siguiente.
```{r, echo = TRUE}
sum(matriz[1, ])
sum(matriz[2, ])
sum(matriz[3, ])
sum(matriz[4, ])
```

Y naturalmente, es equivalente a hacer lo siguiente.
```{r}
sum(vector_1)
sum(vector_2)
sum(vector_3)
sum(vector_4)
```

**Estamos aplicando una función a cada elemento de nuestra matriz. Los elementos son los renglones. Cada renglón es un vector. Cada vector es usado como argumento de la función.**

Si cambiamos el argumento MARGIN de `MARGIN = 1` a `MARGIN = 2`, entonces la función se aplicará por columna.
```{r, echo=TRUE}
apply(X = matriz, MARGIN = 2, FUN = sum)
```

En este caso, la función `sum()` ha sido aplicado a cada elementos de nuestra matriz, los elementos son las columnas, y cada columna es un vector.

### ¿Qué es FUN?
FUN es un argumento que nos pide el **nombre de una función que se se aplicarla a todos los elementos de nuestra matriz**.

El ejemplo de la sección anterior aplicamos las funciones `mean()` y `sum()` usando sus nombres, sin paréntesis, esto es, sin especificar argumentos.

Podemos dar como argumento cualquier nombre de función, siempre y cuando ésta acepte vectores como argumentos.

Probemos cambiando el argumento `FUN`. Usaremos la función `mean()` para obtener la media de cada renglón y de cada columna.

Aplicado a los renglones.
```{r, echo=TRUE}
apply(matriz, 1, mean)
```

Aplicado a las columnas
```{r, echo=TRUE}
apply(matriz, 2, mean)
```

Las siguientes llamadas a `sd()`, `max()` y `quantile()` se ejecutan sin necesidad de especificar argumentos.
```{r, echo=TRUE}
# Desviación estándar
apply(matriz, 1, FUN = sd)

# Máximo
apply(matriz, 1, FUN = max)

# Cuantiles
apply(matriz, 1, FUN = quantile)
```

### ¿Cómo sabe FUN cuáles son sus argumentos?
Recuerda que podemos llamar una función y proporcionar sus argumentos en orden, tal como fueron establecidos en su definición.

Por lo tanto, **el primer argumento que espera la función, será la `X` del `apply()`**.

Para ilustrar esto, usaremos la función `quantile()`. Llama `?quantile` en la consola para ver su documentación.
```{r, echo=TRUE, eval=FALSE}
?quantile
```

`quantile()` espera siempre un argumento `x`, que debe ser un vector numérico, además tener varios argumentos adicionales. 

* `probs` es un vector numérico con las probabilidades de las que queremos extraer cuantiles.
* `na.rm`, si le asignamos `TRUE` quitará de x los `NA` y `NaN` antes de realizar operaciones. 
* `names`, si le asignamos `TRUE`, hará que el objeto resultado de la función tenga nombres. 
* `type` espera un valor entre 1 y 9, para determinar el algoritmo usado para el cálculo de los cuantiles.

En orden, el primer argumento es `x`, el segundo `probs`, y así sucesivamente.

Cuando usamos `quantile()` en un `apply()`, el argumento `x` de la función será cada elemento de nuestra matriz. Es decir, los vectores como renglones o columnas de los que está constituida la matriz.

Esto funcionará siempre y cuando los argumentos sean apropiados para la función. Si proporcionamos un argumento inválido, la función no se ejecutará y **apply** fallará.

Por ejemplo, intentamos obtener cuantiles de las columnas de una matriz, en la que una de ellas es de tipo carácter.

Creamos una matriz.
```{r, echo=TRUE}
matriz2 <- matrix(c(1:2, "a", "b"), nrow = 2)

# Resultado
```

Aplicamos la función y obtenemos un error.
```{r, echo=TRUE, error=TRUE}
apply(matriz2, 2, quantile)
```

Por lo tanto, **apply sólo puede ser usado con funciones que esperan vectores como argumentos**.

### ¿Qué pasa si deseamos utilizar los demás argumentos de una función con apply?
En los casos en los que una función tiene recibe más de un argumento, asignamos los valores de estos del nombre de la función, separados por comas, usando sus propios nombres (a este procedimiento es al que se refiere el argumento `...` descrito en la documentación de `apply`).

Supongamos que deseamos encontrar los cuantiles de un vector, correspondientes a las probabilidades **.33** y **.66**. Esto es definido con el argumento `probs` de esta función. 

Para ello, usamos `quantile()` y después de haber escrito el nombre de la función, escribimos el nombre del argumento probs y los valores que deseamos para este.
```{r, echo = TRUE}
apply(X = matriz, MARGIN = 2, FUN = quantile, probs = c(.33, .66))
```

Como podrás ver, hemos obtenido los resultados esperados.

Si además deseamos que el resultado aparezca sin nombres, entonces definimos el valor del argumento `names` de la misma manera.
```{r, echo=TRUE}
apply(matriz, 2, quantile, probs = c(.33, .66), names = FALSE)
```

De este modo es posible aplicar funciones complejas que aceptan múltiples argumentos, con la ventaja que usamos pocas líneas de código.

### ¿Qué tipo de resultados devuelve apply?
En los ejemplos anteriores, el resultado de `apply()` en algunas ocasiones fue un vector y en otros fue una matriz. 

Si aplicamos `mean()`, obtenemos como resultado un vector.
```{r, echo=TRUE}
mat_media <- apply(matriz, 1, mean)

class(mat_media)
```

Pero si aplicamos `quantile()`, obtenemos una matriz.
```{r, echo=TRUE}
mat_cuant <- apply(matriz, 1, quantile)

class(mat_cuant)
```

Este comportamiento se debe a que **`apply()` nos devolverá objetos del mismo tipo que la función aplicada devuelve**. Dependiendo de la función, será el tipo de objeto que obtengamos. 

Sin embargo, este comportamiento puede causarte algunos problemas. En primer lugar, anterior te obliga a conocer de antemano el tipo del resultado que obtendrás, lo cual no siempre es fácil de determinar, en particular si las funciones que estás utilizando son poco comunes o tienen comportamientos poco convencionales.

Cuando estás trabajando en proyectos en los que el resultado de una operación será usado en operaciones posteriores, corres el riesgo de que en alguna parte del proceso, un `apply()` te devuelva un resultado que te impida continuar adelante.

Con algo de práctica es más o menos sencillo identificar problemas posibles con los resultados de `apply()`, pero es algo que debes tener en cuenta, pues puede explicar por qué tu código no funciona como esperabas.

En este sentido, `lapply()` tiene la ventaja de que siempre devuelve una lista.

## lapply
`lapply()` es un caso especial de `apply()`, diseñado para **aplicar funciones a todos los elementos de una lista**. La **l** de su nombre se refiere, precisamente, a **lista**. 

`lapply()` intentará coercionar a una lista el objeto que demos como argumento y después aplicará una función a todos sus elementos. 

`lapply` siempre nos devolverá una lista como resultado. A diferencia de `apply`, sabemos que siempre obtendremos un objeto de tipo lista después de aplicar una función, sin importar cuál función sea.

Dado que en R todas las estructuras de datos pueden coercionarse a una lista, `lapply()` puede usarse en un número más amplio de casos que `apply()`, además de que esto nos permite utilizar funciones que aceptan argumentos distintos a vectores.

La estructura de esta función es:
```{r, eval=FALSE}
lapply(X, FUN)
```

En donde:

* `X` es una lista o un objeto coercionable a una lista.
* `FUN` es la función a aplicar.

Estos argumentos son idéntico a los de `apply()`, pero a diferencia aquí no especificamos `MARGIN`, pues las listas son estructuras con una unidimensionales, que sólo tienen largo.

### Usando lapply()
Probemos `lapply()` aplicando una función a un data frame. Usaremos el conjunto de datos `trees`, incluido por defecto en R *base*.

`trees` contiene datos sobre el grueso, alto y volumen de distinto árboles de cerezo negro. Cada una de estas variables está almacenada en una columna del data frame.

Veamos los primeros cinco renglones de `trees`.
```{r, echo=TRUE}
trees[1:5, ]
```

Aplicamos la función `mean()`, usando su nombre.
```{r, echo=TRUE}
lapply(X = trees, FUN = mean)
```

Dado que un data frame está formado por columnas y cada columna es un vector atómico, cuando usamos `lapply()` , la función es aplicada a cada columna. `lapply()`, a diferencia de `apply()` no puede aplicarse a renglones.

En este ejemplo, obtuvimos la media de grueso (Girth), alto (Height) y volumen (Volume), como una lista.

Verificamos que la clase de nuestro resultado es una lista con `class()`.
```{r, echo=TRUE}
arboles <- lapply(X = trees, FUN = mean)

class(arboles)
```

Esto es muy conveniente, pues la recomendación para almacenar datos en un data frame es que cada columna represente una variable y cada renglón un caso (por ejemplo, el enfoque **tidy** de [Wickham (2014)](https://www.jstatsoft.org/article/view/v059i10/v59i10.pdf)). Por lo tanto,  con `lapply()` podemos manipular y transformar datos, por variable.

Al igual que con `apply()`, podemos definir argumentos adicionales a las funciones que usemos, usando sus nombres, después del nombre de la función.
```{r, echo=TRUE}
lapply(X = trees, FUN = quantile, probs = .8)
```

Si usamos `lapply` con una matriz, la función se aplicará a cada **celda** de la matriz, no a cada columna.

Creamos una matriz.
```{r, echo=TRUE}
matriz <- matrix(1:9, ncol = 3)

# Resultado
matriz
```

Llamamos a  `lapply()`.
```{r}
lapply(matriz, quantile, probs = .8)
```

Para usar una matriz con `lapply()` y que la función se aplique a cada columna, primero la coercionamos a un data frame con la función `as.data.frame()`
```{r, echo=TRUE}
lapply(as.data.frame(matriz), quantile, probs = .8)
```

Si deseamos aplicar una función a los renglones de una matriz, una manera de lograr es transponer la matriz con `t()` y después coercionar a un data frame.
```{r, echo=TRUE}
matriz_t <- t(matriz)

lapply(as.data.frame(matriz_t), quantile, probs = .8)
```

Con vectores como argumento, `lapply()` aplicará la función a cada elementos del vector, de manera similar a una vectorización de operaciones. 

Por ejemplo, usamos `lapply()` para obtener la raíz cuadrada de un vector numérico del 1 al 4, con la función `sqrt()`.
```{r, echo=TRUE}
mi_vector <- 1:4

lapply(mi_vector, sqrt)
```

### Usando lapply() en lugar de un bucle for
En muchos casos es posible reemplazar un bucle `for()` por un `lapply()`. 

De hecho, `lapply()` está haciendo lo mismo que un `for()`, está iterando una operación en todos los elementos de una estructura de datos.

Por lo tanto, el siguiente código con un `for()`...
```{r, echo=TRUE}
mi_vector <- 6:12
resultado <- NULL
posicion <- 1

for(numero in mi_vector) {
  resultado[posicion] <- sqrt(numero)
  posicion <- posicion + 1
}

resultado
```

... nos dará los mismos resultados que el siguiente código con `lapply()`.
```{r, echo=TRUE}
resultado <- NULL

resultado <- lapply(mi_vector, sqrt)

resultado
```

El código con `lapply()` es mucho más breve y más sencillo de entender, al menos para otros usuarios de R.

El inconveniente es que obtenemos una lista como resultado en lugar de un vector, pero eso es fácil de resolver usando la función `as.numeric()` para hacer coerción a tipo numérico.
```{r, echo=TRUE}
as.numeric(resultado)
```

El siguiente código es la manera en la que usamos `for()` si deseamos aplicar una función a todas sus columnas, tiene algunas partes que no hemos discutido, pero es sólo para ilustrar la diferencia simplemente usar `trees_max <- lapply(trees, max)`.
```{r, echo=TRUE}
trees_max <- NULL
i <- 1
columnas <- ncol(trees)

for(i in 1:columnas) {
  trees_max[i] <- max(trees[, i])
  i <- i +1
}

trees_max
```

### Usando lapply con listas
Hasta hora hemos hablado de usar `lapply()` con objetos que pueden coercionarse a una lista, pero ¿qué pasa si usamos esta función con una lista que contiene a otros objetos?

Pues la función se aplicará a cada uno de ellos. Por lo tanto, así podemos utilizar funciones que acepten todo tipo de objetos como argumento. Incluso podemos aplicar funciones a listas recursivas, es decir, listas de listas.

Por ejemplo, obtendremos el coeficiente de correlación de cuatro data frames contenidos en una sola lista. Esto no es posible con `apply()`, porque sólo podemos usar funciones que aceptan vectores como argumentos, pero con `lapply()` no es ningún problema.

Empezaremos creando una lista de data frames. Para esto, usaremos las función `rnorm()`, que genera números al azar y `set.seed()`, para que obtengas los mismos resultados aquí mostrados.

`rnorm()` creara `n` números al azar (pseudoaleatorios, en realidad), sacados de una distribución normal con media 0 y desviación estándar 1. `set.seed()` es una función que "fija" los resultados de una generación de valores al azar. Cada que ejecutas `rnorm()` obtienes resultados diferentes, pero si das un número como argumento `seed` a `set.seed()`, siempre obtendrás los mismos números.
```{r, echo = TRUE}
# Fijamos seed
set.seed(seed = 2018)

# Creamos una lista con tres data frames dentro
tablas <- list(
  df1 = data.frame(a = rnorm(n = 5), b = rnorm(n = 5), c = rnorm(n = 5)),
  df2 = data.frame(d = rnorm(n = 5), e = rnorm(n = 5), f = rnorm(n = 5)),
  df3 = data.frame(g = rnorm(n = 5), h = rnorm(n = 5), i = rnorm(n = 5))
)

# Resultado
tablas
```

Para obtener el coeficiente de correlación usaremos la función `cor()`. 

Esta función acepta como argumento una data frame o una matriz. Con este objeto, calculará el coeficiente de correlación **R de Pearson** existente entre cada una de sus columnas. Como resultado obtendremos una matriz de correlación.

Por ejemplo, este es el resultado de aplicar `cor()` a `iris`.
```{r, echo=TRUE}
cor(iris[1:4])
```

Con `lapply` aplicaremos `cor()` a cada uno de los data frames contenidos en nuestra lista. El resultado será una lista de matrices de correlaciones.

Esto lo logramos con una línea de código.
```{r, echo=TRUE}
lapply(X = tablas, FUN = cor)
```

De esta manera puedes manipular información de múltiples data frames, matrices o listas con muy pocas líneas de código y, en muchos casos, más rápidamente que con las alternativas existentes.

Finalmente, si asignamos los resultados de las última operación a un objeto, podemos usarlos y manipularlos de la misma manera que cualquier otra lista.

```{r, echo = TRUE}
correlaciones <- lapply(tablas, cor)

# Extraemos el primer elemento de la lista
correlaciones[[1]]
```

<!--chapter:end:10-apply.Rmd-->

# Importar y exportar datos
Hasta ahora, hemos trabajado con datos ya existentes en R *base* o que hemos generado nosotros mismos, sin embargo, lo usual es que usemos datos almacenados en archivos fuera de R.

R puede importar datos de una amplia variedad de tipos de archivo con las funciones en *base* además de que esta capacidad es ampliada con el uso de paquetes específicos.

Cuando importamos un archivo, estamos guardando su contenido en nuestra sesión como un objeto. Dependiendo del procedimiento que usemos será el tipo de objeto creado.

De manera análoga, podemos exportar nuestros objetos de R a archivos en nuestra computadora.

## Descargando datos
Antes de empezar a importar datos, vale la pena señalar que  podemos descargar archivos de internet usando R con la función `download.file()`.

De esta manera tendremos acceso a una vasta diversidad de fuentes de datos. Entre otras, podrás descargar los archivos 

La función `download.file()` nos pide como argumento `url`, la dirección de internet del archivo que queremos descargar y `destfile` el nombre que tendrá el archivo en nuestra computadora. Ambos argumentos como cadenas de texto, es decir, entre comillas.

Por ejemplo, para descargar una copia del set *iris* disponible en el [*UCI Machine Learning Repository*](https://archive.ics.uci.edu) usamos la siguiente dirección como argumento `url`:

* https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data

Y asignamos "iris.data" al argumento `dest`.
```{r descarga iris, echo=TRUE, eval=FALSE}
download.file(
  url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data", 
  destfile = "iris.data"
  )
```

El resultado es un archivo llamado "iris.data" en nuestro directorio de trabajo. 

Este método funciona con prácticamente todo tipo de archivos, aunque en algunos casos será necesario agregar el argumento `method = "wb"`, por asegurar que el archivo obtenido funcione correctamente.

## Tablas (datos rectangulares)
Como vimos en el capítulo [7](#estructuras-de-datos), las estructura rectangular, en renglones y columnas, es común y conveniente para el análisis de datos. Nos referiremos a esta forma de organizar datos como **tabla**.

R cuenta con la función genérica `read.table()`, que puede leer cualquier tipo de archivo que contenga una tabla. 

La condición para que R interprete un archivo como una tabla es que tenga renglones y en cada renglón, los datos estén separados por comas, o algún otro carácter, indicando columnas. Es decir, algo que luzca de la siguiente manera.

>1, 20,  8, 5

>1, 31,  6, 5

>2, 18,  9, 5

>2, 25, 10, 5

Por supuesto, en lugar de comas podemos tener puntos y coma, dos puntos, tabuladores o cualquier otro signo de puntuación como **separador** de columnas.

La función `read.table()` acepta un número considerable de argumentos. Los más importantes son los siguientes.

* `file`: La ruta del archivo que importaremos, como cadena de texto. Si el archivo se encuentra en nuestro [directorio de trabajo](##directorio-de-trabajo), es suficiente dar el nombre del archivo, sin la ruta completa.
* `header`: Si nuestro archivo tiene encabezados, para ser interpretados como nombres de columna, definimos este argumento como `TRUE`.
* `sep`: El carácter que es usado como separador de columnas. Por defecto es ";".
* `col.names`: Un vector opcional, de tipo carácter, con los nombres de las columnas en la tabla.
* `stringsAsFactors`: Esta función convierte automáticamente los datos de texto a factores. Si este no es el comportamiento que deseamos, definimos este argumento como `FALSE`.

Puedes consultar todos los argumentos de esta función ejecutando `?read.table` en la consola.

Es importante señalar que el objeto obtenido al usar esta función es siempre un **data frame**.

Probemos con un archivo con extensión ".data", descargado desde el repositorio de [Github](http://www.github.com) de este libro. 
```{r descarga cancer.data, echo=TRUE, eval=FALSE}
download.file(
  url = "https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.data", 
  dest = "breast-cancer-wis.data"
)
```

Estos datos pertenecen a una base de diagnósticos de cáncer mamario de la Universidad de Wisconsin, usado para probar métodos de aprendizaje automático. Puedes encontrar la información completa sobre este conjunto de datos en el siguiente enlace:

* https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29

Nos damos cuenta de que hemos tenido éxito en la descarga si aparece un mensaje en la consola de R indicando los resultados de nuestra operación.

Usamos sin especificar ningún otro argumento.
```{r read.table no args, echo=TRUE}
bcancer <- read.table(file = "datos/breast-cancer-wis.data")
```

Veamos los primeros renglones de nuestros datos usando la función `head()`
```{r read.table no args head, echo=TRUE}
head(bcancer)
```

Nuestros datos no lucen particularmente bien. Necesitamos ajustar algunos parámetros al importarlos.

No hay datos de encabezado, por lo que `header` será igual a `FALSE` y  el separador de columnas es una coma, así que el valor de `sep` será ",". No conocemos cuál es el nombre de las columnas, así que por el momento no proporcionaremos uno.

```{r read.table args, echo=TRUE}
bcancer <- read.table(file = "datos/breast-cancer-wis.data", header = FALSE, sep = ",")

# Resultado
head(bcancer)
```

Luce mejor, pero los nombres de las columnas son poco descriptivos. Si no damos nombres de variables, cada columna tendrá como nombre "V" seguida de números del 1 adelante.

Para este ejemplo, contamos con un archivo de información, que describe el contenido de los datos que hemos importado.

* https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.names

Si descargas este archivo, puedes abrirlo usando el bloc o navegador de internet de tu computadora.

Guardaremos en un vector las abreviaturas de los nombres de columna descritos en el documento anterior.
```{r nombres bcancer, echo=TRUE}
nombres <- c("id", "clump_t", "u_csize", "u_cshape", "m_adh", "spcs", "b_nuc", 
             "b_chr", "n_nuc", "mit", "class")
```

Ahora usaremos este vector como argumento `col.names` en `read.table()`, para importar nuestros datos con nombres de columna.
```{r, echo=TRUE}
bcancer <- read.table(file = "datos/breast-cancer-wis.data", header = FALSE, sep = ",",
                      col.names = nombres)

# Resultado
head(bcancer)
```

Nuestros datos han sido importados correctamente. Además, el objeto resultante es un data frame, listo para que trabajemos con él.
```{r, echo=TRUE}
class(bcancer)
```

### Archivos CSV
Un caso particular de las tablas, son los archivos separados por comas, con extensión **.csv**, por *Comma Separated Values*, sus siglas en inglés. Este es un tipo de archivo comúnmente usado para compartir datos, pues es compatible con una amplia variedad de sistemas diferentes además de que ocupa relativamente poco espacio de almacenamiento.

Este tipo de archivos también se pueden importar usando la función `read.table()`.

Probemos descargando los mismos datos que en el ejemplo anterior, pero almacenados en un archivo con extensión **.csv**.
```{r, echo=TRUE, eval=FALSE}
download.file(
  url = "https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.csv", 
  dest = "breast-cancer-wis.csv"
)
```

Podemos usar `read.table()` con los mismos argumentos que en el ejemplo anterior, con la excepción de que este archivo sí tiene encabezados de columna, por lo que cambiamos `header` de `FALSE` a `TRUE`.
```{r read.table breast cancer, echo=TRUE}
bcancer <- read.table(file = "datos/breast-cancer-wis.csv", header = TRUE, sep = ",",
                      col.names = nombres)

# Resultado
head(bcancer)
```

Una ventaja de usar documentos con extensión **.csv** es la posibilidad de usar la función `read.csv()`. Esta es una es una versión de `read.table()`, optimizada para importar archivos **.csv**.

`read.csv()` acepta los mismos argumentos que `read.table()`, pero al usarla con un archivo **.csv**, en casi todo los casos, no hará falta especificar nada salvo la ruta del archivo.
```{r readcsv, echo=TRUE}
bcancer <- read.csv("datos/breast-cancer-wis.csv")

# Resultado
head(bcancer)
```

`read.csv()` también devuelve un data frame como resultado

## Archivos con una estructura desconocida
Habrá ocasiones en las que no estamos seguros del contenido de los archivos que deseamos importar. En estos casos, podemos pedirle a R que intente abrir el archivo en cuestión, usando la función `file.show()`.

Por ejemplo, intentamos abrir el archivo con extensión **.csv** que importamos antes.
```{r fileshow bc csv, echo=TRUE, eval=FALSE}
file.show("datos/breast-cancer-wis.csv")
```

R intentará usar el programa que en nuestro equipo, por defecto, abre el tipo de archivo que le hemos indicado. Si no tenemos un programa configurado para abrir el tipo de archivo que deseamos, nuestro sistema operativo nos pedirá que elijamos uno.

Lo anterior puede ocurrir si intentas abrir el archivo con extensión **.data** que hemos importado en este capítulo.
```{r file.show bc data, echo=TRUE, eval=FALSE}
file.show("datos/breast-cancer-wis.data")
```

Podemos usar la función `readLines()` para leer un archivo línea por línea. Establecemos el argumento `n = 4` para obtener sólo los primeros cuatro renglones del documento.
```{r, echo = TRUE}
readLines("datos/breast-cancer-wis.data", n = 4)
```

La salida es una lista de vectores, uno por linea en el archivo. 

Observando la salida de `readLines()` podremos determinar si el archivo que nos interesa puede ser importado usando con los métodos que hemos revisado o necesitaremos de herramientas diferentes.

El documento "R Data Import/Export" (R Core Team, 2018) contiene una guía avanzada sobre el proceso de importar y exportar todo tipo de datos. Puedes consultarlo en el siguiente enlace:

* https://cran.r-project.org/doc/manuals/r-release/R-data.pdf

## Exportar datos
Un paso muy importante en el trabajo con R es exportar los datos que hemos generado, ya sea para que sean usados por otras personas o para almacenar información en nuestro disco duro en lugar de nuestro RAM. 

Dependiendo del tipo de estructura de dato en el que se encuentran contenidos nuestros datos son las opciones que tenemos para exportarlos.

### Data frames y matrices
Si nuestros datos se encuentran contenidos en una estructura de datos rectangular, podemos exportarlos con diferentes funciones.

De manera análoga a `read.table()`, la función `write.table()` nos permite exportar matrices o data frames, como archivos de texto con distintas extensiones.

Los argumentos más usados de `write.table()` son los siguientes.

* `x`:  El nombre del data frame o matriz a exportar.
* `file`: El nombre, extensión y ruta del archivo creado con esta función. Si sólo escribimos el nombre del archivo, este será creado en nuestro directorio de trabajo.
* `sep`: El carácter que se usará como separador de columnas.
* `row.names`: Si deseamos incluir el nombre de los renglones en nuestro objeto al exportarlo, establecemos este argumento como `TRUE`. En general, es recomendable fijarlo como `FALSE`, para conservar una estructura tabular más fácil de leer.
* `col.names`: Si deseamos que el archivo incluya los nombres de las columnas en nuestro objeto, establecemos este argumento como `TRUE`. Es recomendable fijarlo como `TRUE` para evitar la necesidad de almacenar los nombres de columna en documentos distintos.

Puedes consultar todos los argumentos de esta función ejecutando `?write.table`.

Probemos exportando el objeto `iris` a un documento de texto llamado **iris.txt** a nuestro directorio de trabajo, usando como separador la coma, con nombres de columnas y sin nombre de renglones. 
```{r write.table, echo=T}
write.table(x = iris, file = "iris.txt", sep = ",", 
            row.names = FALSE, col.names = TRUE)
```

Importemos el archivo que hemos creado usando `read.table()`.
```{r exportar iris.txt, echo=TRUE}
iris_txt <- read.table(file = "iris.txt", header = TRUE, sep = ",")

# Resultado
head(iris_txt)
```

También podemos exportar datos a archivos con extensión **.csv** con la función `write.csv()`. 

Vamos a exportar `iris` como un documento **.csv**. En este caso, sólo especificamos que no deseamos guardar los nombres de los renglones con `row.names = FALSE`.
```{r exportar iris.csv, echo=TRUE}
write.csv(x = iris, file = "iris.csv", row.names = FALSE) 
```

Importamos el archivo creado.
```{r importar iris.csv, echo=TRUE}
iris_csv <- read.csv("iris.csv")

# Resultado
head(iris_csv)
```

### Listas
La manera más sencilla de exportar listas es guardarlas en archivos RDS. Este es un tipo de archivo nativo de R que puede almacenar cualquier objeto a un archivo en nuestro disco duro. 

Además, RDS comprime los datos que almacena, por lo que ocupa menos espacio en disco duro que otros tipos de archivos, aunque contengan la misma información.

Para exportar un objeto a un archivo RDS, usamos la función `saveRDS()` que siempre nos pide dos argumentos:

* `object`: El nombre del objeto a exportar.
* `file`: El nombre y ruta del archivo que crearemos. Los archivos deben tener la extensión **.rds**. Si no especificamos una ruta completa, el archivo será creado en nuestro directorio de trabajo.

Creamos una lista de ejemplo que contiene dos vectores y dos matrices
```{r lista a exportar, echo = TRUE}
mi_lista <- list("a" = c(TRUE, FALSE, TRUE),
     "b" = c("a", "b", "c"),
     "c" = matrix(1:4, ncol = 2),
     "d" = matrix(1:6, ncol = 3))


# Resultado
mi_lista
```

Aunque podemos intentar `write.table()` para exportar listas, por lo general obtendremos un error como resultado.

Tratamos de exportar la lista anterior como un archivo **.txt**.
```{r lista intento write.table, echo = TRUE, error=TRUE}
write.table(x = mi_lista, file = "mi_lista.txt")
```

Usamos la función `saveRDS()` para exportar al archivo **mi_lista.rds**.
```{r exportar rds, echo = TRUE}
saveRDS(object = mi_lista, file = "mi_lista.rds")
```

Si deseamos importar un archivo RDS a R, usamos la función `readRDS()`, indicando la ruta en la que se encuentra el archivo que deseamos.

Intentemos importar el archivo **mi_lista.rds**.
```{r importar rds, echo=TRUE}
mi_lista_importado <- readRDS(file = "mi_lista.rds")
```

Vamos el resultado.
```{r resultado rds, echo=TRUE}
mi_lista_importado

# El resultado es una lista, al igual que el objeto original
class(mi_lista)
```

Los objetos importados usando un archivo RDS conservan los tipos y clases que tenían originalmente, lo cual previene pérdida de información.

## Hojas de cálculo de Excel
Un formato usado con mucha frecuencia para almacenar archivos son las hojas de cálculo, en particular las generadas por el paquete [*Microsoft Excel*](https://products.office.com/es-mx/excel).

R *base* no tiene una función para importar archivos almacenados en archivos con extensión **.xsl** y **.xslx**, creados con *Excel*.

Para importar datos desde este tipo de archivos, necesitamos instalar el paquete **readxl**, que contiene funciones específicas para realizar esta tarea.

Usamos la función `installpackages()`, como lo vimos en el [capítulo 3](##paquetes)
```{r instalar readxl, echo =TRUE, eval=FALSE}
install.packages("readxl")
```

Ya instalado, cargamos el **readxl** a nuestra sesión de trabajo.
```{r, echo=TRUE}
library(readxl)
```

Usaremos, principalmente dos funciones de este paquete.

* `read_excel()`: Para importar archivos **.xls** y **xlsx**.
* `excel_sheets()`: Para obtener los nombres de las pestañas en una hoja de cálculo de *Excel*.

Para probar estas funciones, descargaremos una hoja de cálculo de prueba. Nota que hemos establecido el argumento `mode = "wb"` para asegurar que el archivo se descargue correctamente.
```{r descarga xlsx, echo=TRUE, eval=FALSE}
download.file(
  url = "https://github.com/jboscomendoza/r-principiantes-bookdown/raw/master/datos/data_frames.xlsx", 
  destfile = "datos/data_frames.xlsx", 
  mode = "wb"
) 
```

Si intentamos leer las primeras cinco líneas de **data_frames.xlsx**, confirmamos que este es un archivo que no tiene forma rectangular, de tabla.
```{r readLines xlsx, echo = TRUE}
readLines("datos/data_frames.xlsx", n = 5)
```

En caso de que tengamos instalado *Excel* o algún otro programa compatible con archivos de hoja de cálculo, como *LibreOffice Calc* o *Number*, podemos pedir a R que abra este archivo con `file.show()`. De este modo podemos explorar su contenido.
```{r file.show xlsx, echo=TRUE, eval=FALSE}
file.show("datos/data_frames.xlsx")
```

La función `excel_sheets()` nos devuelve el nombre de las pestañas como un vector.
```{r excel_sheets, echo=TRUE}
excel_sheets("datos/data_frames.xlsx")
```

Este archivo tiene dos pestañas, llamadas **iris** y **trees**. 

Intentaremos importar la pestaña **iris** con `read_excel()`. Esta función tiene los siguientes argumentos principales. 

* `path`: La ruta del archivo a importar. Si no especificamos una ruta completa, será buscado en nuestro directorio de trabajo.
* `sheet`: El nombre de la pestaña a importar. Si no especificamos este argumento, `read_excel()` intentará leer la primera pestaña de la hoja de cálculo.
* `range`: Cadena de texto con el rango de celdas a importar, escrito con el formato usado en *Excel*. Por ejemplo, "A1:B:10".
* `col_names`: Con este argumento indicamos si la pestaña que vamos a importar tiene encabezados para usar como nombres de columna. Por defecto su valor es `TRUE`. Si no tenemos encabezados, podemos dar un vector con nombres para asignar a las columnas.

Puedes consultar todos los argumentos de esta función ejecutando `?read_excel`.

Probemos `read_excel()`.
```{r read_excel iris, echo=TRUE}
iris_excel <- read_excel(path = "datos/data_frames.xlsx", sheet = "iris")
```

Nuestro resultado es un data frame.
```{r iris_excel, echo=TRUE}
iris_excel
```

Si los datos en la hoja de cálculo tienen forma de tabla, `read_excel()` no tendrá problemas para importarlos. Cuando este no es el caso, usamos el argumento `range` para extraer sólo la información que nos interesa.


Intentamos importar la pestaña **trees**.
```{r read excel tree malo, echo=TRUE}
trees_excel <- read_excel(path = "datos/data_frames.xlsx", sheet = "trees")

# Resultado
trees_excel
```

Los resultados no lucen bien porque los datos en la pestaña no tienen forma de tabla. 

Ajustamos los argumentos de `read_excel()` para leer correctamente la información de la pestaña. Al explorar manualmente el archivo **data.frames.xlsx**, podemos localizar el rango en el que se encuentran los datos (de las celdas B3 a D33) y los nombres de las columnas (Girth, Height y Volume).

Probemos importar de nuevo con esta información.
```{r read_excel trees bueno, echo=TRUE}
trees_excel <- read_excel(path = "datos/data_frames.xlsx", sheet = "trees", 
                          range = "B3:D33", 
                          col_names = c("Girth", "Height", "Volume"))

# Resultado
trees_excel
```

Esta vez hemos tenido éxito y los datos importados son los correctos.

El paquete **readxl** tiene más funciones para trabajar con hojas de cálculo además de `read_excel()` y `excel_sheets()`, pero revisar cada una de ellas sale del alcance de este libro. Puedes conocer más sobre ellas en la documentación de **readxl**, llamando `help(package = "readxl")`.

## Datos de paquetes estadísticos comerciales (SPSS, SAS y STATA)
En ciertas disciplinas, el uso de determinados paquetes estadísticos comerciales es sumamente común. Si

Por ejemplo, en Psicología el paquete [*SPSS Statistics*](https://www.ibm.com/products/spss-statistics) de IBM es el paquete estadístico comercial más usado. Si eres psicólogo o psicóloga, o colaboras con psicólogos, es altamente probable que te encuentres con datos contenidos en archivos con extensión **.sav**, el tipo de archivo nativo de **SPSS Statistics**.

Por lo tanto, es conveniente ser capaces de importar y exportar datos almacenados en archivos compatibles con paquetes estadísticos comerciales, pues esto nos permitirá  usar datos ya existentes compatibles con ellos y colaborar con otras personas.

Para este fin, usamos el paquete **haven**.
```{r haven instalar, echo=TRUE, eval=FALSE}
install.packages("haven")
```

Para usar las funciones de **haven**, lo cargamos a nuestra sesión de trabajo.
```{r haven library, echo=TRUE}
library(haven)
```

Las siguientes funciones de **haven** son usadas para importar datos. Todas estas funciones nos piden como argumento `file` la ruta y nombre del archivo a importar, si no especificamos ruta, será buscado en nuestro directorio de trabajo.

* `read_spss()`: *SPSS Statistics*, archivos con extensión **sav**, **zsav** y **por**.
* `read_sav()`: *SPSS Statistics*, sólo archivos **sav**, **zsav**.
* `read_sas()`: *SAS*, archivos **sas7bdat**.
* `read_xpt`: *SAS*, archivos **xpt**.
* `read_stata()`: *Stata*, archivos **dta**.

Todas importan los datos como un data frame.

También podemos exportar nuestros data frames creados en R como archivos compatibles con estos programas con las siguientes funciones. Todas piden el argumento `file`, con la ruta y nombre del archivo a crear. Es muy importante que demos como nombre de archivo uno con la extensión correcta para cada paquete.

* write_sav(): *SPSS Statistics*, archivos **sav**, **zsav** o **por**.
* write_sas(): *SAS*, archivos **sas7bda**.
* write_xpt(): *SAS*, archivos **xpt**.
* write_dta(): *Stata*, archivos **dta**.

Como siempre, puedes leer sobre las demás funciones en el paquete **haven** en su documentación, llamando `help(package = "haven")`.


<!--chapter:end:11-importar-y-exportar.Rmd-->

# Gráficas
R cuenta con un sistema de generación de gráficas poderoso y flexible. Sin embargo, tener estar cualidades hace que este sistema sea un tanto complejo para aprender.

En este capítulo revisaremos como crear las gráficas más comunes con R *base*, así como algunos de los parámetros que podemos ajustar para mejorar su presentación. 


Al crear gráficas, notarás que ponemos en práctica todo lo que hemos visto en los capítulos anteriores, incluyendo importar datos, hacer subconjuntos de un objeto y uso de funciones.

## Datos usados en el capítulo
Para las siguientes secciones utilizaremos de nuevo una copia de los datos disponibles en el [*UCI Machine Learning Repository*](https://archive.ics.uci.edu/ml/index.php).

Usaremos un conjunto de datos llamado *"Bank Marketing Data Set"*, que contiene información de personas contactadas en una campaña de *marketing* directo puesta en marcha por un banco de Portugal.

Comenzamos con la descarga de la copia del archivo **csv** desde el sitio de *Github* de este libro.
```{r dl bank, echo=TRUE, eval=FALSE}
download.file(
  url = "https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/bank.csv", 
  destfile = "datos/bank.csv"
  )
```

Damos un vistazo al contenido del archivo **bank.csv** con `readLines()`.
```{r readLines banco, echo=TRUE}
readLines("datos/bank.csv", n = 4) 
```

Por la estructura de los datos, podremos usar la función  `read.csv()`, con el argumento `sep = ";"` para importarlos como un data frame.
```{r importar banco, echo=TRUE}
banco <- read.csv(file = "datos/bank.csv", sep = ";")
```

Vemos las primeras líneas del conjunto con `head()`, el número de renglones y columnas con  `dim()`.
```{r explora banco, echo?TRUE}
# Primeros datos
head(banco)

# Dimensiones
dim(banco)
```

Usamos `lapply()` con la función `class()` para determinar el tipo de dato de cada columna en `banco`. Conocer esto nos será muy útil más adelante.
```{r lapplyclass banco, echo=TRUE}
lapply(banco, class)
```

Y por último, pedimos un resumen de nuestros datos con la función `summary()`. Esta función acepta cualquier tipo de objeto como argumento y nos devuelve un resumen descriptivo de los datos de cada uno de sus elementos.
```{r banco summary, echo=TRUE}
summary(banco)
```

## La función `plot()`
En R, la función `plot()` es usada de manera general para crear gráficos.

Esta función tiene un comportamiento especial, pues dependiendo del tipo de dato que le demos como argumento, generará diferentes tipos de gráfica. Además, para cada tipo de gráfico, podremos ajustar diferentes parámetros que controlan su aspecto, dentro de esta misma función.

Puedes imaginar a  `plot()` como una especie de navaja Suiza multi-funcional, con una herramienta para cada ocasión.

`plot()` siempre pide un argumento `x`, que corresponde al **eje X** de una gráfica. `x` requiere un vector y si no especificamos este argumento, obtendremos un error y no se creará una gráfica.

El resto de los argumentos de `plot()` son opcionales, pero el más importante es `y`. Este argumento también requiere un vector y corresponde al **eje Y** de nuestra gráfica. 

Dependiendo del tipo de dato que demos a `x` y `y` será el gráfico que obtendremos, de acuerdo a las siguientes reglas:

`x`       | `y`         | Gráfico
---       |---          |---
Continuo  | Continuo    | Diagrama de dispersión (*Scatterplot*)
Continuo  | Discreto    | Diagrama de dispersión, `y` coercionada a numérica
Continuo  | Ninguno     | Diagrama de dispersión, por número de renglón
Discreto  | Continuo    | Diagrama de caja (*Box plot*)
Discreto  | Discreto    | Gráfico de mosaico (Diagrama de Kinneman)
Discreto  | Ninguno     | Gráfica de barras
Ninguno   | Cualquiera  | Error

En donde los tipos de dato son:

* **Continuo**: Un vector numérico, entero, lógico o complejo.
* **Discreto**: Un vector de factores o cadenas de texto.

Además de `plot()`, hay funciones que generan tipos específicos de gráfica. Por ejemplo, podemos crear una gráfica de barras con `plot()` pero existe también la función `barplot()`. También existen también casos como el de los histogramas, que sólo pueden ser creados con la función `hist()`.

Cuando llamas a la función `plot()` o alguna otra similar, R abre una ventana mostrando ese gráfico. Si estás usando RStudio, el gráfico aparece en el panel **Plot**. Si llamas de nuevo la función `plot()`, el gráfico generado más reciente reemplazará al más antiguo y en RStudio se creará una nueva pestaña en en el panel **Plot**. El gráfico reemplazado se perderá.

Por lo tanto, a menos que nosotros los indiquemos, nuestros gráficos se pierden al crear uno nuevo. Al final de este capítulo veremos cómo exportar gráficos de manera más permanente.

## Histogramas
Un histograma es una gráfica que nos permite observar la distribución de datos numéricos usando barras. Cada barra representa el número de veces (frecuencia) que se observaron datos en un rango determinado.

Para crear un histograma usamos la función `hist()`, que siempre nos pide como argumento `x` un vector numérico. El resto de los argumentos de esta función son opcionales. Si damos un vector no numérico, se nos devolverá un error.

Ya hemos trabajado con esta función en el [capítulo 8](##nuestra-funcion-crear-histograma), pero ahora profundizaremos sobre ella.

Probemos creando un histograma con las edades (*age*) de las personas en nuestro data frame `banco`. Sabemos que *age* 

Daremos como argumento a `hist()` la columna **age** como un vector, extraído de `banco` usando el signo de dolar `$`, aunque también podemos usar corchetes e índices.
```{r hist_age, echo=TRUE}
hist(x = banco$age)
```

Nuestro histograma luce bastante bien para habernos costado tan poco trabajo crearlo, aunque puede mejorar su presentación.

Podemos agregar algunos argumentos a la función `hist()` para modificar ciertos parámetros gráficos. 

Vamos a cambiar el título del gráfico con el argumento `main`, y el nombre de los ejes X y Y con `xlab` y `ylab`, respectivamente.

Estos argumentos requiere una cadena de texto y pueden agregados también a gráficos generados con `plot()`.
```{r hist_main, echo=TRUE}
hist(x = banco$age, main = "Histograma de Edad", 
     xlab = "Edad", ylab = "Frecuencia")
```

Probemos cambiando el color de las barras del histograma agregando el argumento `col`. Este argumento acepta nombres de colores genéricos en inglés como "red", "blue" o "purple"; y también acepta colores hexadecimales, como "#00FFFF", "#08001a" o "#1c48b5".

Puedes ver una lista de los nombres de colores válidos en R en el siguiente enlace:

* http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf

El tema de los colores hexadecimales sale del alcance de este libro, pero en el siguiente enlace encontrarás una *web app* para generar y elegir fácilmente colores de este tipo.

* https://www.w3schools.com/colors/colors_picker.asp

Probemos con columnas de color púrpura ("purple").
```{r hist_color, echo=TRUE}
hist(x = banco$age, main = "Histograma de Edad", 
     xlab = "Edad", ylab = "Frecuencia",
     col = "purple")
```

Nuestro histograma ya luce presentable.

Creamos ahora un histograma con los mismos argumentos, pero con los datos de la columna "duration", con barras de color marfil ("ivory") y los títulos apropiados.
```{r}
hist(x = banco$duration, main = "Histograma de Duration", 
     xlab = "Duration", ylab = "Frecuencia",
     col = "ivory")
```

Como es usual, puedes consultar los demás argumentos de esta función llamando `?hist()`.

## Gráficas de barras
Este es quizás el tipo de gráfico mejor conocido de todos. Una gráfica de este tipo nos muestra la frecuencia con la que se han observado los datos de una variable discreta, con una barra para cada categoría de esta variable.

La función `plot()` puede generar gráficos de barra si damos como argumento `x` un vector de factor o cadena de texto, sin dar un argumento `y`.

Por ejemplo, creamos una gráfica de barras de la variable educación ("education") de `banco`
```{r barra_plot, echo=TRUE}
#plot(x = banco$education)
```

Al igual que con los histogramas, obtenemos un resultado aceptable no obstante el esfuerzo mínimo que hemos hecho para generar nuestra gráfica de barras.

Podemos ajustar los parámetros gráficos con los argumentos `main`, `xlab`, `ylab` y `col`. En este caso, podemos darle a `col` un vector de colores, uno por barra, para que cada una sea distinta.
```{r bar_col, echo=TRUE}
#plot(x = banco$education, main = "Gráfica de Educacíón",
#     xlab = "Nivel educativo", ylab = "Frecuencia", 
#     col = c("royalblue", "seagreen", "purple", "grey"))
```

La combinación de colores puede mejorar, pero ya tenemos una gráfica de barras presentable.

Sin embargo, hay ocasiones en las que deseamos usar gráficas de barras para presentar proporciones, que deseamos barras apiladas. Para esos casos, usamos la función `barplot()`.

### La función `barplot()`
Además de usar `plot()`, podemos crear gráficas de barra con la función `barplot()`.

`barplot` pide como argumento una matriz, que represente una **tabla de contingencia** con los datos a graficar. Este tipo de tablas pueden ser generadas con la función `table()`.

`table()` pide como argumento uno o más vectores, de preferencia variables discretas. Si damos sólo un vector como argumento, devuelve un conteo, si damos dos o más variables, devuelve tablas de contingencia.

Por ejemplo, el conteo de la variable **education**,
```{r educacion_table, echo=TRUE}
table(banco$education)
```

Si damos como argumentos la variable **education** y la variable **loan** (préstamo), obtenemos una tabla de contingencia, que asignaremos al objeto `tab_banco`.
```{r eduloan_table, echo=TRUE}
tab_banco <- table(banco$loan, banco$education)

# Resultado
tab_banco
```

Damos como argumento `tab_banco` a `barplot()` y nos devuelve una gráfica de barras apiladas.
```{r bar, echo=TRUE}
barplot(tab_banco)
```

Si deseamos graficar proporciones en lugar de conteos, usamos la función `prop.table()`. 

Esta función nos pide como argumento una tabla de contingencia generada por `table()`. y un número para `margin`. El argumento `margin` es similar a `MARGIN` de `apply()` (como vimos en el [capítulo 10](###que-es-fun)). 

* Si damos como argumento 1, las proporciones se calcularán agrupadas por renglón. La suma de proporciones por renglón será igual a 1.
* Si damos como argumento 2, las proporciones se calcularán agrupadas por columna. La suma de proporciones por columna será igual a 1
* Si no damos ningún argumento, las proporciones se calcularán usando toda la tabla como grupo. La suma de proporciones de todas las celdas en la tabla será igual a 1.

Para ilustrar esto, veamos los tres casos para `margin` usando como argumento nuestro objeto `tab_banco`.
```{r}
# Proporción por renglón
prop.table(tab_banco, margin = 1)

# Porporción por columna
prop.table(tab_banco, margin = 2)

# Porporción por tabla
prop.table(tab_banco)
```

Nosotros queremos obtener las proporciones por columna, así que usaremos `margin = 2`.
```{r proptable_bar, echo=TRUE}
ptab_banco <- prop.table(tab_banco, margin = 2)
```

Damos el resultado de la operación anterior a `barplot()`.
```{r proptable_barplot, echo = TRUE}
barplot(ptab_banco)
```

Hemos obtenido el resultado esperado, pero podemos mejorar la presentación. Nota que con barras apiladas el argumento `col` se puede usar para colorear las categorías al interior de las barras.
```{r barplot_legend, echo=TRUE}
barplot(ptab_banco,  main = "Préstamos por nivel educativo",
     xlab = "Nivel educativo", ylab = "Proporción", 
     col = c("royalblue", "grey"))
```

Luce bien, pero tenemos un problema: no sabemos qué representan las categorías en nuestras barras apiladas viendo solamente nuestra gráfica. 

Nosotros podemos consultar directamente con los datos, pero una persona que vea por primera vez esta gráfica no tendrá esa opción, reduciendo con ello su utilidad. 

Para solucionar este problema, usamos leyendas.

## Leyendas
Las leyendas son usadas para identificar con mayor claridad los distintos elementos en un gráfico, tales como colores y formas.

En R usamos la función `legend()` para generar leyendas. Esta función debe ser llamada después de crear un gráfico. En cierto modo es una anotación a un gráfico ya existente. `legend()` es una función relativamente compleja, así que sólo revisaremos lo esencial. 

`legend()` siempre nos pide siempre los siguientes argumentos.

* `legend`: Las etiquetas de los datos que queremos describir con la leyenda. Por ejemplo, si tenemos cuatro categorías a describir, proporcionamos un vector de cuatro cadenas de texto.
* `fill`: Los colores que acompañan a las etiquetas definidas con `legend`. Estos colores tienen que coincidir con los que hemos usado en el gráfico.
* `x` y `y`: Las coordenadas en pixeles, en las que estará ubicada la leyenda. Podemos dar como argumento a `x` alguno de los siguientes, para ubicar automáticamente la leyenda:  "bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right", "center".
* `title`: Para poner título a la leyenda.

Además, tenemos muchos otros argumentos opcionales, que puedes consultar en la documentación  llamando `?legend()`.

Vamos a agregar una leyenda a la última gráfica de barras que creamos en la sección anterior de este capítulo.

Entonces necesitamos conocer las etiquetas que daremos como argumento `legend` y a qué colores corresponden al vector `banco$loan`.

Usamos la función `unique` para determinar cuántos valores únicos hay en este vector. Cada uno de estos valores corresponde a una etiqueta. Esta función, si la aplicamos a un vector de tipo factor, nos devuelve sus niveles.
```{r unique_loan, echo?TRUE}
unique(banco$loan)
```

Tenemos dos etiquetas, "no" y "yes" (no y sí, respectivamente), en ese orden, por lo que ese será nuestro argumento `legend`.

Nosotros determinamos los colores en la sección anterior como "royalblue" y "grey", en ese orden. Por lo tanto, tendremos que "no" será coloreado con "royalblue", y "yes" con "grey". como vamos a rellenar una barra, esto colores los daremos al argumento `fill`.

Por último, daremos como "topright" como argumento `x` para que nuestra leyenda se unique en la parte superior derecha de nuestro gráfico.

Aplicamos todo, incluido generar el gráfico al que agregaremos la leyenda.
```{r leyenda, echo = TRUE}
barplot(ptab_banco,  main = "Préstamos por nivel educativo",
     xlab = "Nivel educativo", ylab = "Proporción", 
     col = c("royalblue", "grey"))
legend(x = "topright", legend = c("No", "Yes"), fill = c("royalblue", "grey"), 
       title = "Loan")
```

Se ve mucho más clara la información, pues ahora estamos mostrando a qué categoría corresponden los colores que hemos empleado en el gráfico.

En las secciones siguientes agregaremos leyendas a otros gráficos, con lo cual quedará un poco más claro el uso de `legend()`.

## Diagramas de dispersión
Este tipo de gráfico es usado para mostrar la relación entre dos variables numéricas continuas, usando puntos. Cada punto representa la intersección entre los valores de ambas variables.

Para generar un diagrama de dispersión, damos vectores numéricos como argumentos `x` y `y` a la función `plot()`.

Veamos la relación entre las variables **age** y **balance** de `banco`.
```{r scatter, echo=TRUE}
plot(x = banco$age, y = banco$balance)
```

Tenemos algunos datos extremos tanto en **balance**. Para fines de tener una gráfica más informativa, vamos a recodificarlos usando `ifelse()`, cambiando todos los valores mayores a 15 000.
```{r recode_banco, echo=TRUE}
banco$balance <- ifelse(banco$balance > 15000, 15000, banco$balance)
```

```{r scatter_recode, echo=TRUE}
plot(x = banco$age, y = banco$balance)
```

En los diagramas de dispersión, podemos usar el argumento `col` para camiar el color de los puntos usando como referencia una tercera variable.

La variable que usaremos será, de nuevo, **loan**
```{r, echo = TRUE}
# plot(x = banco$age, y = banco$balance, col= banco$loan)
```

Nos sería de utilidad una leyenda para interpretar más fácilmente los colores. 

Ya sabemos que los niveles de **loan** son "no" y "yes", además de que los colores han sido rojo y negro, así que agregar una leyenda será relativamente fácil.

```{r legend, echo=TRUE}
#plot(x = banco$age, y = banco$balance, col= banco$loan)
#legend(x = "topleft", legend = c("No", "Yes"), fill = c("Black", "Red"), title = "Loan")
```

Desafortunadamente esta gráfica no es muy informativa para nuestros datos. Por fortuna, podemos probar con un conjunto de datos diferente.

Si usamos diagramas de dispersión con `iris` obtendremos gráficos mucho más interesantes. 

Creamos un gráfico con las medidas de pétalo, aplicando lo que hemos visto para generar diagramas de dispersión.
```{r irisscatter, echo=TRUE}
plot(x = iris$Petal.Length, y = iris$Petal.Width, col = iris$Species, 
     main = "Iris - Pétalo", xlab = "Largo", ylab = "Ancho")
legend(x = "topleft", legend = c("Setosa", "Versicolor", "Virginica"), 
       fill = c("black", "red", "green"), title = "Especie")
```

## Diagramas de caja
Los diagrama de caja, también conocidos como de caja y bigotes son gráficos que muestra la distribución de una variable usando cuartiles, de modo que de manera visual podemos inferir algunas cosas sobre su dispersión, ubicación y simetría.

Una gráfica de este tipo dibuja un rectángulo cruzado por una línea recta horizontal. Esta linea recta representa la mediana, el segundo cuartil, su base representa el primer cuartil y su parte superior el tercer cuartil. Al rango entre el primer y tercer cuartil se le conoce como intercuartílico (RIC). Esta es la caja.

Además, de la caja salen dos líneas. Una que llega hasta el mínimo valor de los datos en la variable o hasta el primer cuartil menos hasta 1.5 veces el RIC; y otra que llegar hasta el valor máximo de los datos o el tercer cuartil más hasta 1.5 veces el RIC. Estos son los bigotes.

Usamos la función `plot()` para crear este tipo de gráfico, dando como argumento `x` un vector de factor o cadena de texto, y como argumento `y` un vector numérico.

Una ventaja de este tipo de gráfico es que podemos comparar las distribución de una misma variable para diferentes grupos.

Vamos a ver cómo se distribuye la edad por nivel de educación en nuestro objeto `banco`, esto es, las variables **education** y  **age**.
```{r boxplot_plot, echo=TRUE}
#plot(x = banco$education, y = banco$age)
```

Podemos ver que las personas con menor nivel educativo tienden a tener una edad mayor. La mayoría de las personas con educación primaria tienen entre 40 y 50 años, mientras que la mayoría con educación terciaria tiene entre 35 y 45 años, aproximadamente.

Por supuesto, podemos cambiar los parámetros gráficos a un diagrama de caja.
```{r boxplot_leyenda, echo=TRUE}
#plot(x = banco$education, y = banco$age, main = "Edad por nivel educativo", 
#     xlab = "Nivel educativo", ylab = "Edad", 
 #    col = c("orange3", "yellow3", "green3", "grey"))
```

También podemos crear diagramas de caja con la función `boxplot()`.  Esta función puede generar diagramas de caja de dos maneras distintas.

En la primera manera, si damos como argumento `x` un vector numérico, nos dará un diagrama de caja de esa variable.
```{r boxplot_x, echo=TRUE}
boxplot(x = banco$age)
```

En la segunda manera necesitamos dar dos argumentos:

* `formula`: Para esta función las fórmulas tienen el formato `y ~ x`, donde x es el nombre de la variable continua a graficar, y la x es la variable que usaremos como agrupación.
* `data`: Es el data frame del que serán tomadas las variables.

Por ejemplo, para mostrar diagramas de caja por nivel educativo, nuestra variable y es **age** y nuestra variable x es **education**, por lo tanto, `formula` será `age ~ education`.
```{r boxplot_formula, echo=TRUE}
boxplot(formula = age ~ education, data =  banco)
```


## Gráficos de mosaico
Los gráficos de mosaico o diagramas de Marimekko son usados para mostrar la relación entre dos variables discretas, ya sean factores o cadenas de texto.

Este tipo de gráfico recibe su nombre porque consiste en una cuadricula, en la que cada rectángulo representa el numero de casos que corresponden a un cruce específico de variables. Entre más casos se encuentren en ese cruce, más grande será el rectángulo.

Para obtener un gráfico de mosaico, damos como vectores de factor o cadena de texto como argumentos `x` y `y` a la función `plot()`.

Por ejemplo, intentemos graficar el estado marital con el nivel educativo de las personas en `banco`
```{r mosaico, echo =TRUE}
#plot(x = banco$marital, y = banco$education)
```

Podemos cambiar el color de los mosaicos con el argumento `col`. Debemos proporcionar un color por cada nivel del vector en el eje Y.
```{r mosaico_color, echo =TRUE}
#plot(x = banco$marital, y = banco$education, 
 #    col = c("#99cc99", "#cc9999", "#9999cc", "#9c9c9c"))
```

De esta manera es más claro que el grupo más numeroso de personas son las casadas con educación secundaria y el más pequeño, divorciadas con educación primaria.

## Exportar gráficos
Exportar los gráficos que hemos creado es un proceso que puede parecer un poco confuso.

Cuando llamamos una de estas funciones, le estamos indicando a R que "mande" nuestro gráfico a un **dispositivo gráfico** (*graphic device*) en nuestra computadora, donde podemos verlo, que por defecto es **una ventana en nuestro escritorio** o el panel **Plot** si estás usando *RStudio*.

Una consecuencia de esto es que si creas y lo mandas a un dispositivo gráfico en uso, el gráfico nuevo reemplazará al anterior. Por ejemplo, si usas `plot()` para crear un gráfico, se mostrará en una ventana de tu escritorio, pero si usas `plot()` de generar un gráfico distinto, el contenido de esta ventana será reemplazada con este nuevo gráfico. Lo mismo pasa con todos los dispositivos gráficos.

Además, los gráficos no pueden ser guardados en un objetos para después ser exportados. Es necesario mandar nuestros gráficos a un dispositivo como JPG, PNG o algún otro tipo de archivo que pueda ser almacenado en nuestro disco duro.

Para exportar un gráfico usamos alguna de las siguientes funciones, cada una corresponde con un tipo de archivo distinto. No son las únicas, pero son las más usadas. 

* `bpm()`
* `jpeg()`
* `pdf()`
* `png()`
* `tiff()`

Cada una de estas funciones tiene los siguientes argumentos tres argumentos principales.

* `filename`: El nombre y ruta del archivo de imagen a crear. Si no especificamos una ruta completa, entonces el el archivo será creado en nuestro directorio de trabajo.
* `width`: El **ancho** del archivo de imagen a crear, por defecto en pixeles.
* `height`: El **alto** del archivo de imagen a crear, por defecto en pixeles.

La manera de utilizar estas funciones llamándolas **antes** de llamar a una función que genere una gráfica. Al hacer esto, le indicamos a R que en lugar de mandar nuestro gráfico a una ventana del escritorio, lo mande a un dispositivo gráfico distinto.

Finalmente, llamamos a la función `dev.off()`, para cerrar el dispositivo gráfico que hemos elegido, de este modo se creará un archivo y podremos crear más gráficos después.

Por ejemplo, para exportar un gráfico con leyenda como un archivo PNG llamamos lo siguiente. Nota que tenemos que dar la misma extensión de archivo que la función que estamos llamando, en este caso **.png**.
```{r crear_png, echo=TRUE}
#png(filename = "loan_age.png", width = 800, height = 600)
#plot(x = banco$age, y = banco$duration, col = banco$loan, 
 #    main = "Edad y Duración", xlab = "Edad", ylab = "Duración")
#legend(x = "top", legend = c("No", "Yes"), fill = c("Black", "Red"), 
 #      title = "Loan")
#dev.off()
```

Si aparece un mensaje como el siguiente, es que hemos tenido éxito.

>null device 
          1 

Podemos ver el resultado usando `file.show()`.
```{r, echo=TRUE, eval=FALSE}
file.show("loan_age.png")
```

De esta manera podemos exportar cualquier tipo de gráfico generado con R.

<!--chapter:end:12-graficas.Rmd-->

# Conclusión
Al haber concluido este libro tendrás las herramientas básicas para utilizar R como un lenguaje de programación. Desde los conceptos más básicos, hasta la definición de funciones para exportar gráficos.

Lo que hemos visto en este libro te será de utilidad sin importar el uso de R que tengas previsto, pues son conceptos fundamentales que te permitirán acceder a otros más complejos y avanzado.

El siguiente paso es aplicar lo que hemos revisado hasta este momento, ya sea en algún proyecto propio o para aprender más sobre R y sus aplicaciones.

En caso de que desees profundizar más sobre el uso de R, la siguiente sección te presenta una selección de materiales de referencia que te facilitarán continuar con tu aprendizaje, dependiendo de tus intereses personales.

Todas las referencias incluyen un enlace para que las consultes en línea, sin costo y legalmente.

¡Suerte!

**Material de referencia**

Probabilidad y estadística (introductorio a medio)

*	Diez, D., Barr, C., Çetinkaya-Rundel, M. (2015). *OpenIntro Statistics*, segunda edición. OpenIntro.
  https://www.openintro.org/stat/textbook.php?stat_book=os 
*	Navarro, D. (2015). *Learning statistics with R: A tutorial for psychology students and other beginners*. University of Adelaide.
http://www.fon.hum.uva.nl/paul/lot2015/Navarro2014.pdf 


R aplicado a *Data Science* (medio a avanzado)

* Peng, R. D. (2016). *R Programming for Data Science*. Leanpub.  https://leanpub.com/rprogramming  
* Wickham. H. y Grolemund, G. (2017). *R for Data Science*. O’Reilly.   http://r4ds.had.co.nz/


Programación con R (avanzado)

*	Wickham, H. (2014). *Tidy Data*. Journal of Statistical Software. https://www.jstatsoft.org/article/view/v059i10/v59i10.pdf 
*	Wickham, H. (2014). *Advanced R*. O’Reilly. http://adv-r.had.co.nz/ 


Referencias sobre RStudio

*	*RStudio Cheat Sheets*.
  https://www.rstudio.com/resources/cheatsheets/

<!--chapter:end:13-conclusion.Rmd-->

