[["index.html", "R Grupo de estudios económicos Prefacio", " R Grupo de estudios económicos Jeshua Romero Guadarrama, Kevin Fernández, Apocryfo, Jenn, Daniel, Tifany Jiménez, Ernesto, Ezequiel, Rich Conejo, Angiebaram, Jesmarth, Adolfo Robles, Isaac Flores, Abdeel, Roberto Daniel 2021-08-07 Prefacio Publicado por Jeshua Romero Guadarrama en colaboración con JeshuaNomics: Git Hub Facebook Twitter Linkedin Vkontakte Tumblr YouTube Instagram Jeshua Romero Guadarrama es economista y actuario por la Universidad Nacional Autónoma de México, quien ha construido el presente proyecto en colaboración con JeshuaNomics, ubicado en la Ciudad de México, se puede contactar mediante el siguiente correo electrónico: jeshuanomics@gmail.com. Última actualización el sábado 07 del 08 de 2021 Los estudiantes con poca experiencia en el análisis avanzado de estadísticas a menudo tienen dificultades para entender los beneficios de desarrollar habilidades de programación al momento de aplicar diversos métodos descriptivos e inferenciales. Análisis estadístico con R para principiantes por Jeshua Romero Guadarrama (2021), ofrece una introducción interactiva a los aspectos esenciales de la programación por medio del lenguaje y software estadístico R, así como una guía para la aplicación de la teoría económica y econométrica en entornos específicos. En otras palabras, el objetivo es que los estudiantes se adentren al mundo de la economía aplicada mediante ejemplos empíricos presentados en la vida diaria y haciendo uso de las habilidades de programación recién adquiridas. Dicho objetivo se encuentra respaldado por ejercicios de programación interactivos y la incorporación de visualizaciones dinámicas de conceptos fundamentales mediante la flexibilidad de JavaScript, a través de la biblioteca D3.js. En los últimos años, el lenguaje de programación estadística R se ha convertido en una parte integral del plan de estudios de las clases de estadística que se imparten en las universidades. Regularmente una gran parte de los estudiantes no han estado expuestos a ningún lenguaje de programación antes y, por lo tanto, tienen dificultades para participar en el aprendizaje de R por sí mismos. Con poca experiencia en el análisis avanzado de estadísticas, es natural que los novicios tengan dificultades para comprender los beneficios de desarrollar habilidades en R para aprender y aplicar la estadística. Estos incluyen particularmente la capacidad de realizar, documentar y comunicar estudios empíricos y tener las facilidades para programar estudios de simulación, lo cual es útil para, por ejemplo, comprender y validar teoremas que generalmente no se asimilan o entienden fácilmente con el estudio de las fórmulas. Al ser un economistas aplicado y econometrista, me gustaría que mis colegas desarrollen capacidades de gran valor; en consecuencia, deseo compartir con las nuevas generaciones de economistas mis conocimientos. En lugar de confrontar a los estudiantes con ejercicios de codificación puros y literatura clásica complementaria, he pensado que sería mejor proporcionar material de aprendizaje interactivo que combine el código en R con el contenido del curso de texto Introducción a la Econometría de (stock2015?) que sirve de base para el presente material. El presente trabajo es un complemento empírico interactivo al estilo de un informe de investigación reproducible que permite a los estudiantes no solo aprender cómo los resultados de los estudios de casos se pueden replicar con R, sino que también fortalece su capacidad para utilizar las habilidades recién adquiridas en otras aplicaciones empíricas. Las convenciones usadas en el presente curso El texto en cursiva indica nuevos términos, nombres, botones y similares. El texto en negrita se usa generalmente en párrafos para referirse al código R. Esto incluye comandos, variables, funciones, tipos de datos, bases de datos y nombres de archivos. Texto de ancho constante sobre fondo gris indica un código R que usted puede escribir literalmente. Puede aparecer en párrafos para una mejor distinción entre declaraciones de código ejecutables y no ejecutables, pero se encontrará principalmente en forma de grandes bloques de código R. Estos bloques se denominan fragmentos de código. Reconocimiento A mi alma máter: Universidad Nacional Autónoma de México (Facultad de Economía y Facultad de Ciencias). Por brindarme valiosas oportunidades que coadyuvaron a mi formación. Esta obra está autorizado bajo la Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["contenido.html", "Contenido", " Contenido Introducción Sobre este curso Similitud con este curso Otro para principiantes Lo que puede omitir con seguridad Supuestos tontos Cómo está organizado este curso Parte I: Introducción al análisis estadístico con R Parte II: Descripción de datos Parte III: Sacar conclusiones a partir de los datos Parte IV: Trabajar con probabilidad Parte V: La parte de diez Apéndice A en línea: Más sobre probabilidad Apéndice B en línea: Estadísticas no paramétricas Apéndice C en línea: Diez temas que simplemente no encajan en ningún otro capítulo Iconos utilizados en este curso A dónde ir desde aquí "],["índice-de-contenido.html", "Índice de contenido", " Índice de contenido Parte I: Introducción al análisis estadístico con R Datos, estadísticas y decisiones Las nociones estadísticas (y relacionadas) que solo debe conocer Muestras y poblaciones Variables: dependientes e independientes Tipos de datos Un poco de probabilidad Estadística inferencial: probando hipótesis Hipótesis nulas y alternativas Dos tipos de error R: Qué hace y cómo lo hace Descargando R y RStudio Una sesión con R El directorio de trabajo Así que comencemos, ya Datos faltantes Funciones R Funciones definidas por el usuario comentarios R Estructuras Vectores Vectores numéricos Matrices Factores Listas Listas y estadísticas Marcos de datos Paquetes Más paquetes R Fórmulas Leyendo y escribiendo Hojas de cálculo Archivos CSV Archivos de texto Parte II: Descripción de datos Obtención de gráficos Encontrar patrones Graficar una distribución Salto de bares Rebanar el pastel La trama de dispersión De cajas y bigotes Gráficos básicos R Histogramas Añadiendo características gráficas Parcelas de barras Gráficos circulares Gráficos de puntos Parcelas de barras revisitadas Diagramas de dispersión Diagramas de caja Graduarse a ggplot2 Histogramas Parcelas de barras Gráficos de puntos Parcelas de barras revisitadas Diagramas de dispersión Diagramas de caja Terminando Encontrar su centro Medios: el atractivo de los promedios El promedio en R: mean() ¿Cuál es tu condición? Eliminar $-signos con with() Explorando los datos Valores atípicos: el defecto de los promedios Otros medios para un fin Medianas: atrapadas en el medio La mediana en R: median() Estadísticas à la Mode El modo en R Desviarse del promedio Medición de la variación Desviaciones cuadradas promedio: varianza y cómo calcularla Varianza de la muestra Varianza en R Regreso a las raíces: desviación estándar Desviación estándar de la población Desviación estándar de la muestra Desviación estándar en R Condiciones, condiciones, condiciones Cumplimiento de estándares y posiciones Atrapando algunas Z Características de las puntuaciones z Bonos versus Bambino Puntajes de exámenes Puntuaciones estándar en R ¿Cuál es tu posición? Clasificación en R Puntuaciones empatadas Nth más pequeño, Nth más grande Percentiles Rangos de porcentaje Resumiendo Resumiendo todo ¿Cuántos? Lo alto y lo bajo Viviendo en los momentos Un momento de enseñanza Volver a descriptivos Asimetría Curtosis Sintonización de la frecuencia Variables nominales: table() et al Variables numéricas: hist() Variables numéricas: stem() Resumiendo un marco de datos ¿Qué es normal? Golpear la curva Profundizando Parámetros de una distribución normal Trabajar con distribuciones normales Distribuciones en R Función de densidad normal Función de densidad acumulativa Cuantiles de distribuciones normales Muestreo aleatorio Un miembro distinguido de la familia Parte III: Sacar conclusiones a partir de los datos El juego de la confianza: estimación Comprensión de las distribuciones de muestreo Una idea EXTREMADAMENTE importante: el teorema del límite central (Aproximadamente) Simulando el teorema del límite central Predicciones del teorema del límite central Confianza: ¡tiene sus límites! Encontrar límites de confianza para una media Encajar en una t Prueba de hipótesis de una muestra Hipótesis, pruebas y errores Pruebas de hipótesis y distribuciones muestrales Coger algo de Z de nuevo Prueba Z en R t para uno t Prueba en R Trabajar con distribuciones t Visualización de distribuciones t Trazado de t en gráficos R base Trazando t en ggplot2 Una cosa más sobre ggplot2 Probando una varianza Pruebas en R Trabajar con distribuciones de chi-cuadrado Visualización de distribuciones de chi-cuadrado Trazado de chi-cuadrado en gráficos R base Trazar chi-cuadrado en ggplot2 Prueba de hipótesis de dos muestras Hipótesis construidas para dos Distribuciones de muestreo revisadas Aplicación del teorema del límite central Z una vez más Prueba Z para dos muestras en R t para dos Como guisantes en una vaina: variaciones iguales Prueba t en R Trabajando con dos vectores Trabajar con un marco de datos y una fórmula Visualizando los resultados Como p y q: varianzas desiguales Un conjunto emparejado: prueba de hipótesis para muestras emparejadas Prueba t de muestras pareadas en R Prueba de dos variaciones Prueba F en R F junto con t Trabajar con distribuciones F Visualización de distribuciones F Prueba de más de dos muestras Probando más de dos Un problema espinoso Una solución Relaciones significativas ANOVA en R Visualizando los resultados Después del ANOVA Contrastes en R Comparaciones no planificadas Otro tipo de hipótesis, otro tipo de prueba Trabajo con ANOVA de medidas repetidas ANOVA de medidas repetidas en R Visualizando los resultados Ponerse de moda Análisis de tendencias en R Pruebas más complicadas Rompiendo las combinaciones Interacciones El análisis ANOVA bidireccional en R Visualización de los resultados bidireccionales Dos tipos de variables. . . En seguida ANOVA mixto en R Visualización de los resultados de ANOVA mixtos Después del análisis Análisis multivariado de varianza MANOVA en R Visualización de los resultados de MANOVA Después del análisis Regresión: modelo lineal, múltiple y lineal general La trama de la dispersión Graficar líneas Regresión: ¡Qué línea! Uso de regresión para pronosticar Variación alrededor de la línea de regresión Prueba de hipótesis sobre regresión Regresión lineal en R Características del modelo lineal Haciendo predicciones Visualización del diagrama de dispersión y la línea de regresión Graficando los residuales Hacer malabares con muchas relaciones a la vez: regresión múltiple Regresión múltiple en R Haciendo predicciones Visualización del diagrama de dispersión 3D y el plano de regresión ANOVA: otra mirada Análisis de covarianza: el componente final del GLM Pero espera, hay más Correlación: el auge y la caída de las relaciones Parcelas de dispersión de nuevo Comprensión de la correlación Correlación y regresión Prueba de hipótesis sobre la correlación ¿Un coeficiente de correlación es mayor que cero? ¿Se diferencian dos coeficientes de correlación? Correlación en R Calcular un coeficiente de correlación Prueba de un coeficiente de correlación Prueba de la diferencia entre dos coeficientes de correlación Calcular una matriz de correlación Visualización de matrices de correlación Correlación múltiple Correlación múltiple en R Ajuste de R-cuadrado Correlación parcial Correlación parcial en R Correlación semiparcial Correlación semiparcial en R Regresión curvilínea: cuando las relaciones se complican ¿Qué es un logaritmo? ¿Qué es e? Regresión de potencia Regresión exponencial Regresión logarítmica Regresión polinomial: un poder superior ¿Qué modelo debería utilizar? Parte IV: Trabajar con probabilidad Introducción a la probabilidad ¿Qué es la probabilidad? Experimentos, ensayos, eventos y espacios de muestra Espacios muestrales y probabilidad Eventos compuestos Unión e intersección Intersección de nuevo La probabilidad condicional Trabajando con las probabilidades La base de la prueba de hipótesis Grandes espacios de muestra Permutaciones Combinaciones R Funciones para contar reglas Variables aleatorias: discretas y continuas Distribuciones de probabilidad y funciones de densidad La distribución binomial El binomio binomial y el binomio negativo en R Distribución binomial Distribución binomial negativa Prueba de hipótesis con la distribución binomial Más sobre pruebas de hipótesis: R versus tradición Introducción al modelado Modelado de una distribución Sumergirse en la distribución de Poisson Modelado con la distribución de Poisson Probando el ajuste del modelo Un comentario sobre chisq.test() Jugando a la pelota con un modelo Una discusión simulada Arriesgarse: el método Monte Carlo Cargando los dados Simulando el teorema del límite central Parte V: La parte de diez Diez consejos para emigrados de Excel Definir un vector en R es como nombrar un rango en Excel Operar en vectores es como operar en rangos con nombre A veces, las funciones estadísticas funcionan de la misma manera Y a veces no Contraste: Excel y R funcionan con diferentes formatos de datos Las funciones de distribución son (algo) similares Un marco de datos es (algo) como un rango con nombre de varias columnas La función sapply() es como arrastrar Usar edit() es (casi) como editar una hoja de cálculo Utilice el portapapeles para importar una tabla de Excel a R Diez valiosos recursos R en línea Sitios web para usuarios R R - blogueros Red de aplicaciones de Microsoft R Rápido - R RStudio Aprendizaje en línea Desbordamiento de pila Libros y documentación en línea R manuales Documentación R RDocumentación USTED PUEDE analizar El diario R "],["1-introducción-qué-es-r-y-para-qué-es-usado.html", "Capítulo 1 Introducción: ¿Qué es R y para qué es usado?", " Capítulo 1 Introducción: ¿Qué es R y para qué es usado? R es un lenguaje de programación y entorno computacional dedicado a la estadística. Decimos que es un lenguaje de programación porque nos permite dar instrucciones, usando código, a nuestros equipos de cómputo para que realicen tareas específicas (además de que es Turing Completo, pero profundizaremos en ello); para ello sólo necesitamos un intérprete para este código y es a esto a lo que llamamos un entorno computacional. Cuando instalamos R en nuestra computadora en realidad lo que estamos instalando es el entorno computacional, y para que podamos hacer algo en ese entorno necesitamos conocer la manera de escribir instrucciones que el software pueda interpretar y ejecutar. Eso es lo que aprenderemos a hacer en este curso. R es diferente a otros lenguajes de programación que por lo general están diseñados para realizar muchas tareas diferentes; esto es porque fue creado con el único propósito de hacer estadística. Esta característica es la razón de que R sea un lenguaje de programación peculiar, que puede resultar absurdo en algunos sentidos para personas con experiencia en otros lenguajes, pero también es la razón por la que R es una herramienta muy poderosa para el trabajo en estadística, puesto que funciona de la manera que una persona especializada en esta disciplina desearía que lo hiciera. Para entender mejor estas peculiaridades, nos conviene conocer un poco de los orígenes de este lenguaje de programación. "],["1-1-un-poco-de-historia.html", "1.1 Un poco de historia", " 1.1 Un poco de historia R tiene sus orígenes en S, un lenguaje de programación creado en los Laboratorios Bell de Estados Unidos. Sí, los mismos laboratorios que inventaron el transistor, el láser, el sistema operativo Unix y algunas otras cosas más. Dado que S y sus estándares son propiedad de los Laboratorios Bell, lo cual restringe su uso, Ross Ihaka y Robert Gentleman, de la Universidad de Auckland en Nueva Zelanda, decidieron crear una implementación abierta y gratuita de S. Este trabajo, que culminaría en la creación de R inició en 1992, teniendo una versión inicial del lenguaje en 1995 y en el 2000 una versión final estable. R hereda muchas características de S, por lo que puedes correr código de este lenguaje usando R sin mayor problema. Para lograr esto, en R frecuentemente existe más de una manera de realizar tareas comunes, una compatible con S y otra diseñada específicamente para R. Lo anterior tiene como resultado inconsistencias, sintaxis poco intuitiva y abundante frustración de cabeza para las personas que quieren aprender R. En el presente, el mantenimiento y desarrollo de R es realizado por el R Development Core Team, un equipo de especialistas en ciencias computacionales y estadística provenientes de diferentes instituciones y lugares alrededor del mundo. La versión de R mantenida por este equipo es conocida como base y como su nombre indica, es sobre aquella que se crean otras implementaciones de R así como los paquetes que expanden su funcionalidad. Para lograr que R sea usado sin restricciones es distribuido de manera gratuita, a través de la Licencia Pública General de GNU, por lo que es software libre y de código abierto. Si lo deseas, puedes examinar y estudiar el código que hace que R funcione o puedes crear versiones propias de R que se ajusten a tus necesidades particulares. Esta licencia también te permite usar R para los fines que desees, sin limitaciones, no importando si personales, académicos o comerciales. En la actualidad, el desarrollo de este lenguaje de programación se mantiene activa. La versión más reciente de R al momento de escribir este documento es la 3.4.2 Short Summer fue publicada en septiembre del 2017 y diariamente son publicados nuevos paquetes y sus respectivas actualizaciones. "],["1-2-quién-usa-r.html", "1.2 ¿Quién usa R?", " 1.2 ¿Quién usa R? R es un lenguaje relativamente joven pero que ha experimentado un crecimiento acelerado en su adopción durante los últimos 10 años. En septiembre de 2017, de acuerdo al TIOBE programming community index (2017), que es uno de los índices de más prestigio en el mundo en relación popularidad en el uso de lenguajes de programación, R era el lenguaje número 11 en popularidad, después de haber sido el lenguaje número 18 en el 2016. Esto es sobresaliente si consideramos que R es un lenguaje dedicado únicamente a la estadística, mientras que lenguajes como Python (número 5 en 2017) o Java (número 1) son lenguajes que pueden ser usados para todo tipo de tareas, desde crear sitios web hasta programar robots. La adopción de R se debe en gran medida a que permite responder preguntas mediante el uso de datos de forma efectiva, y como es un lenguaje abierto y gratuito, se facilita compartir código, crear herramientas para solucionar problemas comunes y que todo tipo de personas interesadas en análisis estadísticos puedan participar y contribuir al desarrollo y uso de R, no sólo aquellas que tengan acceso a licencias de software cerrado. Incluso compañías e instituciones que no tendrían ninguna dificultad para financiar el costo de licencias de software cerrado utilizan R. R, por citar un ejemplo, es usado por Facebook para analizar la manera en que sus usuarios interactúan con sus muros de publicaciones para así determinar qué contenido mostrarles. Esta es una tarea muy importante en Facebook, pues las interacciones de los usuarios con publicidad y contenido pagado son la principal fuente de ingreso de esta compañía. Además de que su división de recursos humanos emplea esta herramienta para estudiar las interacciones entre sus trabajadores. Google usa R para analizar la efectividad las campañas de publicidad implementadas en sus servicios, por ejemplo, los anuncios pagados que te aparecen cuando googleas algo. Nuevamente, esta es la principal fuente de ingresos de esta compañía. R También es usado para hacer predicciones económicas y otras actividades. Microsoft adquirió y ahora desarrolla una versión propia de R llamada OpenR, que ha hecho disponible para uso general del público. OpenR es empleada para realizar todo tipo de análisis estadísticos, por ejemplo, para empatar a jugadores en la plataforma de videojuegos XBOX Live (así que puedes culpar a R cuando te tocan partidas contra jugadores mucho más hábiles que tú). Otras compañías que usan R de modo cotidiano son American Express, IBM, Ford, Citibank, HP y Roche, entre muchas más (Bhalla, 2016; Level, 2017; Microsoft, 2014). Lo anterior ilustra algunas de las aplicaciones específicas de este lenguaje y de manera general podemos decir que R es usado para procesar, analizar, modelar y comunicar datos. Aunque R está diseñado para análisis estadístico, con el paso del tiempo los usuarios de este lenguaje han creado extensiones a R, llamadas paquetes, que han ampliado su funcionalidad. En la actualidad es posible realizar en R minería de textos, procesamiento de imagen, visualizaciones interactivas de datos y procesamiento de Big Data, entre muchas otras cosas. Así que, empecemos a usar R. Referencias Level (2017). How Big Companies Are Using R for Data Analysis. Recuperado en septiembre de 2017 de: http://www.northeastern.edu/levelblog/2017/05/31/big-companies-using-r-data-analysis/ Microsoft (2014). Companies using R in 2014. Recuperado en septiembre de 2017 de: http://blog.revolutionanalytics.com/2014/05/companies-using-r-in-2014.html Bhalla, D. (2016) Companies using R. Recuperado en septiembre de 2017 de: http://www.listendata.com/2016/12/companies-using-r.html R FAQ. Recuperado en Septiembre de 2017 de: https://cran.r-project.org/doc/FAQ/R-FAQ.html#What-is-R_003f TIOBE Index for September 2017. Recuperado en Septiembre de 2017 de: https://www.tiobe.com/tiobe-index/ Adesanya, T. (2017). A Gentler Introduction to Programming. Recuperado en Septiembre de 2017 de: https://medium.freecodecamp.org/a-gentler-introduction-to-programming-707453a79ee8 "],["2-instalación.html", "Capítulo 2 Instalación", " Capítulo 2 Instalación La manera de instalar R cambia dependiendo del sistema operativo utilices pero todas tienen en común el uso de CRAN. CRAN es el The Comprehensive R Archive Network, una red en la que se archivan todas las versiones de R base, así como todos los paquetes para R que han pasado por un proceso de revisión riguroso, realizado por el CRAN Team, que se encarga de asegurar su correcto funcionamiento. CRAN es una red porque existen copias de su contenido en diferentes servidores alrededor del mundo, los cuales se actualizan diariamente. De este modo, no importa de qué servidor de CRAN descargues R o algún paquete, lo que vas a obtener será la versión más reciente de ese recurso, que es igual a la disponible en todos los demás servidores. Como veremos más adelante, cuando descargamos un paquete de R, lo estamos haciendo desde CRAN, a menos que indiquemos otra cosa. El sitio oficial de CRAN, en el que encontrarás más información sobre este repositorio es el siguiente: https://cran.r-project.org/ "],["2-1-windows.html", "2.1 Windows", " 2.1 Windows Para instalar R en Windows, la forma más simple es descargar la versión más reciente de R base desde el siguiente enlace de CRAN: https://cran.r-project.org/bin/windows/base/ El archivo que necesitamos tiene la extensión .exe (por ejemplo R-3.5.1-win.exe). Una vez descargado, lo ejecutamos como cualquier instalable. Después de la instalación, estamos listos para usar R. "],["2-2-osx.html", "2.2 OSX", " 2.2 OSX Para instalar R en OSX, se sigue un procedimiento similar que en Windows. Necesitamos descargar los archivos binarios de R base desde CRAN y ejecutarlos. https://cran.r-project.org/bin/macosx/ Al concluir la instalación, podremos usar R, incluso llamándolo directamente desde la consola. "],["2-3-linux.html", "2.3 Linux", " 2.3 Linux En Linux, como suele ser el caso para casi todo, hay una manera fácil y una difícil de instalar R. La manera fácil depende de la presencia de R en los repositorios de la distribución de Linux que estés usando. Si R se encuentra en los repositorios de tu distribución, sólo es necesario usar el gestor de paquetes de tu preferencia para instalarlo, como cualquier otro software. Si R no se encuentra en los repositorios, debes agregar una entrada a tu lista de fuentes de software. Esta entrada depende de tu distribución. También tienes la opción de puedes compilar R directamente desde archivos fuente. Para todas las opciones anteriores, los detalles de instalación se se encuentran en el siguiente enlace: https://cran.r-project.org/bin/linux/ Si estás usando Linux no te debería ser difícil seguir las instrucciones presentadas. "],["2-4-rstudio-un-ide-para-r.html", "2.4 RStudio - un IDE para R", " 2.4 RStudio - un IDE para R Aunque podemos usar R directamente, es recomendable instalar y usar un entorno integrado de desarrollo (IDE, por sus siglas en inglés). Podemos utilizar R ejecutando nuestro código directamente desde documentos de texto plano, pero esta es una manera poco efectiva de trabajar, especialmente en proyectos complejos. Un IDE nos proporciona herramientas para escribir y revisar nuestro código, administrar los archivos que estamos usando, gestionar nuestro entorno de trabajo y algunas otras herramientas de productividad. Tareas que serían difíciles o tediosas de realizar de otro modo, son fáciles a través de un IDE. Hay varias opciones de IDE para R, y entre ellas mi preferido es RStudio. Este entorno, además de incorporar las funciones esenciales de una IDE, es desarrollado por un equipo que ha contribuido de manera significativa para lograr que R sea lenguaje de programación más accesible, con un énfasis en la colaboración y la reproducción de los análisis. Para instalar RStudio, es necesario con descargar y ejecutar alguno de los instaladores disponibles en su sitio oficial. Están disponibles versiones para Windows, OSX y Linux. https://www.rstudio.com/products/rstudio/download/ Si ya hemos instalado R en nuestro equipo, RStudio lo detectará automáticamente y podremos utilizarlo desde este entorno. Si no instalamos RStudio antes que R, no hay problema, cada vez que iniciamos este programa, verificará la instalación de R. "],["3-conceptos-básicos.html", "Capítulo 3 Conceptos básicos", " Capítulo 3 Conceptos básicos Para trabajar con R es necesario conocer un poco del vocabulario usado en en este lenguaje de programación. Los siguientes son conceptos básicos que usaremos a lo largo de todo el libro. "],["3-1-la-consola-de-r.html", "3.1 La consola de R", " 3.1 La consola de R Lo primero que nos encontramos al ejecutar R es una pantalla que nos muestra la versión de este lenguaje que estamos ejecutando y un prompt: &gt;_ Esta es la consola de R y corresponde al entorno computacional de este lenguaje. Es aquí donde nuestro código es interpretado. Podemos escribir código directamente en la consola y R nos dará el resultado de lo pidamos allí mismo. Esta es la razón por la que se dice que R permite el uso interactivo, pues no es necesario compilar nuestro código para ver sus resultados. Si estás usando RStudio, te encontrarás la consola de R en uno de los paneles de este programa. "],["3-2-ejecutar-llamar-correr-y-devolver.html", "3.2 Ejecutar, llamar, correr y devolver", " 3.2 Ejecutar, llamar, correr y devolver Cuando hablamos de ejecutar, llamar o correr nos referimos a pedir que R realice algo, en otras palabras, estamos dando una instrucción o una entrada. Cuando decimos que R nos devuelve algo, es que ha realizado algo que le hemos pedido, es decir, nos está dando una salida. Por ejemplo, si escribimos los siguiente en la consola lo siguiente y damos Enter, estamos pidiendo que se ejecute esta operación: &gt; 1 + 1 Y nos será devuelto su resultado: [1] 2 "],["3-3-objetos.html", "3.3 Objetos", " 3.3 Objetos En R, todo es un objeto. Todos los datos y estructuras de datos son objetos. Además, todos los objetos tienen un nombre para identificarlos. La explicación de esto es un tanto compleja y se sale del alcance de este libro. Se relaciona con el paradigma de programación orientada a objetos y ese es todo un tema en sí mismo. Lo importante es que recuerdes que al hablar de un objeto, estamos hablando de cualquier cosa que existe en R y que tiene un nombre. "],["3-4-constantes-y-variables.html", "3.4 Constantes y variables", " 3.4 Constantes y variables De manera análoga al uso de estos términos en lenguaje matemático, una constante es un objeto cuyo valor no podemos cambiar, en contraste, una variable es un objeto que puede cambiar de valor. Por ejemplo, en la siguiente expresión, \\(\\pi\\) y 2 son constantes, mientras que a y r son variables. \\(a = \\pi r ^ 2\\) Las constantes y variables en R tienen nombres que nos permiten hacer referencia a ellas en operaciones. Las constantes ya están establecidas por R, mientras que nosotros podemos crear variables, asignándoles valores a nombres. En R usamos &lt;- para hacer asignaciones. De este modo, podemos asignar el valor 3 a la variable radio radio &lt;- 3 Hablaremos sobre asignaciones más adelante, en el capítulo de operadores. Es recomendable que al crear una variable usemos nombres claros, no ambiguos y descriptivos. Esto previene confusión y hace que nuestro código sea más fácil de comprender por otras personas o por nosotros mismos en el futuro. Los nombres de las variables pueden incluir letras, números, puntos y guiones bajos. Deben empezar siempre con una letra o un punto y si empiezan con un punto, a este no le puede seguir un número. Finalmente, cuando te encuentres con un renglón de código que inicia con un gato (hashtag), esto representa un comentario, es código que no se ejecutará, sólo se mostrará. # Este es un comentario "],["3-5-funciones-introducción-básica.html", "3.5 Funciones (introducción básica)", " 3.5 Funciones (introducción básica) Una función es una serie de operaciones a la que les hemos asignados un nombre. Las funciones aceptan argumentos, es decir, especificaciones sobre cómo deben funcionar. Cuando llamamos una función, se realizan las operaciones que contiene, usando los argumentos que hemos establecido. En R reconocemos a una función usando la notación: nombre_de_la_función(). Por ejemplo: mean() quantile() summary() density() c() Al igual que con las variables, se recomienda que los nombres de las funciones sean claros, no ambiguos y descriptivos. Idealmente, el nombre de una función describe lo que hace. De hecho, es probable que adivines qué hacen casi todas funciones de la lista de arriba a partir de su nombre. Aunque estrictamente hablando una función es un objeto, para fines de explicación, en este libro nos referiremos a ambos como si fueran cosas diferentes. Las funciones son un tema que revisamos más adelante. Por el momento, recuerda que una función realiza operaciones y nos pide argumentos para poder llevarlas a cabo. "],["3-6-documentación.html", "3.6 Documentación", " 3.6 Documentación Las funciones de R base y aquellas que forman parte de paquete tienen un archivo de documentación. Este archivo describe qué hace la función, sus argumentos, detalles sobre las operaciones que realiza,los resultados que devuelve y ejemplos de uso. Para obtener la documentación de una función, escribimos el ? antes de su nombre y lo ejecutamos. También podemos usar la función help(), con el nombre de la función. Los dos procedimientos siguientes son equivalentes. ?mean() help(&quot;mean&quot;) Si usas RStudio, la documentación de la función se mostrará en uno de los paneles de este IDE. Si estas usando R directamente, se abrirá una ventana de tu navegador de Internet. También podemos obtener la documentación de un paquete, si damos el argumento package a la función help(), con el nombre de un paquete. Por ejemplo, la documentación del paquete stats, instalado por defecto en R base. help(package = &quot;stats&quot;) "],["3-7-directorio-de-trabajo.html", "3.7 Directorio de trabajo", " 3.7 Directorio de trabajo El directorio o carpeta de trabajo es el lugar en nuestra computadora en el que se encuentran los archivos con los que estamos trabajando en R. Este es el lugar donde R buscara archivos para importarlos y al que serán exportados, a menos que indiquemos otra cosa. Puedes encontrar cuál es tu directorio de trabajo con la función getwd(). Sólo tienes que escribir la función en la consola y ejecutarla. getwd() #&gt; [1] &quot;D:/# Libros/# Libros-GitHub/R_grupo_de_estudios_economicos&quot; Se mostrará en la consola la ruta del directorio que está usando R. Puedes cambiar el directorio de trabajo usando la función setwd(), dando como argumento la ruta del directorio que quieres usar. setwd(&quot;C:\\otro_directorio&quot;) Por último, si deseas conocer el contenido de tu directorio de trabajo, puedes ejecutar. la función list.files(), sin argumentos, que devolverá una lista con el nombre de los archivos de tu directorio de trabajo. La función list.dirs(), también sin argumentos` te dará una lista de los directorios dentro del directorio de trabajo. # Ver archivos list.files() # Ver directorios list.dirs() 3.7.1 Sesión Los objetos y funciones de R son almacenados en la memoria RAM de nuestra computadora. Cuando ejecutamos R, ya sea directamente o a través de RStudio, estamos creando una instancia del entorno del entorno computacional de este lenguaje de programación. cada instancia es una sesión. Todos los objetos y funciones creadas en una sesión, permanecen sólo en ella, no son compartidos entre sesiones, sin embargo una sesión puede tener el mismo directorio de trabajo que otra sesión. Es posible tener más de una sesión de R activa en la misma computadora. Aunque ambas Cuando cerramos R, también cerramos nuestra sesión. Se nos preguntará si deseamos guardar el contenido de nuestra sesión para poder volver a ella después. Esto se guarda en un archivo con extensión **.Rdata* en tu directorio de trabajo. Para conocer los objetos y funciones que contiene nuestra sesión, usamos la función ls(), que nos devolverá una lista con los nombres de todo lo guardado en la sesión. ls() #&gt; [1] &quot;escape_latex&quot; &quot;my_output&quot; &quot;radio&quot; #&gt; [4] &quot;sf&quot; &quot;stargazer_html_title&quot; &quot;ttcode&quot; #&gt; [7] &quot;write_html&quot; De manera más precisa, nuestra sesión es un entorno de trabajo y los objetos pertenecen a un entorno específico. Los entornos son un concepto importante al hablar de lenguajes de programación, pero también son un tema que sale del alcance de este libro. Con que recuerdes que cada sesión de R tiene su propio entorno global, eso será suficiente. "],["3-8-paquetes.html", "3.8 Paquetes", " 3.8 Paquetes R puede ser expandido con paquetes. Cada paquete es una colección de funciones diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, minería de datos, interacción con servicios de Internet y muchas otras cosas más. Estos paquetes se encuentran alojados en CRAN, así que pasan por un control riguroso antes de estar disponibles para su uso generalizado. Podemos instalar paquetes usando la función install.packages(), dando como argumento el nombre del paquete que deseamos instalar, entre comillas. Por ejemplo, para instalar el paquete readr, corremos lo siguiente. install.packages(&quot;readr&quot;) Hecho esto, aparecerán algunos mensajes en la consola mostrando el avance de la instalación Una vez concluida la instalación de un paquete, podrás usar sus funciones con la función library(). Sólo tienes que llamar esta función usando como argumento el nombre del paquete que quieres utilizar library(readr) Cuando haces esto, R importa las funciones contenidas en el paquete al entorno de trabajo actual. Es importante que tengas en mente que debes hacer una llamada a library() cada que inicies una sesión en R. Aunque hayas importado las funciones de un paquete con anterioridad, las sesiones de R se inician limpias, sólo con los objetos y funciones de base. Este comportamiento es para evitar problemas de compatibilidad y para propiciar buenas prácticas de colaboración. Si importamos paquetes automáticamente y usamos sus funciones sin indicar de donde provienen, al compartir nuestro código con otras personas, estas no tendrán la información completa para entender qué estamos haciendo. R, al pedirnos que cada sesión indiquemos qué estamos importando, nos obliga a ser explícito con todo lo que estamos haciendo. Es un poco latoso, pero te acostumbras a ello. En caso de escribir en install.packages() el nombre de un paquete no disponible en CRAN, se nos mostrará una advertencia y no se instalará nada. install.packages(&quot;un_paquete_falso&quot;) Los paquetes que hemos importado en nuestra sesión actual aparecen al llamar sessionInfo(). También podemos ver qué paquetes tenemos ya instalados ejecutando la función installed.packages() sin ningún argumento. Una instalación nueva de R tiene pocos paquetes instalados, pero esta lista puede crecer considerablemente con el tiempo. "],["3-9-scripts.html", "3.9 Scripts", " 3.9 Scripts Los scripts son documentos de texto con la extensión de archivo .R, por ejemplo mi_script.R. Estos archivos son iguales a cualquier documentos de texto, pero R los puede leer y ejecutar el código que contienen. Aunque R permite el uso interactivo, es recomendable que guardes tu código en un archivo .R, de esta manera puedes usarlo después y compartirlo con otras personas. En realidad, en proyectos complejos, es posible que sean necesarios múltiples scripts para distintos fines. Podemos abrir y ejecutar scripts en R usando la función source(), dándole como argumento la ruta del archivo .R en nuestra computadora, entre comillas. Por ejemplo. source(&quot;C:/Mis scripts/mi_script.R&quot;) Cuando usamos RStudio y abrimos un script con extensión .R, este programa nos abre un panel en el cual podemos ver su contenido. De este modo podemos ejecutar todo el código que contiene o sólo partes de él. "],["4-tipos-de-datos.html", "Capítulo 4 Tipos de datos", " Capítulo 4 Tipos de datos En R los datos pueden ser de diferentes tipos. Cada tipo tiene características particulares que lo distinguen de los demás. Entre otras cosas algunas operaciones sólo pueden realizarse con tipos de datos específicos En este capítulo revisaremos los tipos de datos más comunes en R y sus propiedades, así como la coerción entre tipos de dato. "],["4-1-datos-más-comunes.html", "4.1 Datos más comunes", " 4.1 Datos más comunes Los tipos de datos de uso más común en R son los siguientes. Tipo Ejemplo Nombre en inglés Entero 1 integer Numérico 1.3 numeric Cadena de texto uno character Factor uno factor Lógico TRUE logical Perdido NA NA Vacío NULL null Además de estos tipos, en R también contamos con datos complejos numéricos complejos (con una parte real y una imaginaria), raw (bytes), fechas y raster, entre otros. Estos tipos tiene aplicaciones muy específicas, por ejemplo, los datos de tipo fecha son ampliamente usados en economía, para análisis de series de tiempo. Revisemos las principales características de estos tipos de dato. "],["4-2-entero-y-numérico.html", "4.2 Entero y numérico", " 4.2 Entero y numérico Como su nombre lo indica, los datos enteros representan números enteros, sin una parte decimal o fraccionaria, que pueden ser usados en operaciones matemáticas. Por su parte, como su nombre lo indica, los datos numéricos representan números, la diferencia de estos con los datos enteros es que tiene una parte decimal o fraccionaria. Los datos numéricos también son llamados doble o float (flotantes). Este nombre se debe a que, en realidad, son números de doble precisión, pues tienen una parte entera y una fraccionaria decimal, y son llamados float debido a que se usa un punto flotante para su representación computacional. Para fines prácticos, estos términos son sinónimos. En este libro, siempre que hablemos de datos numéricos, nos referimos a este tipo. "],["4-3-cadena-de-texto.html", "4.3 Cadena de texto", " 4.3 Cadena de texto El tipo character representa texto y es fácil reconocerlo porque un dato siempre esta rodeado de comillas, simples o dobles. De manera convencional, nos referimos a este tipo de datos como cadenas de texto, es decir, secuencias de caracteres. Este es el tipo de datos más flexible de R, pues una cadena de texto puede contener letras, números, espacios, signos de puntuación y símbolos especiales. "],["4-4-factor.html", "4.4 Factor", " 4.4 Factor Un factor es un tipo de datos específico a R. Puede ser descrito como un dato numérico representado por una etiqueta. Supongamos que tenemos un conjunto de datos que representan el sexo de personas encuestadas por teléfono, pero estos se encuentran capturados con los números 1 y 2. El número 1 corresponde a femenino y el 2 a masculino. En R, podemos indicar que se nos muestre, en la consola y para otros análisis, los 1 como femenino y los 2 como masculino. Aunque para nuestra computadora, femenino tiene un valor de 1, pero a nosotros se nos muestra la palabra femenino. De esta manera reducimos el espacio de almacenamiento necesario para nuestros datos. Este comportamiento es similar a lo que ocurre con paquetes estadísticos comerciales como SPSS Statistics, en los que podemos asignar etiquetas a los datos, dependiendo de su valor. La diferencia se encuentra en que R trata a los factores de manera diferente a un dato numérico. Por último, cada una de las etiquetas o valores que puedes asumir un factor se conoce como nivel. En nuestro ejemplo con femenino y masculino, tendríamos dos niveles. "],["4-5-lógico.html", "4.5 Lógico", " 4.5 Lógico Los datos de tipo lógico sólo tienen dos valores posibles: verdadero (TRUE) y falso (FALSE). Representan si una condición o estado se cumple, es verdadero, o no, es falso. Este tipo de dato es, generalmente, el resultado de operaciones relacionales y lógicas, son esenciales para trabajar con álgebra Booleana, lo cual revisaremos en el (capítulo 5)(#-operadores). Como este tipo de dato sólo admite dos valores específicos, es el más restrictivo de R. "],["4-6-na-y-null.html", "4.6 NA y NULL", " 4.6 NA y NULL En R, usamos NA para representar datos perdidos, mientras que NULL representa la ausencia de datos. La diferencia entre las dos es que un dato NULL aparece sólo cuando R intenta recuperar un dato y no encuentra nada, mientras que NA es usado para representar de modo explícito datos perdidos, omitidos o que por alguna razón son faltantes. Por ejemplo, si tratamos de recuperar la edad de una persona encuestada que no existe, obtendríamos un NULL, pues no hay ningún dato que corresponda con ello. En cambio, si tratamos de recuperar su estado civil, y la persona encuestada no contestó esta pregunta, obtendríamos un NA. NA además puede aparecer como resultado de una operación realizada, pero no tuvo éxito en su ejecución. "],["4-7-coerción.html", "4.7 Coerción", " 4.7 Coerción En R, los datos pueden ser coercionados, es decir, forzados, para transformarlos de un tipo a otro. La coerción es muy importante. Cuando pedimos a R ejecutar una operación, intentará coercionar de manera implícita, sin avisarnos, los datos de su tipo original al tipo correcto que la permita realizar. Habrá ocasiones en las que R tenga éxito y la operación ocurra sin problemas, y otras en las que falle y obtengamos un error. Lo anterior ocurre porque no todos los tipos de datos pueden ser transformados a los demás, para ello se sigue una regla general. La coerción de tipos se realiza de los tipos de datos más restrictivos a los más flexibles. Las coerciones ocurren en el siguiente orden. lógico -&gt; entero -&gt; numérico -&gt; cadena de texto (logical -&gt; integer -&gt; numeric -&gt; character) Las coerciones no pueden ocurrir en orden inverso. Podemos coercionar un dato de tipo entero a uno numérico, pero uno de cadena de texto a numérico. Como los datos de tipo lógico sólo admiten dos valores (TRUE y FALSE), estos son los más restrictivos; mientras que los datos de cadena de texto, al admitir cualquier cantidad y combinación de caracteres, son los más flexibles. Los factores son un caso particular para la coerción. Dado que son valores numéricos con etiquetas, pueden ser coercionados a tipo numérico y cadena de texto; y los datos numéricos y cadena de texto pueden ser coercionados a factor. Sin embargo, al coercionar un factor tipo numérico, perdemos sus niveles. 4.7.1 Coerción explícita con la familia as() También podemos hacer coerciones explícitas usando la familia de funciones as(). Función Tipo al que hace coerción as.integer() Entero as.numeric() Numérico as.character() Cadena de texto as.factor() Factor as.logical() Lógico as.null() NULL Todas estas funciones aceptan como argumento datos o vectores (veremos qué es un vector en el capítulo 6). Cuando estas funciones tienen éxito en la coerción, nos devuelven datos del tipo pedido. Si fallan, obtenemos NA como resultado. Por ejemplo, intentemos convertir el número 5 a una cadena de texto. Para ello usamos la función as.character(). as.character(5) #&gt; [1] &quot;5&quot; Esta es una coerción válida, así que tenemos éxito. Pero, si intentamos convertir la palabra cinco a un dato numérico, obtendremos una advertencia y NA. as.numeric(&quot;cinco&quot;) #&gt; [1] NA Comprobemos el comportamiento especial de los factores. Podemos coercionar al número 5 y la palabra cinco en un factor. as.factor(5) #&gt; [1] 5 #&gt; Levels: 5 as.factor(&quot;cinco&quot;) #&gt; [1] cinco #&gt; Levels: cinco Asignamos la palabra cinco como factor al objeto factor_cinco. factor_cinco &lt;- as.factor(&quot;cinco&quot;) #Resultado factor_cinco #&gt; [1] cinco #&gt; Levels: cinco Ahora podemos coercionar factor_cinco a cadena de texto y a numérico. # Cadena de texto as.character(factor_cinco) #&gt; [1] &quot;cinco&quot; # Numérico as.numeric(factor_cinco) #&gt; [1] 1 Si coercionamos un dato de tipo lógico a numérico, TRUE siempre devolverá 1 y FALSE dará como resultado 0. as.numeric(TRUE) #&gt; [1] 1 as.numeric(FALSE) #&gt; [1] 0 Por último, la función as.null() siempre devuelve NULL, sin importar el tipo de dato que demos como argumento. # Lógico as.null(FALSE) #&gt; NULL # Numérico as.null(457) #&gt; NULL # Cadena de texto as.null(&quot;palabra&quot;) #&gt; NULL "],["4-8-verificar-el-tipo-de-un-dato.html", "4.8 Verificar el tipo de un dato", " 4.8 Verificar el tipo de un dato En ocasiones, tenemos datos pero no sabemos de simple vistazo de qué tipo son. Para esto casos, podemos usar la función class() para determinar el tipo de un dato. Esto es de utilidad para asegurarnos que las operaciones que deseamos realizar tendrán los datos apropiados para llevarse a cabo con éxito. class() recibe como argumento un dato o vector y devuelve el nombre del tipo al que pertenece, en inglés. Por ejemplo, verificamos el tipo de datos que son 3, 3 y TRUE. class(3) #&gt; [1] &quot;numeric&quot; class(&quot;3&quot;) #&gt; [1] &quot;character&quot; class(TRUE) #&gt; [1] &quot;logical&quot; 4.8.1 Verificación con la familia de funciones is() También podemos verificar si un dato es de un tipo específico con la familia de funciones is(). Función Tipo que verifican is.integer() Entero is.numeric() Numérico is.character() Cadena de texto is.factor() Factor is.logical() Lógico is.na() NA is.null() NULL Estas funciones toman como argumento un dato, si este es del tipo que estamos verificando, nos devolverán TRUE y en caso contrario devolverán FALSE. Por ejemplo, verificamos que 5 sea numérico. is.numeric(5) #&gt; [1] TRUE Obtenemos TRUE, pues es verdadero que este es un dato numérico. Verificamos que 5 sea de tipo cadena de texto. is.character(5) #&gt; [1] FALSE El resultado es FALSE, por lo tanto este no es un dato de cadena de texto. Conociendo el tipo de datos con los que estamos trabajando, nos aseguramos de que obtendremos los resultados esperados para las operaciones que estemos realizando. "],["5-operadores.html", "Capítulo 5 Operadores", " Capítulo 5 Operadores Los operadores son los símbolos que le indican a R que debe realizar una tarea. Combinando datos y operadores es que logramos que R haga su trabajo. Existen operadores específicos para cada tipo de tarea. Los tipos de operadores principales son los siguientes: Aritméticos Relacionales Lógicos De asignación Familiarizarnos con los operadores nos permitirá manipular y transformar datos de distintos tipos. "],["5-1-operadores-aritméticos.html", "5.1 Operadores aritméticos", " 5.1 Operadores aritméticos Como su nombre lo indica, este tipo de operador es usado para operaciones aritméticas. En R tenemos los siguientes operadores aritméticos: Operador Operación Ejemplo Resultado + Suma 5 + 3 8 - Resta 5 - 3 2 * Multiplicación 5 * 3 18 / División 5 /3 1.666667 ^ Potencia 5 ^ 3 125 %% División entera 5 %% 3 2 Es posible realizar operaciones aritméticas con datos de tipo entero y numérico. Si escribes una operación aritmética en la consola de R y das Enter, esta se realiza y se devuelve su resultado. 15 * 3 #&gt; [1] 45 Cuando intentas realizar una operación aritmética con otro tipo de dato, R primero intentará coercionar ese dato a uno numérico. Si la coerción tiene éxito se realizará la operación normalmente, si falla, el resultado será un error. Por ejemplo, 4 + \"tres\" devuelve: Error in 4 + \"tres\" : non-numeric argument for binary operator.\" 4 + &quot;tres&quot; #&gt; Error in 4 + &quot;tres&quot;: argumento no-numérico para operador binario El mensaje non-numeric argument for binary operator aparece siempre que intentas realizar una operación aritmética con un argumento no numérico. Si te encuentras un un error que contiene este mensaje, es la primera pista para que identifiques donde ha ocurrido un problema. Cualquier operación aritmética que intentemos con un dato NA, devolverá NA como resultado. NA - 66 #&gt; [1] NA 21 * NA #&gt; [1] NA NA ^ 13 #&gt; [1] NA 5.1.1 La división entera Entre los operadores aritméticos, el de división entera o módulo requiere una explicación adicional sobre su uso. La operación que realiza es una división de un número entre otro, pero en lugar de devolver el cociente, nos devuelve el residuo. Por ejemplo, si hacemos una división entera de 4 entre 2, el resultado será 0. Esta es una división exacta y no tiene residuo. 4 %% 2 #&gt; [1] 0 En cambio, si hacemos una división entera de 5 entre 2, el resultado será 1, pues este es el residuo de la operación. 5 %% 2 #&gt; [1] 1 "],["5-2-operadores-relacionales.html", "5.2 Operadores relacionales", " 5.2 Operadores relacionales Los operadores lógicos son usados para hacer comparaciones y siempre devuelven como resultado TRUE o FALSE (verdadero o falso, respectivamente). Operador Comparación Ejemplo Resultado &lt; Menor que 5 &lt; 3 FALSE &lt;= Menor o igual que 5 &lt;= 3 FALSE &gt; Mayor que 5 &gt; 3 TRUE &gt;= Mayor o igual que 5 &gt;= 3 TRUE == Exactamente igual que 5 == 3 FALSE != No es igual que 5 != 3 TRUE Es posible comparar cualquier tipo de dato sin que resulte en un error. Sin embargo, al usar los operadores &gt;, &gt;=, &lt; y &lt;= con cadenas de texto, estos tienen un comportamiento especial. Por ejemplo, \"casa\" &gt; \"barco\" nos devuelve TRUE. &quot;casa&quot; &gt; &quot;barco&quot; #&gt; [1] TRUE Este resultado se debe a que se ha hecho una comparación por orden alfabético. En este caso, la palabra casa tendría una posición posterior a barco, pues empieza con c y esta letra tiene una posición posterior a la b en el alfabeto. Por lo tanto, es verdadero que sea mayor. Cuando intentamos comparar factores, siempre obtendremos como resultado NA y una advertencia acerca de que estos operadores no son significativos para datos de tipo factor. as.factor(&quot;casa&quot;) &gt; &quot;barco&quot; #&gt; [1] NA "],["5-3-operadores-lógicos.html", "5.3 Operadores lógicos", " 5.3 Operadores lógicos Los operadores lógicos son usados para operaciones de álgebra Booleana, es decir, para describir relaciones lógicas, expresadas como verdadero (TRUE) o falso (FALSO). Operador Comparación Ejemplo Resultado x | y x Ó y es verdadero TRUE | FALSE TRUE x &amp; y x Y y son verdaderos TRUE &amp; FALSE FALSE !x x no es verdadero (negación) !TRUE FALSE isTRUE(x) x es verdadero (afirmación) isTRUE(TRUE) TRUE Los operadores | y &amp; siguen estas reglas: | devuelve TRUE si alguno de los datos es TRUE &amp; solo devuelve TRUE si ambos datos es TRUE | solo devuelve FALSE si ambos datos son FALSE &amp; devuelve FALSE si alguno de los datos es FALSE Estos operadores pueden ser usados con estos con datos de tipo numérico, lógico y complejo. Al igual que con los operadores relacionales, los operadores lógicos siempre devuelven TRUE o FALSE. Para realizar operaciones lógicas, todos los valores numéricos y complejos distintos a 0 son coercionados a TRUE, mientras que 0 siempre es coercionado a FALSE. Por ejemplo, 5 | 0 resulta en TRUE y 5 &amp; FALSE resulta en FALSE. Podemos comprobar lo anterior con la función isTRUE(). 5 | 0 #&gt; [1] TRUE 5 &amp; 0 #&gt; [1] FALSE isTRUE(0) #&gt; [1] FALSE isTRUE(5) #&gt; [1] FALSE Estos operadores se pueden combinar para expresar relaciones complejas. Por ejemplo, la negación FALSE Y FALSE dará como resultado TRUE. !(FALSE | FALSE) #&gt; [1] TRUE También podemos combinar operadores lógicos y relacionales, dado que esto últimos dan como resultado TRUE y FALSE. #&gt; [1] TRUE "],["5-4-operadores-de-asignación.html", "5.4 Operadores de asignación", " 5.4 Operadores de asignación Este es probablemente el operador más importante de todos, pues nos permite asignar datos a variables. Operador Operación &lt;- Asigna un valor a una variable = Asigna un valor a una variable Aunque podemos usar el signo igual para una asignación, a lo largo de este libro utilizaremos &lt;-, por ser característico de R y fácil de reconocer visualmente. Después de realizar la operación de asignación, podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya habíamos asignado datos, nuestra variable conserva el valor más reciente. Además, esta operación nos permite guardar el resultado de operaciones, de modo que los podemos recuperar sin necesidad de realizar las operaciones otra vez. Basta con llamar el nombre de la variable en la consola En este ejemplo, asignamos valores a las variables estatura y peso. estatura &lt;- 1.73 peso &lt;- 83 Llamamos a sus valores asignados estatura #&gt; [1] 1.73 peso #&gt; [1] 83 Usamos los valores asignados para realizar operaciones. peso / estatura ^ 2 #&gt; [1] 27.7323 Cambiamos el valor de una variable a uno nuevo y realizamos operaciones peso &lt;- 76 peso #&gt; [1] 76 peso / estatura ^ 2 #&gt; [1] 25.39343 estatura &lt;- 1.56 peso &lt;- 48 peso / estatura ^ 2 #&gt; [1] 19.72387 Asignamos el resultado de una operación a una variable nueva. bmi &lt;- peso / estatura ^ 2 bmi #&gt; [1] 19.72387 Como podrás ver, es posible asignar a una variable valores de otra variable o el resultado de operaciones con otras variables. velocidad_inicial &lt;- 110 velocidad_final &lt;- 185 tiempo_inicial &lt;- 0 tiempo_final &lt;- 15 variacion_velocidad &lt;- velocidad_final - velocidad_inicial variacion_tiempo &lt;- tiempo_final - tiempo_inicial variacion_velocidad / variacion_tiempo #&gt; [1] 5 "],["5-5-orden-de-operaciones.html", "5.5 Orden de operaciones", " 5.5 Orden de operaciones En R, al igual que en matemáticas, las operaciones tienen un orden de evaluación definido. Cuanto tenemos varias operaciones ocurriendo al mismo tiempo, en realidad, algunas de ellas son realizadas antes que otras y el resultado de ellas dependerá de este orden. El orden de operaciones incluye a las aritméticas, relacionales, lógicas y de asignación. En la tabla siguiente se presenta el orden en que ocurren las operaciones que hemos revisado en este capítulo. Orden Operadores 1 ^ 2 * / 3 + - 4 &lt; &gt; &lt;= &gt;= == != 5 ! 6 &amp; 7 | 8 &lt;- Si deseamos que una operación ocurra antes que otra, rompiendo este orden de evaluación, usamos paréntesis. Podemos tener paréntesis anidados. "],["6-estructuras-de-datos.html", "Capítulo 6 Estructuras de datos", " Capítulo 6 Estructuras de datos Las estructuras de datos son objetos que contienen datos. Cuando trabajamos con R, lo que estamos haciendo es manipular estas estructuras. Las estructuras tienen diferentes características. Entre ellas, las que distinguen a una estructura de otra son su número de dimensiones y si son homogeneas o hereterogeneas. La siguiente tabla muestra las principales estructuras de control que te encontrarás en R. Dimensiones Homogéneas Heterogéneas 1 Vector Lista 2 Matriz Data frame n Array Adaptado de Wickham (2016). Veamos las características de cada una de ellas. "],["6-1-vectores.html", "6.1 Vectores", " 6.1 Vectores Un vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo. Todos los vectores tienen tres propiedades: Tipo. Un vector tiene el mismo tipo que los datos que contiene. Si tenemos un vector que contiene datos de tipo numérico, el vector será también de tipo numérico. Los vectores son atómicos, pues sólo pueden contener datos de un sólo tipo, no es posible mezclar datos de tipos diferentes dentro de ellos. Largo. Es el número de elementos que contiene un vector. El largo es la única dimensión que tiene esta estructura de datos. Atributos. Los vectores pueden tener metadatos de muchos tipos, los cuales describen características de los datos que contienen. Todos ellos son incluidos en esta propiedad. En este libro no se usarán vectores con metadatos, por ser una propiedad con usos van más allá del alcance de este libro. Cuando una estructura únicamente puede contener datos de un sólo tipo, como es el caso de los vectores, decimos que es homogénea, pero no implica que necesariamente sea atómica. Regresaremos sobre esto al hablar de matrices y arrays. Como los vectores son la estructura de datos más sencilla de R, datos simples como el número 3, son en realidad vectores. En este caso, un vector de tipo numérico y largo igual a 1. 3 #&gt; [1] 3 Verificamos que el 3 es un vector con la función is.vector(). is.vector(3) #&gt; [1] TRUE Y usamos la función length() para conocer su largo. length(3) #&gt; [1] 1 Lo mismo ocurre con los demás tipos de datos, por ejemplo, con cadenas de texto y datos lógicos. is.vector(&quot;tres&quot;) #&gt; [1] TRUE is.vector(TRUE) #&gt; [1] TRUE 6.1.1 Creación de vectores Creamos vectores usando la función c() (combinar). Llamamos esta función y le damos como argumento los elementos que deseamos combinar en un vector, separados por comas. # Vector numérico c(1, 2, 3, 5, 8, 13) #&gt; [1] 1 2 3 5 8 13 # Vector de cadena de texto c(&quot;arbol&quot;, &quot;casa&quot;, &quot;persona&quot;) #&gt; [1] &quot;arbol&quot; &quot;casa&quot; &quot;persona&quot; # Vector lógico c(TRUE, TRUE, FALSE, FALSE, TRUE) #&gt; [1] TRUE TRUE FALSE FALSE TRUE Si deseamos agregar un elemento a un vector ya existente, podemos hacerlo combinando nuestro vector original con los elementos nuevos y asignando el resultado a nuestro vector original. mi_vector &lt;- c(TRUE, FALSE, TRUE) mi_vector &lt;- c(mi_vector, FALSE) mi_vector #&gt; [1] TRUE FALSE TRUE FALSE Naturalmente, podemos crear vectores que son combinación de vectores. mi_vector_1 &lt;- c(1, 3, 5) mi_vector_2 &lt;- c(2, 4, 6) mi_vector_3 &lt;- c(mi_vector_1, mi_vector_2) mi_vector_3 #&gt; [1] 1 3 5 2 4 6 Si intentamos combinar datos de diferentes tipos en un mismo vector, R realizará coerción automáticamente. El vector resultante será del tipo más flexible entre los datos que contenga, siguiendo las reglas de coerción. Creamos un vector numérico. mi_vector &lt;- c(1, 2, 3) class(mi_vector) #&gt; [1] &quot;numeric&quot; Si intentamos agregar un dato de tipo cadena de texto, nuestro vector ahora será de tipo cadena de texto. mi_vector_nuevo &lt;- c(mi_vector, &quot;a&quot;) class(mi_vector_nuevo) #&gt; [1] &quot;character&quot; Como las cadenas de texto son el tipo de dato más flexible, siempre que creamos un vector que incluye un dato de este tipo, el resultado será un vector de texto. mi_vector_mezcla &lt;- c(FALSE, 2, &quot;tercero&quot;, 4.00) class(mi_vector_mezcla) #&gt; [1] &quot;character&quot; Podemos crear vectores de secuencias numéricas usando :. De un lado de los dos puntos escribimos el número de inicio de la secuencia y del otro el final. Por ejemplo, creamos una secuencia del 1 al 10. 1:10 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 También podemos crear una secuencia del 10 al 1. 10:1 #&gt; [1] 10 9 8 7 6 5 4 3 2 1 Las secuencias creadas con : son consecutivas con incrementos o decrementos de 1. Estas secuencias pueden empezar con cualquier número, incluso si este es negativo o tiene cifras decimales # Número negativo -43:-30 #&gt; [1] -43 -42 -41 -40 -39 -38 -37 -36 -35 -34 -33 -32 -31 -30 # Número con cifras decimales 67.23:75 #&gt; [1] 67.23 68.23 69.23 70.23 71.23 72.23 73.23 74.23 Si nuestro número de inicio tiene cifras decimales, estas serán respetadas al hacer los incrementos o decrementos de uno en uno. En contraste, si es nuestro número de final el que tiene cifras decimales, este será redondeado. # Se conservan los decimales del inicio -2.48:2 #&gt; [1] -2.48 -1.48 -0.48 0.52 1.52 56.007:50 #&gt; [1] 56.007 55.007 54.007 53.007 52.007 51.007 50.007 # Se redondean los decimales del final 166:170.05 #&gt; [1] 166 167 168 169 170 968:960.928 #&gt; [1] 968 967 966 965 964 963 962 961 6.1.2 Vectorización de operaciones Existen algunas operaciones al aplicarlas a un vector, se aplican a cada uno de sus elementos. A este proceso le llamamos vectorización. Las operaciones aritméticas y relacionales pueden vectorizarse. Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene. Por ejemplo, creamos un vector numérico. mi_vector &lt;- c(2, 3, 6, 7, 8, 10, 11) Si aplicamos operaciones aritméticas, obtenemos un vector con un resultado por cada elemento. # Operaciones aritméticas mi_vector + 2 #&gt; [1] 4 5 8 9 10 12 13 mi_vector * 2 #&gt; [1] 4 6 12 14 16 20 22 mi_vector %% 2 #&gt; [1] 0 1 0 1 0 0 1 Al aplicar operaciones relacionales, obtenemos un vector de TRUEy FALSE, uno para cada elemento comparado. mi_vector &gt; 7 #&gt; [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE mi_vector &lt; 7 #&gt; [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE mi_vector == 7 #&gt; [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE Esta manera de aplicar una operación es muy eficiente. Comparada con otros procedimientos, requiere de menos tiempo de cómputo, lo cual a veces es considerable, en particular cuando trabajamos con un número grande de datos. Aunque el nombre de este proceso es vectorización, también funciona, en ciertas circunstancias, para otras estructuras de datos. "],["6-2-matrices-y-arrays.html", "6.2 Matrices y arrays", " 6.2 Matrices y arrays Las matrices y arrays pueden ser descritas como vectores multidimensionales. Al igual que un vector, únicamente pueden contener datos de un sólo tipo, pero además de largo, tienen más dimensiones. En un sentido estricto, las matrices son una caso especial de un array, que se distingue por tener específicamente dos dimensiones, un largo\" y un alto. Las matrices son, por lo tanto, una estructura con forma rectangular, con renglones y columnas. Como las matrices son usadas de manera regular en matemáticas y estadística, es una estructura de datos de uso común en R común y en la que nos enfocaremos en este libro. Los arrays, por su parte, pueden tener un número arbitrario de dimensiones. Pueden ser cubos, hipercubos y otras formas. Su uso no es muy común en R, aunque a veces es deseable contar con objetos n-dimensionales para manipular datos. Como los arrays tienen la restricción de que todos sus datos deben ser del mismo tipo, no importando en cuántas dimensiones se encuentren, esto limita sus usos prácticos. En general, es preferible usar listas en lugar de arrays, una estructura de datos que además tienen ciertas ventajas que veremos más adelante. 6.2.1 Creación de matrices Creamos matrices en R con la función matrix(). La función matrix() acepta dos argumentos, nrow y ncol. Con ellos especificamos el número de renglones y columnas que tendrá nuestra matriz. # Un vector numérico del uno al doce 1:12 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 # matrix() sin especificar renglones ni columnas matrix(1:12) #&gt; [,1] #&gt; [1,] 1 #&gt; [2,] 2 #&gt; [3,] 3 #&gt; [4,] 4 #&gt; [5,] 5 #&gt; [6,] 6 #&gt; [7,] 7 #&gt; [8,] 8 #&gt; [9,] 9 #&gt; [10,] 10 #&gt; [11,] 11 #&gt; [12,] 12 # Tres renglones y cuatro columnas matrix(1:12, nrow = 3, ncol = 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 # Cuatro columnas y tres columnas matrix(1:12, nrow = 4, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 # Dos renglones y seis columnas matrix(1:12, nrow = 4, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 Los datos que intentemos agrupar en una matriz serán acomodados en orden, de arriba a abajo, y de izquierda a derecha, hasta formar un rectángulo. Si multiplicamos el número de renglones por el número de columnas, obtendremos el número de celdas de la matriz. En los ejemplo anteriores, el número de celdas es igual al número de elementos que queremos acomodar, así que la operación ocurre sin problemas. Cuando intentamos acomodar un número diferente de elementos y celdas, ocurren dos cosas diferentes. Si el número de elementos es mayor al número de celdas, se acomodarán todos los datos que sean posibles y los demás se omitirán. matrix(1:12, nrow = 3, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 Si, por el contrario, el número de celdas es mayor que el número de elementos, estos se reciclaran. En cuanto los elementos sean insuficientes para acomodarse en las celdas, R nos devolverá una advertencia y se empezaran a usar los elementos a partir del primero de ellos matrix(1:12, nrow = 5, ncol = 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 6 11 4 #&gt; [2,] 2 7 12 5 #&gt; [3,] 3 8 1 6 #&gt; [4,] 4 9 2 7 #&gt; [5,] 5 10 3 8 Otro procedimiento para crear matrices es la unión vectores con las siguientes funciones: cbind() para unir vectores, usando cada uno como una columna. rbind() para unir vectores, usando cada uno como un renglón. De este modo podemos crear cuatro vectores y unirlos para formar una matriz. Cada vector será un renglón en esta matriz. Creamos cuatro vectores, cada uno de largo igual a cuatro. vector_1 &lt;- 1:4 vector_2 &lt;- 5:8 vector_3 &lt;- 9:12 vector_4 &lt;- 13:16 Usamos rbind() para crear un matriz, en la que cada vector será un renglón. matriz &lt;- rbind(vector_1, vector_2, vector_3, vector_4) # Resultado matriz #&gt; [,1] [,2] [,3] [,4] #&gt; vector_1 1 2 3 4 #&gt; vector_2 5 6 7 8 #&gt; vector_3 9 10 11 12 #&gt; vector_4 13 14 15 16 Si utilizamos cbind(), entonces cada vector será una columna. matriz &lt;- cbind(vector_1, vector_2, vector_3, vector_4) # Resultado matriz #&gt; vector_1 vector_2 vector_3 vector_4 #&gt; [1,] 1 5 9 13 #&gt; [2,] 2 6 10 14 #&gt; [3,] 3 7 11 15 #&gt; [4,] 4 8 12 16 Al igual que con matrix(), los elementos de los vectores son reciclados para formar una estructura rectangular y se nos muestra un mensaje de advertencia. # Elementos de largo diferente vector_1 &lt;- 1:2 vector_2 &lt;- 1:3 vector_3 &lt;- 1:5 matriz &lt;- cbind(vector_1, vector_2, vector_3) # Resultado matriz #&gt; vector_1 vector_2 vector_3 #&gt; [1,] 1 1 1 #&gt; [2,] 2 2 2 #&gt; [3,] 1 3 3 #&gt; [4,] 2 1 4 #&gt; [5,] 1 2 5 Finalmente, las matrices pueden contener NAs. Creamos dos vectores con un NA en ellos. vector_1 &lt;- c(NA, 1, 2) vector_2 &lt;- c(3, 4, NA) Creamos una matriz con rbind(). matriz &lt;- rbind(vector_1, vector_2) # Resultados matriz #&gt; [,1] [,2] [,3] #&gt; vector_1 NA 1 2 #&gt; vector_2 3 4 NA Como NA representa datos perdidos, puede estar presente en compañía de todo tipo de de datos. 6.2.2 Propiedades de las matrices No obstante que las matrices y arrays son estructuras que sólo pueden contener un tipo de datos, no son atómicas. Su clase es igual a matriz (matrix) o array según corresponda. Verificamos esto usando la función class(). mi_matriz &lt;- matrix(1:10) class(mi_matriz) #&gt; [1] &quot;matrix&quot; &quot;array&quot; Las matrices y arrays pueden tener más de una dimensión. Obtenemos el número de dimensiones de una matriz o array con la función dim(). Esta función nos devolverá varios números, cada uno de ellos indica la cantidad de elementos que tiene una dimensión. mi_matriz &lt;- matrix(1:12, nrow = 4, ncol = 3) dim(mi_matriz) #&gt; [1] 4 3 Cabe señalar que si usamos dim() con un vector, obtenemos NULL. Esto ocurre con todos los objetos unidimensionales mi_vector &lt;- 1:12 dim(mi_vector) #&gt; NULL Finalmente, las operaciones aritméticas también son vectorizadas al aplicarlas a una matriz. La operación es aplicada a cada uno de los elementos de la matriz. Creamos una matriz. mi_matriz &lt;- matrix(1:9, nrow = 3, ncol = 3) # Resultado mi_matriz #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 Intentemos sumar, multiplicar y elevar a la tercera potencia. # Suma mi_matriz + 1 #&gt; [,1] [,2] [,3] #&gt; [1,] 2 5 8 #&gt; [2,] 3 6 9 #&gt; [3,] 4 7 10 # Multiplicación mi_matriz * 2 #&gt; [,1] [,2] [,3] #&gt; [1,] 2 8 14 #&gt; [2,] 4 10 16 #&gt; [3,] 6 12 18 # Potenciación mi_matriz ^ 3 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 64 343 #&gt; [2,] 8 125 512 #&gt; [3,] 27 216 729 Si intentamos vectorizar una operación utilizando una matriz con NAs, esta se aplicará para los elementos válidos, devolviendo NA cuando corresponda. Creamos una matriz con NAs. vector_1 &lt;- c(NA, 2, 3) vector_2 &lt;- c(4, 5, NA) matriz &lt;- rbind(vector_1, vector_2) # Resultado matriz #&gt; [,1] [,2] [,3] #&gt; vector_1 NA 2 3 #&gt; vector_2 4 5 NA Intentamos dividir sus elementos entre dos. matriz / 2 #&gt; [,1] [,2] [,3] #&gt; vector_1 NA 1.0 1.5 #&gt; vector_2 2 2.5 NA Finalmente, podemos usar la función t() para transponer una matriz, es decir, rotarla 90°. Creamos una matriz con tres renglones y dos columnas. matriz &lt;- matrix(1:6, nrow = 3) # Resultado matriz #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 Usamos t() para transponer. matriz_t &lt;- t(matriz) # Resultado matriz_t #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 Obtenemos una matriz con dos renglones y dos columnas. "],["6-3-data-frames.html", "6.3 Data frames", " 6.3 Data frames Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas. Esta estructura de datos es la más usada para realizar análisis de datos y seguro te resultará familiar si has trabajado con otros paquetes estadísticos. Podemos entender a los data frames como una versión más flexible de una matriz. Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo. En términos generales, los renglones en un data frame representan casos, individuos u observaciones, mientras que las columnas representan atributos, rasgos o variables. Por ejemplo, así lucen los primeros cinco renglones del objeto iris, el famoso conjunto de datos Iris de Ronald Fisher, que está incluido en todas las instalaciones de R. #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa Los primeros cinco renglones corresponden a cinco casos, en este caso flores. Las columnas son variables con los rasgos de cada flor: largo y ancho de sépalo, largo y ancho de pétalo, y especie. Para crear un data frame usamos la función data.frame(). Esta función nos pedirá un número de vectores igual al número de columnas que deseemos. Todos los vectores que proporcionemos deben tener el mismo largo. Esto es muy importante: Un data frame está compuesto por vectores. Más adelante se hará evidente porque esta característica de un data frame es sumamente importante y también, cómo podemos sacarle provecho. Además, podemos asignar un nombre a cada vector, que se convertirá en el nombre de la columna. Como todos los nombres, es recomendable que este sea claro, no ambiguo y descriptivo. mi_df &lt;- data.frame( &quot;entero&quot; = 1:4, &quot;factor&quot; = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), &quot;numero&quot; = c(1.2, 3.4, 4.5, 5.6), &quot;cadena&quot; = as.character(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) ) mi_df #&gt; entero factor numero cadena #&gt; 1 1 a 1.2 a #&gt; 2 2 b 3.4 b #&gt; 3 3 c 4.5 c #&gt; 4 4 d 5.6 d # Podemos usar dim() en un data frame dim(mi_df) #&gt; [1] 4 4 # El largo de un data frame es igual a su número de columnas length(mi_df) #&gt; [1] 4 # names() nos permite ver los nombres de las columnas names(mi_df) #&gt; [1] &quot;entero&quot; &quot;factor&quot; &quot;numero&quot; &quot;cadena&quot; # La clase de un data frame es data.frame class(data.frame) #&gt; [1] &quot;function&quot; Si los vectores que usamos para construir el data frame no son del mismo largo, los datos no se reciclaran. Se nos devolverá un error. data.frame( &quot;entero&quot; = 1:3, &quot;factor&quot; = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), &quot;numero&quot; = c(1.2, 3.4, 4.5, 5.6), &quot;cadena&quot; = as.character(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) ) #&gt; Error in data.frame(entero = 1:3, factor = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), numero = c(1.2, : arguments imply differing number of rows: 3, 4 También podemos coercionar esta matriz a un data frame. Creamos una matriz. matriz &lt;- matrix(1:12, ncol = 4) Usamos as.data.frame() para coercionar una matriz a un data frame. df &lt;- as.data.frame(matriz) Verificamos el resultado class(df) #&gt; [1] &quot;data.frame&quot; # Resultado df #&gt; V1 V2 V3 V4 #&gt; 1 1 4 7 10 #&gt; 2 2 5 8 11 #&gt; 3 3 6 9 12 6.3.1 Propiedades de un data frame Al igual que con una matriz, si aplicamos una operación aritmética a un data frame, esta se vectorizará. Los resultados que obtendremos dependerán del tipo de datos de cada columna. R nos devolverá todas las advertencias que ocurran como resultado de las operaciones realizadas, por ejemplo, aquellas que hayan requerido una coerción. mi_df &lt;- data.frame( &quot;entero&quot; = 1:4, &quot;factor&quot; = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), &quot;numero&quot; = c(1.2, 3.4, 4.5, 5.6), &quot;cadena&quot; = as.character(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) ) # mi_df * 2 "],["6-4-listas.html", "6.4 Listas", " 6.4 Listas Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero a diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase, por lo que son estructuras heterogéneas. Podemos tener listas que contengan datos atómicos, vectores, matrices, arrays, data frames u otras listas. Esta última característica es la razón por la que una lista puede ser considerada un vector recursivo, pues es un objeto que puede contener objetos de su misma clase. Para crear una lista usamos la función list(), que nos pedirá los elementos que deseamos incluir en nuestra lista. Para esta estructura, no importan las dimensiones o largo de los elementos que queramos incluir en ella. Al igual que con un data frame, tenemos la opción de poner nombre a cada elemento de una lista. Por último, no es posible vectorizar operaciones aritméticas usando una lista, se nos devuelve un error como resultado. mi_vector &lt;- 1:10 mi_matriz &lt;- matrix(1:4, nrow = 2) mi_df &lt;- data.frame(&quot;num&quot; = 1:3, &quot;let&quot; = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) mi_lista &lt;- list(&quot;un_vector&quot; = mi_vector, &quot;una_matriz&quot; = mi_matriz, &quot;un_df&quot; = mi_df) mi_lista #&gt; $un_vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $una_matriz #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; $un_df #&gt; num let #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c Creamos una lista que contiene otras listas. lista_recursiva &lt;- list(&quot;lista1&quot; = mi_lista, &quot;lista2&quot; = mi_lista) # Resultado lista_recursiva #&gt; $lista1 #&gt; $lista1$un_vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $lista1$una_matriz #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; $lista1$un_df #&gt; num let #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c #&gt; #&gt; #&gt; $lista2 #&gt; $lista2$un_vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $lista2$una_matriz #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; $lista2$un_df #&gt; num let #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c 6.4.1 Propiedades de una lista Una lista es unidimensional, sólo tiene largo. El largo de una lista es igual al número de elementos que contiene, sin importar de qué tipo o clase sean. Usamos la lista recursiva que creamos en la sección anterior para ilustrar esto. length(lista_recursiva) #&gt; [1] 2 Dado que una lista siempre tiene una sola dimensión, la función dim() nos devuelve NULL. dim(lista_recursiva) #&gt; NULL Las listas tienen clase list, sin importar qué elementos contienen. class(lista_recursiva) #&gt; [1] &quot;list&quot; Finalmente, no es posible vectorizar operaciones aritméticas usando listas. Al intentarlo nos es devuelto un error. mi_lista / 2 #&gt; Error in mi_lista/2: argumento no-numérico para operador binario Si deseamos aplicar una función a cada elemento de una lista, usamos lapply(), como veremos en el capítulo 10. "],["6-5-coerción-1.html", "6.5 Coerción", " 6.5 Coerción Al igual que con los datos, cuando intentamos hacer operaciones con una estructura de datos, R intenta coercionarla al tipo apropiado para poder llevarlas a cabo con éxito. También podemos usar alguna de las funciones de la familia as() coercionar de un tipo de estructura de datos. A continuación se presentan las más comunes. Función Coerciona a Coerciona exitosamente a as.vector() Vector Matrices as.matrix() Matrices Vectores, Data frames as.data.frame() Data frame Vectores, Matrices as.list() Lista Vectores, Matrices, Data frames Como podrás ver, las estructuras de datos más sencillas, (unidimensionales, homogéneas) pueden ser coercionadas a otras más complejas (multidimensionales, heterogéneas), pero la operación inversa casi nunca es posible. Veamos algunos ejemplos. Creamos un vector, una matriz, un data frame y una lista. mi_vector &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) mi_matriz &lt;- matrix(1:4, nrow = 2) mi_df &lt;- data.frame(&quot;a&quot; = 1:2, &quot;b&quot; = c(&quot;a&quot;, &quot;b&quot;)) mi_lista &lt;- list(&quot;a&quot; = mi_vector, &quot;b&quot; = mi_matriz, &quot;c&quot; = mi_df) Intentemos coercionar a vector con as.vector(). as.vector(mi_matriz) #&gt; [1] 1 2 3 4 as.vector(mi_df) #&gt; a b #&gt; 1 1 a #&gt; 2 2 b as.vector(mi_lista) #&gt; $a #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; #&gt; #&gt; $b #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; $c #&gt; a b #&gt; 1 1 a #&gt; 2 2 b La coerción que intentamos sólo tuvo éxito para una matriz. Para data frame y lista, nos devolvió los mismos objetos. Nota que as.vector() no devolvió un error o una advertencia a pesar de que no tuvo éxito al coercionar, en este caso un data frame o una lista. Esto es importante, pues no puedes confiar que as.vector() tuvo éxito porque corrió sin errores, es necesaria una verificación adicional. Como R intenta coercionar automáticamente, esto puede producir resultados inesperados si no tenemos cuidado. Intentemos coercionar a matriz con as.matrix(). as.matrix(mi_vector) #&gt; [,1] #&gt; [1,] &quot;a&quot; #&gt; [2,] &quot;b&quot; #&gt; [3,] &quot;c&quot; as.matrix(mi_df) #&gt; a b #&gt; [1,] &quot;1&quot; &quot;a&quot; #&gt; [2,] &quot;2&quot; &quot;b&quot; as.matrix(mi_lista) #&gt; [,1] #&gt; a character,3 #&gt; b integer,4 #&gt; c data.frame,2 El vector fue coercionado a una matriz con una sola columna. Por su parte, al correr la función con un data frame, coercionamos también todos los datos que contiene, siguiendo las reglas de coerción de tipos de dato que vimos en el capítulo 4. Al coercionar una lista a una matriz, efectivamente obtenemos un objeto de este tipo, sin embargo perdemos toda la información que contiene, por lo tanto, no podemos considerar que esta es una coerción exitosa. Del mismo modo que con as.vector(), no nos es mostrado ningún error ni advertencia. Intentemos coercionar a matriz con as.data.frame(). as.data.frame(mi_vector) #&gt; mi_vector #&gt; 1 a #&gt; 2 b #&gt; 3 c as.data.frame(mi_matriz) #&gt; V1 V2 #&gt; 1 1 3 #&gt; 2 2 4 as.data.frame(mi_lista) #&gt; Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 2 Tuvimos éxito al coercionar vectores y matrices. El vector, al igual que cuando fue coercionado a matriz, devolvió como resultado un objeto con una sola columna, mientras que la matriz conservó sus renglones y columnas. En este caso, al intentar la coerción de lista a data frame, obtenemos un error. Esta es la única situación en la que esto ocurre utilizando las funciones revisadas en esta sección. Por último, intentemos coercionar a matriz con as.list(). as.list(mi_vector) #&gt; [[1]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;b&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;c&quot; as.list(mi_matriz) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 as.list(mi_df) #&gt; $a #&gt; [1] 1 2 #&gt; #&gt; $b #&gt; [1] &quot;a&quot; &quot;b&quot; Dado que las listas son el tipo de objeto más flexible de todos, hemos tenido éxito en todos los casos con nuestra coerción. Nota que para los vectores y matrices, cada uno de los elementos es transformado en un elemento dentro de la lista resultante. Si tuviéramos una matriz con cuarenta y ocho celdas, obtendríamos una lista con ese mismo número de elementos. En cambio, para un data frame, el resultado es una lista, en la que cada elemento contiene los datos de una columna del data frame original. Un data frame con diez columnas resultará en una lista de diez elementos. Conocer cómo ocurre la coerción de estructuras de datos te ayudará a entender mejor algunos resultados devueltos por funciones de R, además de que te facilitará la manipulación y procesamiento de datos. "],["7-subconjuntos.html", "Capítulo 7 Subconjuntos", " Capítulo 7 Subconjuntos En R, podemos obtener subconjuntos de nuestras estructuras de datos. Es decir, podemos extraer partes de una estructura de datos (nuestro conjunto). Hacemos esto para seleccionar datos que tienen características específicas, por ejemplo, todos los valores mayores a cierto número o aquellos que coinciden exactamente con un valor de nuestro interés. Para realizar esta operación haremos uso de índices, operadores lógicos y álgebra Booleana. Algunos procedimientos para obtener subconjuntos pueden usarse con cualquier estructura de datos, mientras que otras sólo funcionan con algunas de ellas. En este capítulo revisaremos cómo extraer subconjuntos de vectores, matrices, data frames y listas, usando índices, nombres y condicionales. "],["7-1-índices.html", "7.1 Índices", " 7.1 Índices Usar índices para obtener subconjuntos es el procedimiento más universal en R, pues funciona para todas las estructuras de datos. Un índice en R representa una posición. Cuando usamos índices le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas dentro de ella. A diferencia de la mayoría de los lenguajes de programación, los índices en R empiezan en 1, no en 0. El índice del primer elemento de una estructura de datos siempre es 1, el segundo 2, y así sucesivamente. Un aspecto muy importante de este procedimiento es que, para data frames y listas, cuando extraemos un subconjunto de un objeto usando corchetes, obtenemos como resultado un objeto de la misma clase que el objeto original. Si extraemos un subconjunto de un data frame, obtenemos un vector; y si extraemos de una lista, obtenemos una lista. El uso de índices tiene además otras características particulares para las distintas estructuras de datos, así que veremos este procedimiento para cada una de ellas. 7.1.1 Vectores Empecemos creando un vector que contiene los nombres de distintos niveles educativos. nivel &lt;- c(&quot;Preescolar&quot;, &quot;Primaria&quot;, &quot;Secundaria&quot;, &quot;Educación Media Superior&quot;, &quot;Educación Superior&quot;) nivel #&gt; [1] &quot;Preescolar&quot; &quot;Primaria&quot; #&gt; [3] &quot;Secundaria&quot; &quot;Educación Media Superior&quot; #&gt; [5] &quot;Educación Superior&quot; Este es un vector de largo igual a cinco. length(nivel) #&gt; [1] 5 ¿Cómo obtendríamos el tercer elemento de este vector usando índices? ¿O del primer al cuarto elemento? ¿O el segundo y quinto elemento? Para obtener subconjuntos con índices escribimos corchetes [] después del nombre de un objeto. Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto. Por ejemplo: objeto[3] lista[4:5] dataframe[c(2, 7), ] Entonces, para extraer el tercer elemento de nuestro vector nivel hacemos lo siguiente. nivel[3] #&gt; [1] &quot;Secundaria&quot; Para extraer del primer al cuarto elemento de un vector, usamos un vector con una secuencia numérica del 1 al 4 creada con :. nivel[1:4] #&gt; [1] &quot;Preescolar&quot; &quot;Primaria&quot; #&gt; [3] &quot;Secundaria&quot; &quot;Educación Media Superior&quot; Sin embargo, si intentamos extraer el segundo y quinto elemento del vector nivel corriendo lo siguiente, obtendremos un error. nivel[2, 5] #&gt; Error in nivel[2, 5]: número incorreto de dimensiones ¿Porqué no ha funcionado lo anterior? El mensaje de error nos da una pista muy importante. Al usar una coma dentro de los corchetes estamos dando la instrucción a R de buscar los índices solicitados en más de una dimensión. El número antes de la coma será buscado en la primera dimensión del objeto, y el segundo número, en su segunda dimensión. Entonces, al llamar nivel[2, 5], lo que estamos pidiendo es que R extraiga el elemento que se encuentra en la posición 2 de la primera dimensión del vector, y el elemento en la posición 5 de su segunda dimensión. Como los vectores son unidimensionales, es imposible cumplir esta instrucción y se produce un error. Recuerda que en R, un número sencillo es también un vector, por lo tanto, cuando escribimos vector[3], en realidad estamos dando como índice un vector que contiene al número 3. Por lo tanto, si deseamos extraer elementos en posiciones no consecutivas, debemos usar vectores generados con c(). De este modo damos un vector, de más de un número de largo al corchete, pero todos se encuentran en una misma dimensión. Aplicando lo anterior, si escribimos dentro de los corchetes c(2, 5), entonces tendremos éxito al extraer el segundo y quinto elemento de nivel. nivel[c(2, 5)] #&gt; [1] &quot;Primaria&quot; &quot;Educación Superior&quot; Para estructuras de dos dimensiones, como son matrices y data frames, el primer vector de un índice, antes de una coma, es la posición en los renglones y el segundo es la posición las columnas. Obtener subconjuntos por renglones y columnas es un tipo de operación muy común al trabajar con data frames y matrices. 7.1.2 Data frames Creamos un data frame llamado mi_df. mi_df &lt;- data.frame(&quot;nombre&quot; = c(&quot;Armando&quot;, &quot;Elsa&quot;, &quot;Ignacio&quot;, &quot;Olga&quot;), &quot;edad&quot; = c(20, 24, 22, 30), &quot;sexo&quot; = c(&quot;H&quot;, &quot;M&quot;, &quot;M&quot;, &quot;H&quot;), &quot;grupo&quot; = c(0, 1, 1, 0)) # Resultado mi_df #&gt; nombre edad sexo grupo #&gt; 1 Armando 20 H 0 #&gt; 2 Elsa 24 M 1 #&gt; 3 Ignacio 22 M 1 #&gt; 4 Olga 30 H 0 Usamos dim() para confirmar que nuestro objeto tiene dos dimensiones: tres renglones y tres columnas. dim(mi_df) #&gt; [1] 4 4 Si usamos un índice con un sólo número, extraemos una columna completa, con todos sus renglones. mi_df[1] #&gt; nombre #&gt; 1 Armando #&gt; 2 Elsa #&gt; 3 Ignacio #&gt; 4 Olga Si usamos un vector, sin comas, obtenemos varias columnas. mi_df[c(1, 3)] #&gt; nombre sexo #&gt; 1 Armando H #&gt; 2 Elsa M #&gt; 3 Ignacio M #&gt; 4 Olga H Al usar comas, el vector antes de la coma nos devolverá un renglón completo. mi_df[3,] #&gt; nombre edad sexo grupo #&gt; 3 Ignacio 22 M 1 Nota que si dejamos vació el espacio después de la coma, se nos devuelven todas las columnas del data frame. Si el espacio que dejamos vacío es el que se encuentra después de la coma, obtenemos columnas. Esto es equivalente a usar un solo vector dentro de los corchetes. mi_df[ ,1] #&gt; [1] &quot;Armando&quot; &quot;Elsa&quot; &quot;Ignacio&quot; &quot;Olga&quot; Al combinar índices para renglones y columnas, obtenemos los datos que se encuentran en una posición específica. Por ejemplo, el dato en el tercer renglón y la tercer columna. mi_df[3, 3] #&gt; [1] &quot;M&quot; El segundo y tercer dato de la tercera columna. mi_df[2:3, 3] #&gt; [1] &quot;M&quot; &quot;M&quot; El cuarto renglón de la tercera y cuarta columna. mi_df[4, 3:4] #&gt; sexo grupo #&gt; 4 H 0 También podemos usar vectores de más de un número. Por ejemplo, los datos en en el primer y segundo renglón, y en la segunda y cuarta columna. mi_df[1:2, c(2, 4)] #&gt; edad grupo #&gt; 1 20 0 #&gt; 2 24 1 Por último, en todos los casos anteriores, hemos obtenido como resultado un data frame. sub_df &lt;- mi_df[1:2, c(2, 4)] class(sub_df) #&gt; [1] &quot;data.frame&quot; Si damos un índice inválido para las columnas, es decir, un número de columna que no exista, se nos devuelve un renglón. Intentemos obtener la séptima columna de mi_df. mi_df[7] #&gt; Error in `[.data.frame`(mi_df, 7): undefined columns selected Sin embargo, para los renglones simplemente se nos devuelve NA. mi_df[7, ] #&gt; nombre edad sexo grupo #&gt; NA &lt;NA&gt; NA &lt;NA&gt; NA 7.1.3 Matrices El procedimiento anterior para data frames funciona de la misma manera para las matrices, con una excepción. Si usamos como índice un sólo número, entonces obtendremos el valor que se encuentre en esa posición, contando celdas de arriba a abajo y de izquierda a derecha. Creamos una matriz con 4 renglones y dos columnas. mi_matriz &lt;- matrix(1:8, nrow = 4) # Resultado mi_matriz #&gt; [,1] [,2] #&gt; [1,] 1 5 #&gt; [2,] 2 6 #&gt; [3,] 3 7 #&gt; [4,] 4 8 Si damos como índice el número 8, R no intentará devolvernos la octava columna de la matriz, sino la octava celda. mi_matriz[8] #&gt; [1] 8 Fuera de este caso, los índices de renglones y columna tienen el mismo comportamiento que en un data frame. # Tercer renglón mi_matriz[3, ] #&gt; [1] 3 7 # Segunda columna mi_matriz[ ,2] #&gt; [1] 5 6 7 8 # Tercer renglón y segunda columna mi_matriz[3, 2] #&gt; [1] 7 Nota que en este caso obtenemos vectores al extraer un subconjunto. 7.1.4 Arrays Para objetos de tres o más dimensiones se siguen las mismas reglas que con las matrices, aunque ya no es tan fácil hablar de renglones y columnas. Creamos un array de cuatro dimensiones. mi_array &lt;- array(data = 1:16, dim = c(2, 2, 2, 2)) Veamos nuestro resultado y comprobamos con dim() su número de dimensiones. mi_array #&gt; , , 1, 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; , , 2, 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 5 7 #&gt; [2,] 6 8 #&gt; #&gt; , , 1, 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 9 11 #&gt; [2,] 10 12 #&gt; #&gt; , , 2, 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 13 15 #&gt; [2,] 14 16 # Comprobamos el número de dimensiones de nuestro objeto dim(mi_array) #&gt; [1] 2 2 2 2 Intentemos extraer varios subconjuntos, sólo para ilustrar cómo funcionan los índices con arrays. mi_array[1, , , ] #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 1 5 #&gt; [2,] 3 7 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 9 13 #&gt; [2,] 11 15 mi_array[1, 2, , ] #&gt; [,1] [,2] #&gt; [1,] 3 11 #&gt; [2,] 7 15 mi_array[1, 2, 1, ] #&gt; [1] 3 11 mi_array[1, 2, 1, 2] #&gt; [1] 11 Nota que como resultados obtenemos matrices, a menos que hagamos una extraigamos el contenido de una sola celda. "],["7-2-nombres.html", "7.2 Nombres", " 7.2 Nombres Un segundo método para extraer subconjuntos es usar los nombres de los elementos en una estructura de datos. Este forma de obtener subconjuntos es usada principalmente con data frames y listas. De manera similar a los índices, usamos corchetes cuadrados [] después del nombre de un objeto, pero en lugar de escribir un número, escribimos el nombre del elemento que deseamos extraer como una cadena de texto, es decir, entre comillas. 7.2.1 Data frames Los elementos de un data frame son sus columnas y cada una de ellas tiene un nombre, lo que estamos pidiendo a R con este método es que nos devuelva los elementos cuyo nombre coincida con el que hemos proporcionado Para mostrar el uso de este método, utilizaremos el mismo data frame que en la sección anterior. Si escribimos entre corchetes nombre, obtendremos toda la columna nombre. mi_df[&quot;nombre&quot;] #&gt; nombre #&gt; 1 Armando #&gt; 2 Elsa #&gt; 3 Ignacio #&gt; 4 Olga Al escribir grupo, nos es devuelta toda la columna con ese nombre. mi_df[&quot;grupo&quot;] #&gt; grupo #&gt; 1 0 #&gt; 2 1 #&gt; 3 1 #&gt; 4 0 De igual manera que con los índices, al escribir una coma dentro de los corchetes, estamos pidiendo con ello extraer elementos en más de una dimensión. Lo que está antes escrito antes de la coma corresponde a renglones, y lo que está después, a columnas. Si ejecutamos lo siguiente, obtendremos NA en lugar de obtener las columnas edad y sexo. mi_df[&quot;edad&quot;, &quot;sexo&quot;] #&gt; [1] NA Lo anterior ocurre porque R intenta encontrar un renglón llamado edad y una columna llamada sexo, al no encontrarlas, nos devuelve NA. Recuerda que aunque no es lo más común, los renglones de un data frame pueden tener nombres. Al igual que con los índices, si damos el nombre de un renglón que existe, obtenemos NA. Es sólo al solicitar un nombre de columna no válido que se nos devuelve un error. Pedimos un nombre de renglón inexistente y obtenemos NA. mi_df[&quot;localidad&quot;, ] #&gt; nombre edad sexo grupo #&gt; NA &lt;NA&gt; NA &lt;NA&gt; NA Pero si pedimos un nombre inválido de columna, nos es devuelto un error. mi_df[, &quot;localidad&quot;] #&gt; Error in `[.data.frame`(mi_df, , &quot;localidad&quot;): undefined columns selected Para extraer más de una columna, escribimos un vector de texto entre los corchetes. Por ejemplo mi_df[c(&quot;edad&quot;, &quot;sexo&quot;)] #&gt; edad sexo #&gt; 1 20 H #&gt; 2 24 M #&gt; 3 22 M #&gt; 4 30 H Además, las columnas son devueltas en el orden que las pedimos, lo cual es conveniente cuando estamos procesando y recodificando datos. mi_df[c(&quot;sexo&quot;, &quot;edad&quot;)] #&gt; sexo edad #&gt; 1 H 20 #&gt; 2 M 24 #&gt; 3 M 22 #&gt; 4 H 30 7.2.2 Listas Para una lista, el procedimiento es prácticamente el mismo que para un data frame, pero en lugar de obtener columnas, obtenemos los elementos contenidos en ella. La primera diferencia con los data frame es que, dado que las listas son unidimensionales, si usamos una coma dentro de los corchetes, nos será devuelto un error. Creamos una lista llamada mi_lista. mi_lista &lt;- list(&quot;uno&quot; = 1, &quot;dos&quot; = &quot;2&quot;, &quot;tres&quot; = as.factor(3), &quot;cuatro&quot; = matrix(1:4, nrow = 2)) Intentamos obtener un subconjunto con una coma. mi_lista[&quot;uno&quot;, &quot;dos&quot;] #&gt; Error in mi_lista[&quot;uno&quot;, &quot;dos&quot;]: número incorreto de dimensiones Si pedimos un nombre que no existe en la lista, se nos devuelve NULL en lugar de un error. mi_lista[&quot;cinco&quot;] #&gt; $&lt;NA&gt; #&gt; NULL Para todo lo demás, los nombres tienen el mismo comportamiento que para los data frames. Extremos un elemento de la lista. mi_lista[&quot;dos&quot;] #&gt; $dos #&gt; [1] &quot;2&quot; Extraemos más de un elemento de la lista. mi_lista[c(&quot;cuatro&quot;, &quot;tres&quot;)] #&gt; $cuatro #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; $tres #&gt; [1] 3 #&gt; Levels: 3 "],["7-3-subconjuntos-por-índice-y-nombre.html", "7.3 Subconjuntos por índice y nombre", " 7.3 Subconjuntos por índice y nombre Al extraer subconjuntos podemos combinar índices con nombres dentro del mismo corchete para objetos multidimensionales, por ejemplo, usando un índice antes de la coma y un nombre después de ella. Esto nos da una gran flexibilidad para hacer subconjuntos con data frames y matrices. En particular, es útil al definir funciones y al trabajar con conjuntos de datos de los tenemos información incompleta. Por ejemplo, extraemos el tercer y cuarto renglón de la columna nombre en nuestro data frame mi_df. mi_df[3:4, &quot;nombre&quot;] #&gt; [1] &quot;Ignacio&quot; &quot;Olga&quot; También podemos usar vectores dentro de los corchetes. Extraemos los renglones con los nombres 48 y 100 de las primera y cuarta columna de iris. iris[c(&quot;48&quot;, &quot;100&quot;), c(1, 4)] #&gt; Sepal.Length Petal.Width #&gt; 48 4.6 0.2 #&gt; 100 5.7 1.3 "],["7-4-el-signo-de-dolar-y-los-corchetes-dobles.html", "7.4 El signo de dolar $ y los corchetes dobles [[]]", " 7.4 El signo de dolar $ y los corchetes dobles [[]] Otra manera en la que podemos extraer subconjuntos usando nombres, es con el signo de dólar $. Para usar este método, escribir el signo $ después del nombre de un objeto de la siguiente forma: objeto$nombre. Este método permite extraer un sólo elemento a la vez, funciona para data frames y listas, y para el caso de los data frame, el elemento extraído siempre será una columna. Por ejemplo, extraemos la columna nombre del data frame mi_df. mi_df$nombre #&gt; [1] &quot;Armando&quot; &quot;Elsa&quot; &quot;Ignacio&quot; &quot;Olga&quot; También podemos escribir el nombre del elemento que deseamos entre comillas, esto es útil si el nombre tiene espacios. mi_df$&quot;nombre&quot; #&gt; [1] &quot;Armando&quot; &quot;Elsa&quot; &quot;Ignacio&quot; &quot;Olga&quot; Si intentamos dar más de un nombre después del signo $, nos es devuelto un error. mi_df$c(&quot;nombre&quot;, &quot;edad&quot;) El resultado de las operaciones anteriores no es un data frame, sino un vector. class(mi_df$nombre) #&gt; [1] &quot;character&quot; Esta es una característica distintiva de este método, al usar el signo $ para extraer un elemento de un data frame o una lista, obtenemos un objeto de la clase que ese elemento era originalmente. Recuerda que un data frame está formado por vectores. Como vimos en el capítulo 6, una manera de generar data frames es combinar vectores. Estos vectores, aunque estén contenidos dentro de un data frame, conservan todas las características de un vector y es posible extraerlos como tales. Cuando usamos el signo $, le pedimos a R que extraiga de un objeto un subconjunto con sus propiedades originales. Por esta razón, para los data frame, siempre son devueltos vectores, mientras que para las listas lo que obtenemos depende del tipo de objeto contenido en ellas. Por ejemplo, si extraemos el elemento uno de mi_lista usando corchetes, obtenemos una lista. class(mi_lista[&quot;uno&quot;]) #&gt; [1] &quot;list&quot; Pero si usamos el signo $, el resultado es un vector numérico, pues esta es su clase original. class(mi_lista$uno) #&gt; [1] &quot;numeric&quot; Si intentamos extraer el elemento cuatro, obtendremos una matriz. class(mi_lista$&quot;cuatro&quot;) #&gt; [1] &quot;matrix&quot; &quot;array&quot; De manera similar, podemos extraer elementos de un objeto, con su clase original, usando índices y corchetes dobles [[]]. La ventaja de usar corchetes dobles es no sólo podemos usar índices, sino que los podemos combinar con nombres, lo cual nos da acceso a una mayor flexibilidad para extraer subconjuntos y permite usarlos en estructuras de datos con elementos sin nombre. Por ejemplo, para extraer la columna edad de mi_df con corchetes dobles, podemos usar su índice, 2, o su nombre. # Usando un índice mi_df[[2]] #&gt; [1] 20 24 22 30 # Usando un nombre mi_df[[&quot;edad&quot;]] #&gt; [1] 20 24 22 30 A diferencia de los corchetes sencillos, no podemos extraer más de una columna de un data frame usando corchetes dobles y un vector. Si escribimos un vector numérico dentro de corchetes dobles, será interpretado como si cada número estuviera separado por una coma, indicando las dimensiones de las cuales se extraerán datos. Por ejemplo, intentamos extraer las columnas uno y tres de mi_df. mi_df[[c(1, 3)]] #&gt; [1] &quot;Ignacio&quot; El resultado que obtenemos no es el esperado. Lo que ocurre es que cuando escribimos lo siguiente. mi_df[[c(1, 3)]] R lo interpreta como: mi_df[[1, 3]] Es decir, R extraerá el dato en el renglón uno y la columna tres, en lugar de las columnas uno y tres. mi_df[[1, 3]] #&gt; [1] &quot;H&quot; Por lo tanto si escribimos lo siguiente: mi_df[[1:3]] R lo interpretará como buscar el dato uno en la primera dimensión, el dato dos, en la segunda dimensión, y el dato tres en la tercera dimensión. Como un data frame solo tiene dos dimensiones, se nos devolverá un error mi_df[[1:3]] #&gt; Error in .subset2(x, i, exact = exact): falló indexación recursiva en nivel 2 Lo mismo ocurre con vectores que contienen nombres de columnas. mi_df[[c(&quot;nombre&quot;, &quot;edad&quot;)]] #&gt; Error in .subset2(x, i, exact = exact): subíndice fuera de los límites Como las listas son unidimensionales, sólo podemos extraer un elemento a la vez usando corchetes dobles [[]] mi_lista[[1]] #&gt; [1] 1 Si damos más de un índice o nombre, siempre obtendremos un error. # Más de un índice mi_lista[[1:2]] #&gt; Error in mi_lista[[1:2]]: subíndice fuera de los límites # Más de un nombre mi_lista[[&quot;uno&quot;, &quot;dos&quot;]] #&gt; Error in mi_lista[[&quot;uno&quot;, &quot;dos&quot;]]: número incorrecto de subíndices 7.4.1 Los data frames y listas son como cajas de manzanas Para comprender mejor el comportamiento comportamiento del signo $ y los corchetes dobles, imagina que los data frames y listas son cajas que contienen manzanas. Los data frame contienen las manzanas en bolsas, y estas bolsas serían vectores, en los cuales cada manzana sería un elemento. Por su parte, las listas pueden tener manzanas en diferentes presentaciones: bolsas, manzanas sueltas o incluso otras cajas de manzana. Cuando usamos corchetes, estamos sacando manzanas de una caja, usando una caja más pequeña, otro data frame o lista. Así, con un data frame, obtenemos otra caja que contiene bolsas de manzanas, y con una lista obtenemos otra caja con manzanas en las presentaciones que se encuentren. En contraste, al usar el signo $ o corchetes dobles, estamos sacando bolsas de manzana directamente en un data frame, y en las listas estamos sacando las manzanas en su presentación original, sin que haya de por medio otra caja en ninguno de estos casos. Dado lo anterior, podemos extraer subconjuntos de subconjuntos combinando diferentes tipos de corchetes. # Subconjunto de un subconjunto: Data frame. mi_df[[2]][3] #&gt; [1] 22 # Subconjunto de un subcojunto: Lista. mi_lista[[&quot;cuatro&quot;]][2] #&gt; [1] 2 No te preocupes mucho si lo anterior te parece confuso, lo es. No profundizaremos sobre este tema específico de los subconjuntos en este libro, pero ten en cuenta que si te encuentras con código como el del ejemplo anterior, lo que está ocurriendo es la extracción de subconjuntos de subconjuntos. "],["7-5-condicionales.html", "7.5 Condicionales", " 7.5 Condicionales Las condicionales nos permiten obtener subconjuntos que para los que una o más condiciones son verdaderas (TRUE). Para este procedimiento usamos operadores lógicos y condicionales, como revisamos en el capítulo 5 y lo podemos aplicar a data frames. Con este procedimiento, podemos extraer todos los datos de una encuesta que corresponden a mujeres, o a personas que viven en una entidad específica, o que tienen un ingreso superior a la media, o cualquier otra condición que se verificable con álgebra Booleana. Realizamos la extracción de subconjuntos mediante operaciones relacionales y lógicas dentro de corchetes. Esta operación tiene la siguiente estructura. objeto[condicion, columnas_devueltas] En donde: objeto: es un data frame. condición: un subconjunto de objeto, que devuelva un columna como vector, al que se le aplica una o más operaciones lógicas o relacionales. columnas_devueltas: los índices o nombres de las columnas que deseamos sean devueltas como resultado. Dentro del corchete escribimos, antes de una coma, el código para obtener un subconjunto que extraiga una columna, del data frame al que queremos extraer un subconjunto usando un subconjunto. Este primer subconjunto debe ser extraído con alguno de los dos procedimientos que da como resultado un vector, ya sea el signo $ o corchetes dobles [[]]. Necesitamos extraer un vector, porque aplicaremos a todos los elementos de esa columna una operación relacional, usando vectorización, como lo vimos en el capítulo 6. Todos los elementos para los que el resultado de esta operación sea TRUE, formarán parte de nuestro subconjunto usando condicionales. Como cada elemento de una columna de un data frame está ubicado en su propio renglón, podemos decir que nos serán devueltos los renglones para los que la condición sea verdadera. Si dejamos el espacio para columnas_devueltas vacío, nuestro resultado será un data frame con las mismas columnas que el data frame original. Si damos un índice o un nombre, entonces obtendremos un data frame sólo con las columnas solicitadas. De este modo, podemos extraer renglones y columnas específicas. Veamos esto en práctica, extrayendo subconjuntos de los datos iris. 7.5.1 Usando condicionales Intentaremos extraer todos los datos en iris en los que el largo del sépalo, columna Petal.Width, sea mayor que 7.5. Primero, obtenemos el subconjunto de esta columna de iris. Usaremos el signo $ iris$Sepal.Length #&gt; [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 #&gt; [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 #&gt; [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 #&gt; [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 #&gt; [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 #&gt; [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 #&gt; [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 #&gt; [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 #&gt; [145] 6.7 6.7 6.3 6.5 6.2 5.9 Si aplicamos la operación relacional &gt; 7 a este subconjunto, obtenemos un vector, con TRUE o FALSE para cada elemento de iris$Petal.Width. iris$Sepal.Length &gt; 7.5 #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE #&gt; [121] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE #&gt; [133] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [145] FALSE FALSE FALSE FALSE FALSE FALSE Escribimos esta operación dentro de los corchetes, antes de una coma. No escribimos nada después de la coma, para obtener un subconjunto con todas las columnas de iris. iris[iris$Sepal.Length &gt; 7.5, ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 106 7.6 3.0 6.6 2.1 virginica #&gt; 118 7.7 3.8 6.7 2.2 virginica #&gt; 119 7.7 2.6 6.9 2.3 virginica #&gt; 123 7.7 2.8 6.7 2.0 virginica #&gt; 132 7.9 3.8 6.4 2.0 virginica #&gt; 136 7.7 3.0 6.1 2.3 virginica Podemos pedir que se nos devuelvan sólo los datos de la columna Species, escribiendo el índice o nombre de esta columna después de la coma. # Usando índice iris[iris$Sepal.Length &gt; 7.5, 5] #&gt; [1] virginica virginica virginica virginica virginica virginica #&gt; Levels: setosa versicolor virginica #USando nombres iris[iris$Sepal.Length &gt; 7.5, &quot;Species&quot;] #&gt; [1] virginica virginica virginica virginica virginica virginica #&gt; Levels: setosa versicolor virginica Nota que si pedimos una sola columna en nuestros resultado, el resultado será un vector en lugar de un data frame. class(iris[iris$Sepal.Length &gt; 7.5, &quot;Species&quot;]) #&gt; [1] &quot;factor&quot; Podemos realizar más de una operación relacional antes de la coma, usando operadores lógicos. Por ejemplo, extraemos todos los datos para los que el ancho del pétalo (Sepal.Width) sea menor que 3 y la especie (Species) sea setosa. iris[iris$Sepal.Width &lt; 3 &amp; iris$Species == &quot;setosa&quot;, ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 42 4.5 2.3 1.3 0.3 setosa Recuerda que puedes usar el operados ! para negaciones. De este modo puedes extraer todos los datos que no son de la especie virginica o su largo sea menor a 4.7. iris[!(iris$Petal.Length &lt; 4.7 | iris$Species == &quot;virginica&quot;), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 51 7.0 3.2 4.7 1.4 versicolor #&gt; 53 6.9 3.1 4.9 1.5 versicolor #&gt; 57 6.3 3.3 4.7 1.6 versicolor #&gt; 64 6.1 2.9 4.7 1.4 versicolor #&gt; 71 5.9 3.2 4.8 1.8 versicolor #&gt; 73 6.3 2.5 4.9 1.5 versicolor #&gt; 74 6.1 2.8 4.7 1.2 versicolor #&gt; 77 6.8 2.8 4.8 1.4 versicolor #&gt; 78 6.7 3.0 5.0 1.7 versicolor #&gt; 84 6.0 2.7 5.1 1.6 versicolor #&gt; 87 6.7 3.1 4.7 1.5 versicolor En realidad podemos usar un vector lógico para extraer subconjuntos, sin necesidad de realizar una operación relacional. Por ejemplo, para obtener los dato en el primer y cuarto renglón de mi_df. mi_df[c(TRUE, FALSE, FALSE, TRUE), ] #&gt; nombre edad sexo grupo #&gt; 1 Armando 20 H 0 #&gt; 4 Olga 30 H 0 Si damos un vector lógico de largo menor que el número de renglones en un data frame, el vector es reciclado. Al utilizar vector c(FALSE, TRUE), nos serán devueltos el segundo y cuarto renglón de mi_df. mi_df[c(FALSE, TRUE), ] #&gt; nombre edad sexo grupo #&gt; 2 Elsa 24 M 1 #&gt; 4 Olga 30 H 0 Si proporcionamos una condición que no se cumple en ningún caso, es decir, devuelve un vector que consiste sólo de FALSE, el subconjunto que obtenemos es una data frame sin renglones. iris[iris$Species == &quot;oceanica&quot;, ] #&gt; [1] Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;0 rows&gt; (or 0-length row.names) Finalmente, si no escribimos una coma dentro del corchete después de la condicional, obtendremos un data frame sin columnas, que para fines prácticos es un objeto sin utilidad. iris[iris$Petal.Width &gt;= 5] #&gt; data frame with 0 columns and 150 rows 7.5.2 La función subset() Una alternativa para usar condicionales, sin necesidad de corchetes, es la función subset(). Esta función tiene los siguientes argumentos: x: Un objeto, generalmente un data frame. subset: Una condición, expresada como operaciones relacionales o condicionales, que se aplicarán a una columna de x. select: Un vector con los nombres de las columnas a conservar en el resultado. Si no asignamos un valor a este argumento, se nos devuelven todas las columnas de x. Puedes leer la documentación completa llamando ?subset. Como podrás ver, subset() necesita como argumentos los mismos elementos que usamos para extraer subconjuntos con corchetes. La principal diferencia se encuentra en el argumento subset. Al usar corchetes, necesitamos aplicar una operación relacional a un vector, extraído de nuestro objeto original, por ejemplo iris[iris$Species == \"setosa\", ]. Con subset(), basta proporcionar el nombre del elemento al que aplicaremos las operaciones relacionales y condicionales. Para este caso, escribimos Species == \"setosa\". Nota que el nombre de la columna está escrito sin comillas. Por ejemplo, para extraer de iris todos los datos en los que el largo del sépalo es mayor que 7.5, damos a iris como argumento x y Sepal.Lenght como argumento subset. Dejamos sin definir el argumento select, para obtener todas las columnas. subset(x = iris, subset = Sepal.Length &gt; 7.5) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 106 7.6 3.0 6.6 2.1 virginica #&gt; 118 7.7 3.8 6.7 2.2 virginica #&gt; 119 7.7 2.6 6.9 2.3 virginica #&gt; 123 7.7 2.8 6.7 2.0 virginica #&gt; 132 7.9 3.8 6.4 2.0 virginica #&gt; 136 7.7 3.0 6.1 2.3 virginica Obtenemos el mismo resultado que al llamar iris[iris.Sepal.Length &gt; 7.5, ]. Damos además c(\"Sepal.Length\", \"Species\") como argumento a select y con ello sólo nos serán devueltas las columnas con estos nombres. subset(x = iris, subset = Sepal.Length &gt; 7.5, select = c(&quot;Sepal.Length&quot;, &quot;Species&quot;)) #&gt; Sepal.Length Species #&gt; 106 7.6 virginica #&gt; 118 7.7 virginica #&gt; 119 7.7 virginica #&gt; 123 7.7 virginica #&gt; 132 7.9 virginica #&gt; 136 7.7 virginica Desde luego, esto es equivalente a llamar iris[iris.Sepal.Length &gt; 7.5, c(\"Sepal.Length\", \"Species\")]. También podemos usar operaciones lógicas para el argumento subset. Por ejemplo, los datos para los que el largo del sépalo sea mayor que 7.5 y el ancho del pétalo sea igual a 3. subset(x = iris, subset = Sepal.Length &gt; 7.5 &amp; Sepal.Width == 3) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 106 7.6 3 6.6 2.1 virginica #&gt; 136 7.7 3 6.1 2.3 virginica Si damos como argumento a subset una comparación con un nombre de columna no válido, obtenemos un error. subset(x = iris, subset = Sepal.Weight &gt; 7.5 ) #&gt; Error in eval(e, x, parent.frame()): objeto &#39;Sepal.Weight&#39; no encontrado Al igual que si usamos corchetes, si pedimos una condición que para ningún caso es verdadera, nuestro resultado es un data frame sin renglones. subset(x = iris, subset = Sepal.Length &gt; 9 ) #&gt; [1] Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;0 rows&gt; (or 0-length row.names) Si damos como argumento select el nombre de una columna inválida, también se nos devuelve un error. subset(x = iris, subset = Sepal.Length &gt; 7, select = &quot;Sepal.Weight&quot;) #&gt; Error in `[.data.frame`(x, r, vars, drop = drop): undefined columns selected Finalmente, también podemos dar un vector lógico como argumento subset para obtener subconjuntos. Por ejemplo, el segundo y cuarto renglón de mi_df. subset(x = mi_df, subset = c(TRUE, FALSE, FALSE, TRUE)) #&gt; nombre edad sexo grupo #&gt; 1 Armando 20 H 0 #&gt; 4 Olga 30 H 0 La función subset() casi siempre resulta en código más breve y es más fácil de interpretar por el usuario que los subconjuntos condicionales con corchetes. Sin embargo, la mayor parte de las veces, usar uno u otro procedimiento depende de tu preferencia personal y de las necesidades de los proyectos en los que colaboras. "],["8-funciones.html", "Capítulo 8 Funciones", " Capítulo 8 Funciones La instalación base de R tiene suficientes funciones para que realicemos todas las tareas básicas de análisis de datos, desde importar información hasta crear documentos para comunicarla (¡este libro ha sido creado con R!). Sin embargo, es común que necesitemos realizar tareas para las que no existe una función específica o que para encontrar solución necesitemos combinar o utilizar funciones en sucesión, lo cual puede complicar nuestro código. Ilustremos lo anterior con un ejemplo. "],["8-1-por-qué-necesitamos-crear-nuestrar-propias-funciones.html", "8.1 ¿Por qué necesitamos crear nuestrar propias funciones?", " 8.1 ¿Por qué necesitamos crear nuestrar propias funciones? Supongamos que tenemos un jefe que nos ha pedido crear un histograma con datos de edad que hemos recogido en una encuesta. Esto es sencillo de resolver pues contamos con la función hist() que hace exactamente esto. Sólo tenemos que dar un vector numérico como argumento para generar una gráfica (veremos esto con más detalle en el capítulo 12). Primero, generaremos datos aleatorios sacados de una distribución normal con la función rnorm(). Esta función tiene los siguientes argumentos: n: Cantidad de números a generar. mean: Media de la distribución de la que sacaremos nuestros números. sd: Desviación estándar de la distribución de la que sacaremos nuestros números. Además, llamaremos set.seed() para que estos resultados sean replicables. Cada que llamamos rnorm() se generan número aleatorios diferentes, pero si antes llamamos a set.seed(), con un número específico como argumento obtendremos los mismos resultados. Obtendremos 1500 números con media 15 y desviación estándar .75. set.seed(173) edades &lt;- rnorm(n = 1500, mean = 15, sd = .75) Veamos los primero diez números de nuestro objeto. edades[1:10] #&gt; [1] 15.79043 14.68603 16.29119 14.66079 15.25658 14.62890 14.87498 16.35364 #&gt; [9] 16.04607 16.35803 Ahora, sólo tenemos que ejecutar hist() con el argumento x igual a nuestro vector y obtendremos un histograma. # Histograma hist(x = edades) Estupendo. Hemos logrado nuestro objetivo. Nuestro jefe está satisfecho, pero le gustaría que en el histograma se muestre la media y desviación estándar de los datos, que tenga un título descriptivo y que los ejes estén etiquetados en español, además de que las barras sean de color dorado. Suena complicado, pero podemos calcular la media de los datos usando la función mean(), la desviación estándar con sd() y podemos agregar los resultados de este cálculo al histograma usando la función abline(). Para agregar título, etiquetas en español y colores al histograma sólo basta agregar los argumentos apropiados a la función hist(). No te preocupes mucho por los detalles de todo esto, lo veremos más adelante. Calculamos media y desviación estándar de nuestros datos. media &lt;- mean(edades) desv_est &lt;- sd(edades) Agregamos líneas con abline(), para la media de rojo y desviación estándar con azul. También ajustamos los argumentos de hist(). hist(edades, main = &quot;Edades&quot;, xlab = &quot;Datos&quot;, ylab = &quot;Frecuencia&quot;, col = &quot;gold&quot;) abline(v = media, col = &quot;red&quot;) abline(v = media + (desv_est * c(1, -1)), col = &quot;blue&quot;) Con esto nuestro jefe ahora sí ha quedado complacido. Tanto, que nos pide que hagamos un histograma igual para todas las variables numéricas de esa encuesta. Que son cincuenta en total. Para cumplir con esta tarea podríamos usar el código que ya hemos escrito. Simplemente lo copiamos y pegamos cincuenta veces, cambiando los valores para cada una de variables que nos han pedido. Pero hacer las cosas de este modo propicia errores y es difícil de corregir y actualizar. Para empezar, si copias el código anterior cincuenta veces, tendrás un script con más de 400 líneas. Si en algún momento te equivocas porque escribiste Enceusta en lugar de Encuesta, incluso con las herramientas de búsqueda de RStudio, encontrar donde está el error será una tarea larga y tediosa. Y si tu jefe en esta ejemplo quiere que agregues, quites o modifiques tu histograma, tendrás que hacer el cambio cincuenta veces, una para cada copia del código. De nuevo, con esto se incrementa el riesgo de que ocurran errores. Es en situaciones como esta en las que se hace evidente la necesidad de crear nuestras propias funciones, capaces de realizar una tarea específica a nuestros problemas, y que pueda usarse de manera repetida. Así reducimos errores, facilitamos hacer correcciones o cambios y nos hacemos la vida más fácil, a nosotros y a quienes usen nuestro código después. "],["8-2-funciones-definidas-por-el-usuario.html", "8.2 Funciones definidas por el usuario", " 8.2 Funciones definidas por el usuario Una función tiene un nombre, argumentos y un cuerpo. Las funciones definidas por el usuario son creadas usando la siguiente estructura. nombre &lt;- function(argumentos) { operaciones } Cuando asignamos una función a un nombre decimos que hemos definido una función. El nombre que asignamos a una función nos permite ejecutarla y hacer referencias a ella. Podemos asignar la misma función a diferentes nombres o cambiar una función a la que ya le hemos asignado un nombre. Es recomendable elegir nombres claros, no ambiguos y descriptivos. Una vez que la función tiene nombre, podemos llamarla usando su nombre, al igual que con las funciones por defecto de R. Los argumentos son las variables que necesita la función para realizar sus operaciones. Aparecen entre paréntesis, separados por comas. Los valores son asignados al nombre del argumento por el usuario cada vez que ejecuta una función. Esto permite que usemos nuestras funciones en distintas situaciones con diferentes datos y especificaciones. Los argumentos pueden ser datos, estructuras de datos, conexiones a archivos u otras funciones y todos deben tener nombres diferentes. El cuerpo de la función contiene, entre llaves, todas las operaciones que se ejecutarán cuando la función sea llamada. El cuerpo de una función puede ser tan sencillo o complejo como nosotros deseemos, incluso podemos definir funciones dentro de una función (y definir funciones dentro de una función dentro de otra función, aunque esto se vuelve confuso rápidamente). Si el código del cuerpo de la función tiene errores, sus operaciones no se realizarán y nos será devuelto un mensaje de error al ejecutarla. R no avisa si nuestra función va a funcionar o no hasta que intentamos correrla. Una ventaja de usar RStudio es que nos indica errores de sintaxis en nuestro código, lo cual puede prevenir algunos errores. Sin embargo, hay alguno que no detecta, como realizar operaciones o coerciones imposibles. Para ver esto en acción, crearemos una función sencilla para obtener el área de un cuadrilátero. "],["8-3-nuestra-primera-función.html", "8.3 Nuestra primera función", " 8.3 Nuestra primera función Partimos del algoritmo para calcular el área de un cuadrilátero: lado x lado. Podemos convertir esto a operaciones de R y asignarlas a una función llamada area_cuad de la siguiente manera: area_cuad &lt;- function(lado1, lado2) { lado1 * lado2 } Las partes de nuestra función son: Nombre: area_cuad. Argumentos: lado1, lado2. Estos son los datos que necesita la función para calcular el área, representan el largo de los lados de un cuadrilátero. Cuerpo: La operación lado1 * lado2, escrita de manera que R pueda interpretarla. Ejecutaremos nuestra función para comprobar que funciona. Nota que lo único que hacemos cada que la llamamos es cambiar la medida de los lados del cuadrilátero para el que calcularemos un área, en lugar de escribir la operación lado1 * lado2 en cada ocasión. area_cuad(lado1 = 4, lado2 = 6) #&gt; [1] 24 area_cuad(lado1 = 36, lado2 = 36) #&gt; [1] 1296 En cada llamada a nuestra función estamos asignando valores distintos a los argumentos usando el signo de igual. Si no asignamos valores a un argumento, se nos mostrará un error area_cuad(lado1 = 14) #&gt; Error in area_cuad(lado1 = 14): el argumento &quot;lado2&quot; está ausente, sin valor por omisión En R, podemos especificar los argumentos por posición. El orden de los argumentos se determina cuando creamos una función. En este caso, nosotros determinamos que el primer argumento que recibe area_cuad es lado1 y el segundo es lado2. Así, podemos escribir lo siguiente y obtener el resultado esperado. area_cuad(128, 64) #&gt; [1] 8192 Esto es equivalente a escribir lado1 = 128, lado2 = 64 como argumentos. Podemos crear ahora una función ligeramente más compleja para calcular el volumen de un prisma rectangular Siguiendo la misma lógica de transformar un algoritmo a código de R, podemos crear una función con el algoritmo: arista x arista x arista. Definimos la función area_prisma(). area_prisma &lt;- function(arista1, arista2, arista3) { arista1 * arista2 * arista3 } Probemos nuestra función. area_prisma(arista1 = 3, arista2 = 6, arista3 = 9) #&gt; [1] 162 También podríamos escribir esta función aprovechando nuestra función area_cuad. area_prisma &lt;- function(arista1, arista2, arista3) { area_cuad(arista1, arista2) * arista3 } # Probemos la función area_prisma(3, 6, 9) #&gt; [1] 162 Con esto estamos listos para definir una función para crear histogramas con las características que nos pidió nuestro jefe hipotético. "],["8-4-definiendo-la-función-crear-histograma.html", "8.4 Definiendo la función crear_histograma()", " 8.4 Definiendo la función crear_histograma() Definiremos una función con el nombre crear_histograma() para generar un gráfico con las especificaciones que se nos han pedido. Partimos de una función sin argumentos y el cuerpo vacío. crear_histograma &lt;- function() { } Para que esta función realice lo que deseamos necesitamos: Los datos que serán graficados. El nombre de la variable graficada Por lo tanto, nuestros argumentos serán: datos nombre crear_histograma &lt;- function(datos, nombre) { } Ya sabemos las operaciones realizaremos, sólo tenemos que incluirlas al cuerpo de nuestro función. Reemplazaremos las variables que hacen referencia a un objeto en particular por el nombre de nuestros argumentos. De esta manera será generalizable a otros casos. En este ejemplo, cambiamos la referencia a la variable edades por referencias al argumento datos y la referencia a Edades, que usaremos como título del histograma, por una referencia al argumento nombre. crear_histograma &lt;- function(datos, nombre) { media &lt;- mean(datos) desv_est &lt;- sd(datos) hist(datos, main = nombre, xlab = &quot;Datos&quot;, ylab = &quot;Frecuencia&quot;, col = &quot;gold&quot;) abline(v = media, col = &quot;red&quot;) abline(v = media + (desv_est * c(1, -1)), col = &quot;blue&quot;) } Probemos nuestra función usando datos distintos, generados de manera similar a las edades, con la función rnorm(). Generaremos datos de ingreso, con una media igual a 15000 y una desviación estándar de 4500. ingreso &lt;- rnorm(1500, mean = 15000, sd = 4500) # Resultado ingreso[1:10] #&gt; [1] 14365.18 16621.70 13712.35 21796.08 14226.73 13830.29 22187.37 17879.22 #&gt; [9] 11040.41 17923.13 Corremos nuestra función. crear_histograma(ingreso, &quot;Ingreso&quot;) Luce bien. Probemos ahora con datos sobre el peso de las personas. siguiendo el mismo procedimiento. peso &lt;- rnorm(75, mean = 60, sd = 15) crear_histograma(peso, &quot;Peso&quot;) Las funciones definidas por el usuario pueden devolvernos errores. Por ejemplo, si introducimos datos que no son apropiados para las operaciones a realizar, nuestra función no se ejecutará correctamente. crear_histograma(&quot;Cuatro&quot;, ingreso) #&gt; Error in hist.default(datos, main = nombre, xlab = &quot;Datos&quot;, ylab = &quot;Frecuencia&quot;, : &#39;x&#39; must be numeric Por esta razón es importante crear documentación para las funciones que hayas creado. Puede ser tan sencilla como una explicación de qué hace la función y qué tipo de datos necesita para realizar sus operaciones. La primera persona beneficiada por esto eres tu, pues tu yo de un mes en el futuro puede haber olvidado por completo la lógica de una función específica, así que la documentación es una manera de recordar tu trabajo. Una manera simple de documentar tus funciones es con comentarios. # crear_histograma # Devuelve un histograma con lineas indicando la media y desviación estándar de un vector de datos numérico # Argumentos: # - datos: Un vector numérico. # - nombre: Una cadena de texto. 8.4.1 Ejecutando Ahora, podremos cumplir con la solicitud de nuestro jefe ficticio usando cincuenta llamadas a una función en lugar de correr más de cuatrocientas líneas de código y que hemos reducido la probabilidad de cometer errores. Además, si a nuestro jefe se le ocurren nuevas características para los histogramas, basta con cambiar el cuerpo de nuestra función una vez y esto se verá reflejado en nuestro cincuenta casos al correr de nuevo el código. Por ejemplo, supongamos que nuestro jefe también quiere que el histograma muestre la mediana de nuestros datos y que las barras sean de color naranja. Basta con hacer un par de cambios. crear_histograma &lt;- function(datos, nombre) { media &lt;- mean(datos) desv_est &lt;- sd(datos) mediana &lt;- median(datos) hist(datos, main = nombre, xlab = &quot;Datos&quot;, ylab = &quot;Frecuencia&quot;, col = &quot;orange&quot;) abline(v = media, col = &quot;red&quot;) abline(v = media + (desv_est * c(1, -1)), col = &quot;blue&quot;) abline(v = mediana, col = &quot;green&quot;) } # Resultado crear_histograma(peso, &quot;Peso con mediana&quot;) Quizás estés pensando que escribir una función cincuenta veces de todos modos es demasiada repetición y aún se presta a cometer errores. Lo cual es cierto, pero podemos hacer más breve nuestro código y menos susceptible a equivocaciones con la familia de funciones apply, que revisaremos en el capítulo 10. "],["9-estructuras-de-control.html", "Capítulo 9 Estructuras de control", " Capítulo 9 Estructuras de control Como su nombre lo indica, las estructuras de control nos permiten controlar la manera en que se ejecuta nuestro código. Las estructuras de control establecen condicionales en nuestros código. Por ejemplo, qué condiciones deben cumplirse para realizar una operación o qué debe ocurrir para ejecutar una función. Esto es de gran utilidad para determinar la lógica y el orden en que ocurren las operaciones, en especial al definir funciones. Las estructuras de control más usadas en R son las siguientes. Estructura de control Descripción if, else Si, de otro modo for Para cada uno en while Mientras break Interrupción next Siguiente "],["9-1-if-else.html", "9.1 if, else", " 9.1 if, else if (si) es usado cuando deseamos que una operación se ejecute únicamente cuando una condición se cumple. else (de otro modo) es usado para indicarle a R qué hacer en caso de la condición de un if no se cumpla. Un if es la manera de decirle a R: SI esta condición es cierta, ENTONCES haz estas operaciones. El modelo para un if es: if(Condición) { operaciones_si_la_condición_es_TRUE } Si la condición se cumple, es decir, es verdadera (TRUE), entonces se realizan las operaciones. En caso contrario, no ocurre nada y el código con las operaciones no es ejecutado. Por ejemplo, le pedimos a R que nos muestre el texto Verdadero si la condición se cumple. # Se cumple la condición y se muestra &quot;verdadero&quot; if(4 &gt; 3) { &quot;Verdadero&quot; } #&gt; [1] &quot;Verdadero&quot; # No se cumple la condición y no pasa nada if(4 &gt; 5) { &quot;Verdadero&quot; } else complementa un if, pues indica qué ocurrirá cuando la condición no se cumple, es falsa (FALSE), en lugar de no hacer nada. Un if con else es la manera de decirle a R: SI esta condición es es cierta, ENTONCES haz estas operaciones, DE OTRO MODO haz estas otras operaciones. El modelo para un if con un else es: if(condición) { operaciones_si_la_condición_es_TRUE } else { operaciones_si_la_condición_es_FALSE } Usando los ejemplos anteriores, podemos mostrar Falso si no se cumple la condición, en lugar de que no ocurra nada. # Se cumple la condición y se muestra &quot;Verdadero&quot; if(4 &gt; 3) { &quot;Verdadero&quot; } else { &quot;Falso&quot; } #&gt; [1] &quot;Verdadero&quot; # No se cumple la condición y se muestra &quot;Falso&quot; if(4 &gt; 5) { &quot;Verdadero&quot; } else { &quot;Falso&quot; } #&gt; [1] &quot;Falso&quot; 9.1.1 Usando if y else Para ilustrar el uso de if else definiremos una función que calcule el promedio de calificaciones de un estudiante y, dependiendo de la calificación calculada, nos devuelva un mensaje específico. Empezamos definiendo una función para calcular promedio. En realidad, sólo es la aplicación de la función mean() ya existente en R base, pero la ampliaremos después. promedio &lt;- function(calificaciones) { mean(calificaciones) } promedio(c(6, 7, 8, 9, 8)) #&gt; [1] 7.6 promedio(c(5, 8, 5, 6, 5)) #&gt; [1] 5.8 Ahora deseamos que esta función nos muestre si un estudiante ha aprobado o no. Si asumimos que un estudiante necesita obtener 6 o más de promedio para aprobar, podemos decir que: SI el promedio de un estudiante es igual o mayor a 6, ENTONCES mostrar Aprobado, DE OTRO MODO, mostrar Reprobado. Aplicamos esta lógica con un if, else en la función promedio(). promedio &lt;- function(calificaciones) { media &lt;- mean(calificaciones) if(media &gt;= 6) { print(&quot;Aprobado&quot;) } else { print(&quot;Reprobado&quot;) } } Probemos nuestra función promedio(c(6, 7, 8, 9, 8)) #&gt; [1] &quot;Aprobado&quot; promedio(c(5, 8, 5, 6, 5)) #&gt; [1] &quot;Reprobado&quot; Está funcionando, aunque los resultados podrían tener una mejor presentación. Usaremos la función paste0() para pegar el promedio de calificaciones, como texto, con el resultado de Aprobado o Reprobado. Esta función acepta como argumentos cadenas de texto y las pega (concatena) entre sí, devolviendo como resultado una nueva cadena. Primero concatenaremos la palabra Calificación: a la media obtenida con la función promedio() y después el resultado de esta operación con la palabra aprobado o reprobado, según corresponda. promedio &lt;- function(calificaciones) { media &lt;- mean(calificaciones) texto &lt;- paste0(&quot;Calificación: &quot;, media, &quot;, &quot;) if(media &gt;= 6) { print(paste0(texto, &quot;aprobado&quot;)) } else { print(paste0(texto, &quot;reprobado&quot;)) } } Pongamos a prueba nuestra función. promedio(c(6, 7, 8, 9, 8)) #&gt; [1] &quot;Calificación: 7.6, aprobado&quot; promedio(c(5, 8, 5, 6, 5)) #&gt; [1] &quot;Calificación: 5.8, reprobado&quot; Por supuesto, como lo vimos en el capítulo sobre funciones, podemos hacer aún más compleja a promedio(), pero esto es suficiente para conocer mejor las aplicaciones de if else. 9.1.2 ifelse La función ifelse( ) nos permite vectorizar if, else. En lugar de escribir una línea de código para cada comparación, podemos usar una sola llamada a esta función, que se aplicará a todos los elementos de un vector. Si intentamos usar if else con un vector, se nos mostrará una advertencia. if(1:10 &lt; 3) { &quot;Verdadero&quot; } #&gt; [1] &quot;Verdadero&quot; Este mensaje nos dice que sólo se usará el primer elemento del vector para evaluar su la condición es verdadera y lo demás será ignorado. En cambio, con ifelse se nos devolverá un valor para cada elemento de un vector en el que la condición sea TRUE, además nos devolverá otro valor para los elementos en que la condición sea FALSE. Esta función tiene la siguiente forma. ifelse(vector, valor_si_TRUE, valor_si_FALSE) Si intentamos el ejemplo anterior con ifelse(), se nos devolverá un resultado para cada elemento del vector, no sólo del primero de ellos. #&gt; [1] &quot;Verdadero&quot; &quot;Verdadero&quot; &quot;Falso&quot; &quot;Falso&quot; &quot;Falso&quot; &quot;Falso&quot; #&gt; [7] &quot;Falso&quot; &quot;Falso&quot; &quot;Falso&quot; &quot;Falso&quot; De este modo podemos usar ifelse() para saber si los números en un vector son pares o nones. num &lt;- 1:8 ifelse(num %% 2 == 0, &quot;Par&quot;, &quot;Non&quot;) #&gt; [1] &quot;Non&quot; &quot;Par&quot; &quot;Non&quot; &quot;Par&quot; &quot;Non&quot; &quot;Par&quot; &quot;Non&quot; &quot;Par&quot; También tenemos la opción de crear condiciones más complejas usando operadores Booleanos. Por ejemplo, pedimos sólo los números que son exactamente divisibles entre 2 y 3. num &lt;- 1:20 ifelse(num %% 2 == 0 &amp; num %% 3, &quot;Divisible&quot;, &quot;No divisible&quot;) #&gt; [1] &quot;No divisible&quot; &quot;Divisible&quot; &quot;No divisible&quot; &quot;Divisible&quot; &quot;No divisible&quot; #&gt; [6] &quot;No divisible&quot; &quot;No divisible&quot; &quot;Divisible&quot; &quot;No divisible&quot; &quot;Divisible&quot; #&gt; [11] &quot;No divisible&quot; &quot;No divisible&quot; &quot;No divisible&quot; &quot;Divisible&quot; &quot;No divisible&quot; #&gt; [16] &quot;Divisible&quot; &quot;No divisible&quot; &quot;No divisible&quot; &quot;No divisible&quot; &quot;Divisible&quot; Desde luego, esto es particularmente útil para recodificar datos. num &lt;- c(0, 1, 0, 0, 0, 1, 1) num &lt;- ifelse(num == 0, &quot;Hombre&quot;, &quot;Mujer&quot;) num #&gt; [1] &quot;Hombre&quot; &quot;Mujer&quot; &quot;Hombre&quot; &quot;Hombre&quot; &quot;Hombre&quot; &quot;Mujer&quot; &quot;Mujer&quot; "],["9-2-for.html", "9.2 for", " 9.2 for La estructura for nos permite ejecutar un bucle (loop), realizando una operación para cada elemento de un conjunto de datos. Su estructura es la siguiente: for(elemento in objeto) { operacion_con_elemento } Con lo anterior le decimos a R: PARA cada elemento EN un objeto, haz la siguiente operación. Al escribir un bucle for la parte que corresponde al elemento la podemos llamar como nosotros deseemos, pero la parte que corresponde al objeto debe ser el nombre de un objeto existente. Los dos bucles siguientes son equivalentes, sólo cambia el nombre que le hemos puesto al elemento. objeto &lt;- 1:10 for(elemento in objeto) { operacion_con_elemento } for(i in objeto) { operacion_con_elemento } Tradicionalmente se usa la letra i para denotar al elemento, pero nosotros usaremos nombres más descriptivos en este capítulo. 9.2.1 Usando for Vamos a obtener el cuadrado de cada uno de los elementos en un vector numérico del 1 al 6, que representa las caras de un dado. dado &lt;- 1:6 for(cara in dado) { dado ^ 2 } Notarás que al ejecutar el código anterior parece que no ha ocurrido nada. En realidad, sí se han realizado las operaciones, pero R no ha devuelto sus resultados. Las operaciones en un for se realizan pero sus resultados nunca son devueltos automáticamente, es necesario pedirlos de manera explícita. A diferencia de otros lenguajes de programación en los que pedimos los resultados de un bucle con return(), en R este procedimiento sólo funciona con funciones. Una solución para mostrar los resultados de un bucle for es usar la función print(). for(cara in dado) { print(cara ^ 2) } #&gt; [1] 1 #&gt; [1] 4 #&gt; [1] 9 #&gt; [1] 16 #&gt; [1] 25 #&gt; [1] 36 Comprobamos que la operación ha sido realizada a cada elemento de nuestro objeto. Sin embargo, usar print() sólo mostrará los resultados de las operaciones en la consola, no los asignará a un objeto. Si deseamos asignar los resultados de un bucle for a un objeto, usamos índices. Aprovechamos que el primer elemento en un bucle siempre es identificado con el número 1 y que continuará realizando operaciones hasta llegar al total de elementos que hemos especificado. for(numero in 1:10) { print(numero) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 #&gt; [1] 10 En nuestro ejemplo, pasamos por los valores de dado, cara por cara. La primera cara será igual a 1, la segunda a 2, y así sucesivamente hasta el 6. Podemos usar estos valores para asignar cada valor resultante de nuestras operaciones a una posición específica en un vector, incluso si este está vacío. Creamos un vector vacío, asignándole como NULL como valor. mi_vector &lt;- NULL Ejecutamos nuestro bucle. for(cara in dado) { mi_vector[cara] &lt;- cara ^ 2 } Aunque no fueron mostrados en la consola, los resultados han sido asignados al objeto mi_vector. mi_vector #&gt; [1] 1 4 9 16 25 36 9.2.2 for y vectorización Notarás que el resultado que obtuvimos usando for es el mismo que si vectorizamos la operación. dado ^ 2 #&gt; [1] 1 4 9 16 25 36 Dado que en R contamos con vectorización de operaciones, que podemos usar las funciones de la familia apply (discutido en siguiente capítulo) en objetos diferentes a vectores y que la manera de recuperar los resultados de un for es un tanto laboriosa, este tipo de bucle no es muy popular en R. En R generalmente hay opciones mejores, en cuanto a simplicidad y velocidad de cómputo, que un bucle for. Sin embargo, es conveniente que conozcas esta estructura de control, pues hay ocasiones en la que es la mejor herramienta para algunos problemas específicos. "],["9-3-while.html", "9.3 while", " 9.3 while Este es un tipo de bucle que ocurre mientras una condición es verdadera (TRUE). La operación se realiza hasta que se se llega a cumplir un criterio previamente establecido. El modelo de while es: while(condicion) { operaciones } Con esto le decimos a R: MIENTRAS esta condición sea VERDADERA, haz estas operaciones. La condición generalmente es expresada como el resultado de una o varias operaciones de comparación, pero también puede ser el resultado de una función. 9.3.1 Usando while Probemos sumar +1 a un valor, mientras que este sea menor que 5. Al igual que con for, necesitamos la función print() para mostrar los resultados en la consola. umbral &lt;- 5 valor &lt;- 0 while(valor &lt; umbral) { print(&quot;Todavía no.&quot;) valor &lt;- valor + 1 } #&gt; [1] &quot;Todavía no.&quot; #&gt; [1] &quot;Todavía no.&quot; #&gt; [1] &quot;Todavía no.&quot; #&gt; [1] &quot;Todavía no.&quot; #&gt; [1] &quot;Todavía no.&quot; ¡Ten cuidado con crear bucles infinitos! Si ejecutas un while con una condición que nunca será FALSE, este nunca se detendrá. Si corres lo siguiente, presiona la tecla ESC para detener la ejecución, de otro modo, correrá por siempre y puede llegar a congelar tu equipo. while(1 &lt; 2) { print(&quot;Presiona ESC para detener&quot;) } El siguiente es un error común. Estamos sumando 1 a i con cada iteración del bucle, pero como no estamos asignando este nuevo valor a i, su valor se mantiene igual, entonces la condición nunca se cumplirá y el bucle será infinito. De nuevo, si corres lo siguiente, presiona la tecla ESC para detener la ejecución. i &lt;- 0 while(i &lt; 10) { i + 1 } Un uso común de while es que realice operaciones que queremos detener cuando se cumple una condición, pero desconocemos cuándo ocurrirá esto. Supongamos que, por alguna razón queremos sumar calificaciones, del 1 al 10 al azar, hasta llegar a un número que mayor o igual a 50. Además nos interesa saber cuántas calificaciones sumaron y cuál fue el resultado al momento de cumplir la condición. Para obtener números al azar del 1 al 10, usamos la función sample(). Esta función va a tomar una muestra al azar de tamaño igual a 1 (argumento size) de un vector del 1 al 10 (argumento x) cada vez que se ejecute. Por lo tanto, cada vez que corras el ejemplo siguiente obtendrás un resultado distinto, pero siempre llegarás a un valor mayor a 50. Creamos dos objetos, conteo y valor. Les asignamos el valor 0. conteo &lt;- 0 valor &lt;- 0 Nuestro while hará dos cosas. Primero, tomará un número al azar del 1 al 10, y lo sumará a valor. Segundo, le sumará 1 a conteo cada que esto ocurra, de esta manera sabremos cuántas iteraciones ocurrieron para llegar a un valor que no sea menor a 50. while(valor &lt; 50) { valor &lt;- valor + sample(x = 1:10, size = 1) conteo &lt;- conteo + 1 } Aunque no son mostrados en la consola los resultados son asignados a los objetos valory conteo valor #&gt; [1] 51 conteo #&gt; [1] 8 Por último, si intentamos ejecutar un while para el que la condición nunca es igual a TRUE, este no realizará ninguna operación. conteo &lt;- 0 while(&quot;dado&quot; == &quot;ficha&quot;) { conteo &lt;- conteo + 1 } conteo #&gt; [1] 0 "],["9-4-break-y-next.html", "9.4 break y next", " 9.4 break y next break y next son palabras reservadas en R, no podemos asignarles nuevos valores y realizan una operación específica cuando aparecen en nuestro código. break nos permite interrumpir un bucle, mientras que next nos deja avanzar a la siguiente iteración del bucle, saltándose la actual. Ambas funcionan para for y while. 9.4.1 Usando break Para interrumpir un bucle con break, necesitamos que se cumpla una condición. Cuando esto ocurre, el bucle se detiene, aunque existan elementos a los cuales aún podría aplicarse. Interrumpimos un for cuando i es igual a 3, aunque aún queden 7 elementos en el objeto. for(i in 1:10) { if(i == 3) { break } print(i) } #&gt; [1] 1 #&gt; [1] 2 Interrumpimos un while antes de se cumpla la condición de que numero sea mayor a 5, en cuanto este tiene el valor de 15. numero &lt;- 20 while(numero &gt; 5) { if(numero == 15) { break } numero &lt;- numero - 1 } numero #&gt; [1] 15 Como habrás notado, la aplicación de break es muy similar a while, realizar una operación hasta que se cumple una condición, y ambos pueden usarse en conjunto. 9.4.2 Usando next Por su parte, usamos next para saltarnos una iteración en un bucle. Cuando la condición se cumple, esa iteración es omitida. for(i in 1:4) { if(i == 3) { next } print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 4 Estas dos estructuras de control nos dan un control fino sobre nuestro código. aunque los dos ejemplos de arriba son con for, también funcionan con while y repeat. En realidad, break es indispensable para repeat. "],["9-5-repeat.html", "9.5 repeat", " 9.5 repeat Este es un bucle que se llevará a cabo el número de veces que especifiquemos, usando un break para detenerse. repeat asegura que las operaciones que contiene sean iteradas al menos en una ocasión. La estructura de repeat es el siguiente: repeat { operaciones un_break_para_detener } Si no incluimos un break, el bucle se repetirá indefinidamente y sólo lo podremos detener pulsando la tecla ESC, así que hay que tener cuidado al usar esta estructura de control. Por ejemplo, el siguiente repeat sumará +1 a valor hasta que este sea igual a cinco, entonces se detendrá. valor &lt;- 0 mi_vector &lt;- NULL repeat{ valor &lt;- valor + 1 if(valor == 5) { break } } # Resultado valor #&gt; [1] 5 Este tipo de bucle es quizás el menos utilizado de todos, pues en R existen alternativas para obtener los mismos resultados de manera más sencilla y sin el riesgo de crear un bucle infinito. Sin embargo, puede ser la mejor alternativa para problemas específicos. "],["10-la-familia-apply.html", "Capítulo 10 La familia apply", " Capítulo 10 La familia apply La familia de funciones apply es usada para aplicar una función a cada elemento de una estructura de datos. En particular, es usada para aplicar funciones en matrices, data frames, arrays y listas. Con esta familia de funciones podemos automatizar tareas complejas usando poca líneas de código y es una de las características distintivas de R como lenguaje de programación. La familia de funciones apply es una expresión de los rasgos del paradigma funcional de programación presentes en R. Sobre esto no profundizaremos demasiado, pero se refiere saber que en R las funciones son ciudadanos de primera, con la misma importancia que los objetos, y por lo tanto, operamos en ellas. La familia de funciones apply no sólo recibe datos como argumentos, también recibe funciones. 10.0.1 Un recordatorio sobre vectorización Para entender más fácilmente el uso de la familia 0, recordemos la vectorización de operaciones. Hay operaciones que, si las aplicamos a un vector, son aplicadas a todos sus elementos. mi_vector &lt;- 1:10 mi_vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 mi_vector ^ 2 #&gt; [1] 1 4 9 16 25 36 49 64 81 100 Lo anterior es, generalmente, preferible a escribir una operación para cada elemento o a usar un bucle for, como se describió en el capítulo sobre estructuras de control. Como todo lo que ocurre en R es una función, podemos decir que al vectorizar estamos aplicando una función a cada elemento de un vector. La familia de funciones apply nos permite implementar esto en estructuras de datos distintas a los vectores. 10.0.2 Las funciones de la familia apply La familia apply esta formada por las siguientes funciones: apply() eapply() lapply() mapply() rapply() sapply() tapply() vapply() Es una familia numerosa y esta variedad de funciones se debe a que varias de ellas tienen aplicaciones sumamente específicas. Todas las funciones de esta familia tienen una característica en común: reciben como argumentos a un objeto y al menos una función. Hasta ahora, todas las funciones que hemos usado han recibido como argumentos estructuras de datos, sean vectores, data frames o de otro tipo. Las funciones de la familia apply tienen la particularidad que pueden recibir a otra función como un argumento. Lo anterior puede sonar confuso, pero es más bien intuitivo al verlo implementado. Nosotros trabajaremos con las funciones más generales y de uso común de esta familia: apply() lapply() Estas dos funciones nos permitirán solucionar casi todos los problemas a los que nos encontremos. Además, conociendo su uso, las demás funciones de la familia apply serán relativamente fáciles de entender. "],["10-1-apply.html", "10.1 apply", " 10.1 apply apply aplica una función a todos los elementos de una matriz. La estructura de esta función es la siguiente. apply(X, MARGIN, FUN) apply tiene tres argumentos: X: Una matriz o un objeto que pueda coercionarse a una matriz, generalmente, un data frame. MARGIN: La dimensión (margen) que agrupará los elementos de la matriz X, para aplicarles una función. Son identificadas con números, 1 son renglones y 2 son columnas. FUN: La función que aplicaremos a la matriz X en su dimensión MARGIN. 10.1.1 ¿Qué es X X es una matriz o cualquier otro objeto que sea posible coercionar a una matriz. Esto es, principalmente, vectores y data frames. Recuerda que puedes coercionar objetos a matriz usando as.matrix() y puedes comprobar si un objeto es de esta clase con is.matrix(). # Creamos un data frame mi_df &lt;- data.frame(v1 = 1:3, v2 = 4:6) mi_df #&gt; v1 v2 #&gt; 1 1 4 #&gt; 2 2 5 #&gt; 3 3 6 # Coerción a matriz mi_matriz &lt;- as.matrix(mi_df) # Verificamos que sea matriz is.matrix(mi_matriz) #&gt; [1] TRUE # Resultado mi_matriz #&gt; v1 v2 #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 Aunque también podemos coercionar listas y arrays a matrices, los resultados que obtenemos no siempre son apropiados para apply(), por lo que no es recomendable usar estos objetos como argumentos. 10.1.2 ¿Qué es MARGIN? Recuerda que las matrices y los data frames están formadas por vectores y que estas estructuras tienen dos dimensiones, ordenadas en renglones y columnas. Esto lo vimos en en Matrices y arrays y Data frames. Para MARGIN: 1 es renglones. 2 es columnas. Por ejemplo, podemos usar apply() para obtener la sumatoria de los elementos de una matriz, por renglón. Creamos una matriz de cuatro renglones. matriz &lt;- matrix(1:14, nrow = 4) Aplicamos apply(), dando la función sum() el argumento FUN, nota que sólo necesitamos el nombre de la función, sin paréntesis. Por último, damos el argumento MARGIN = 1, para aplicar la función por renglón. apply(X = matriz, MARGIN = 1, FUN = sum) #&gt; [1] 28 32 22 26 Esto es equivalente a hacer lo siguiente. sum(matriz[1, ]) #&gt; [1] 28 sum(matriz[2, ]) #&gt; [1] 32 sum(matriz[3, ]) #&gt; [1] 22 sum(matriz[4, ]) #&gt; [1] 26 Y naturalmente, es equivalente a hacer lo siguiente. sum(vector_1) #&gt; [1] NA sum(vector_2) #&gt; [1] NA sum(vector_3) #&gt; [1] 15 sum(vector_4) #&gt; [1] 58 Estamos aplicando una función a cada elemento de nuestra matriz. Los elementos son los renglones. Cada renglón es un vector. Cada vector es usado como argumento de la función. Si cambiamos el argumento MARGIN de MARGIN = 1 a MARGIN = 2, entonces la función se aplicará por columna. apply(X = matriz, MARGIN = 2, FUN = sum) #&gt; [1] 10 26 42 30 En este caso, la función sum() ha sido aplicado a cada elementos de nuestra matriz, los elementos son las columnas, y cada columna es un vector. 10.1.3 ¿Qué es FUN? FUN es un argumento que nos pide el nombre de una función que se se aplicarla a todos los elementos de nuestra matriz. El ejemplo de la sección anterior aplicamos las funciones mean() y sum() usando sus nombres, sin paréntesis, esto es, sin especificar argumentos. Podemos dar como argumento cualquier nombre de función, siempre y cuando ésta acepte vectores como argumentos. Probemos cambiando el argumento FUN. Usaremos la función mean() para obtener la media de cada renglón y de cada columna. Aplicado a los renglones. apply(matriz, 1, mean) #&gt; [1] 7.0 8.0 5.5 6.5 Aplicado a las columnas apply(matriz, 2, mean) #&gt; [1] 2.5 6.5 10.5 7.5 Las siguientes llamadas a sd(), max() y quantile() se ejecutan sin necesidad de especificar argumentos. # Desviación estándar apply(matriz, 1, FUN = sd) #&gt; [1] 5.163978 5.163978 4.434712 4.434712 # Máximo apply(matriz, 1, FUN = max) #&gt; [1] 13 14 11 12 # Cuantiles apply(matriz, 1, FUN = quantile) #&gt; [,1] [,2] [,3] [,4] #&gt; 0% 1 2 1.0 2.0 #&gt; 25% 4 5 2.5 3.5 #&gt; 50% 7 8 5.0 6.0 #&gt; 75% 10 11 8.0 9.0 #&gt; 100% 13 14 11.0 12.0 10.1.4 ¿Cómo sabe FUN cuáles son sus argumentos? Recuerda que podemos llamar una función y proporcionar sus argumentos en orden, tal como fueron establecidos en su definición. Por lo tanto, el primer argumento que espera la función, será la X del apply(). Para ilustrar esto, usaremos la función quantile(). Llama ?quantile en la consola para ver su documentación. ?quantile quantile() espera siempre un argumento x, que debe ser un vector numérico, además tener varios argumentos adicionales. probs es un vector numérico con las probabilidades de las que queremos extraer cuantiles. na.rm, si le asignamos TRUE quitará de x los NA y NaN antes de realizar operaciones. names, si le asignamos TRUE, hará que el objeto resultado de la función tenga nombres. type espera un valor entre 1 y 9, para determinar el algoritmo usado para el cálculo de los cuantiles. En orden, el primer argumento es x, el segundo probs, y así sucesivamente. Cuando usamos quantile() en un apply(), el argumento x de la función será cada elemento de nuestra matriz. Es decir, los vectores como renglones o columnas de los que está constituida la matriz. Esto funcionará siempre y cuando los argumentos sean apropiados para la función. Si proporcionamos un argumento inválido, la función no se ejecutará y apply fallará. Por ejemplo, intentamos obtener cuantiles de las columnas de una matriz, en la que una de ellas es de tipo carácter. Creamos una matriz. matriz2 &lt;- matrix(c(1:2, &quot;a&quot;, &quot;b&quot;), nrow = 2) # Resultado Aplicamos la función y obtenemos un error. apply(matriz2, 2, quantile) #&gt; Error in (1 - h) * qs[i]: argumento no-numérico para operador binario Por lo tanto, apply sólo puede ser usado con funciones que esperan vectores como argumentos. 10.1.5 ¿Qué pasa si deseamos utilizar los demás argumentos de una función con apply? En los casos en los que una función tiene recibe más de un argumento, asignamos los valores de estos del nombre de la función, separados por comas, usando sus propios nombres (a este procedimiento es al que se refiere el argumento ... descrito en la documentación de apply). Supongamos que deseamos encontrar los cuantiles de un vector, correspondientes a las probabilidades .33 y .66. Esto es definido con el argumento probs de esta función. Para ello, usamos quantile() y después de haber escrito el nombre de la función, escribimos el nombre del argumento probs y los valores que deseamos para este. apply(X = matriz, MARGIN = 2, FUN = quantile, probs = c(.33, .66)) #&gt; [,1] [,2] [,3] [,4] #&gt; 33% 1.99 5.99 9.99 1.99 #&gt; 66% 2.98 6.98 10.98 12.78 Como podrás ver, hemos obtenido los resultados esperados. Si además deseamos que el resultado aparezca sin nombres, entonces definimos el valor del argumento names de la misma manera. apply(matriz, 2, quantile, probs = c(.33, .66), names = FALSE) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1.99 5.99 9.99 1.99 #&gt; [2,] 2.98 6.98 10.98 12.78 De este modo es posible aplicar funciones complejas que aceptan múltiples argumentos, con la ventaja que usamos pocas líneas de código. 10.1.6 ¿Qué tipo de resultados devuelve apply? En los ejemplos anteriores, el resultado de apply() en algunas ocasiones fue un vector y en otros fue una matriz. Si aplicamos mean(), obtenemos como resultado un vector. mat_media &lt;- apply(matriz, 1, mean) class(mat_media) #&gt; [1] &quot;numeric&quot; Pero si aplicamos quantile(), obtenemos una matriz. mat_cuant &lt;- apply(matriz, 1, quantile) class(mat_cuant) #&gt; [1] &quot;matrix&quot; &quot;array&quot; Este comportamiento se debe a que apply() nos devolverá objetos del mismo tipo que la función aplicada devuelve. Dependiendo de la función, será el tipo de objeto que obtengamos. Sin embargo, este comportamiento puede causarte algunos problemas. En primer lugar, anterior te obliga a conocer de antemano el tipo del resultado que obtendrás, lo cual no siempre es fácil de determinar, en particular si las funciones que estás utilizando son poco comunes o tienen comportamientos poco convencionales. Cuando estás trabajando en proyectos en los que el resultado de una operación será usado en operaciones posteriores, corres el riesgo de que en alguna parte del proceso, un apply() te devuelva un resultado que te impida continuar adelante. Con algo de práctica es más o menos sencillo identificar problemas posibles con los resultados de apply(), pero es algo que debes tener en cuenta, pues puede explicar por qué tu código no funciona como esperabas. En este sentido, lapply() tiene la ventaja de que siempre devuelve una lista. "],["10-2-lapply.html", "10.2 lapply", " 10.2 lapply lapply() es un caso especial de apply(), diseñado para aplicar funciones a todos los elementos de una lista. La l de su nombre se refiere, precisamente, a lista. lapply() intentará coercionar a una lista el objeto que demos como argumento y después aplicará una función a todos sus elementos. lapply siempre nos devolverá una lista como resultado. A diferencia de apply, sabemos que siempre obtendremos un objeto de tipo lista después de aplicar una función, sin importar cuál función sea. Dado que en R todas las estructuras de datos pueden coercionarse a una lista, lapply() puede usarse en un número más amplio de casos que apply(), además de que esto nos permite utilizar funciones que aceptan argumentos distintos a vectores. La estructura de esta función es: lapply(X, FUN) En donde: X es una lista o un objeto coercionable a una lista. FUN es la función a aplicar. Estos argumentos son idéntico a los de apply(), pero a diferencia aquí no especificamos MARGIN, pues las listas son estructuras con una unidimensionales, que sólo tienen largo. 10.2.1 Usando lapply() Probemos lapply() aplicando una función a un data frame. Usaremos el conjunto de datos trees, incluido por defecto en R base. trees contiene datos sobre el grueso, alto y volumen de distinto árboles de cerezo negro. Cada una de estas variables está almacenada en una columna del data frame. Veamos los primeros cinco renglones de trees. trees[1:5, ] #&gt; Girth Height Volume #&gt; 1 8.3 70 10.3 #&gt; 2 8.6 65 10.3 #&gt; 3 8.8 63 10.2 #&gt; 4 10.5 72 16.4 #&gt; 5 10.7 81 18.8 Aplicamos la función mean(), usando su nombre. lapply(X = trees, FUN = mean) #&gt; $Girth #&gt; [1] 13.24839 #&gt; #&gt; $Height #&gt; [1] 76 #&gt; #&gt; $Volume #&gt; [1] 30.17097 Dado que un data frame está formado por columnas y cada columna es un vector atómico, cuando usamos lapply() , la función es aplicada a cada columna. lapply(), a diferencia de apply() no puede aplicarse a renglones. En este ejemplo, obtuvimos la media de grueso (Girth), alto (Height) y volumen (Volume), como una lista. Verificamos que la clase de nuestro resultado es una lista con class(). arboles &lt;- lapply(X = trees, FUN = mean) class(arboles) #&gt; [1] &quot;list&quot; Esto es muy conveniente, pues la recomendación para almacenar datos en un data frame es que cada columna represente una variable y cada renglón un caso (por ejemplo, el enfoque tidy de Wickham (2014)). Por lo tanto, con lapply() podemos manipular y transformar datos, por variable. Al igual que con apply(), podemos definir argumentos adicionales a las funciones que usemos, usando sus nombres, después del nombre de la función. lapply(X = trees, FUN = quantile, probs = .8) #&gt; $Girth #&gt; 80% #&gt; 16.3 #&gt; #&gt; $Height #&gt; 80% #&gt; 81 #&gt; #&gt; $Volume #&gt; 80% #&gt; 42.6 Si usamos lapply con una matriz, la función se aplicará a cada celda de la matriz, no a cada columna. Creamos una matriz. matriz &lt;- matrix(1:9, ncol = 3) # Resultado matriz #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 Llamamos a lapply(). lapply(matriz, quantile, probs = .8) #&gt; [[1]] #&gt; 80% #&gt; 1 #&gt; #&gt; [[2]] #&gt; 80% #&gt; 2 #&gt; #&gt; [[3]] #&gt; 80% #&gt; 3 #&gt; #&gt; [[4]] #&gt; 80% #&gt; 4 #&gt; #&gt; [[5]] #&gt; 80% #&gt; 5 #&gt; #&gt; [[6]] #&gt; 80% #&gt; 6 #&gt; #&gt; [[7]] #&gt; 80% #&gt; 7 #&gt; #&gt; [[8]] #&gt; 80% #&gt; 8 #&gt; #&gt; [[9]] #&gt; 80% #&gt; 9 Para usar una matriz con lapply() y que la función se aplique a cada columna, primero la coercionamos a un data frame con la función as.data.frame() lapply(as.data.frame(matriz), quantile, probs = .8) #&gt; $V1 #&gt; 80% #&gt; 2.6 #&gt; #&gt; $V2 #&gt; 80% #&gt; 5.6 #&gt; #&gt; $V3 #&gt; 80% #&gt; 8.6 Si deseamos aplicar una función a los renglones de una matriz, una manera de lograr es transponer la matriz con t() y después coercionar a un data frame. matriz_t &lt;- t(matriz) lapply(as.data.frame(matriz_t), quantile, probs = .8) #&gt; $V1 #&gt; 80% #&gt; 5.8 #&gt; #&gt; $V2 #&gt; 80% #&gt; 6.8 #&gt; #&gt; $V3 #&gt; 80% #&gt; 7.8 Con vectores como argumento, lapply() aplicará la función a cada elementos del vector, de manera similar a una vectorización de operaciones. Por ejemplo, usamos lapply() para obtener la raíz cuadrada de un vector numérico del 1 al 4, con la función sqrt(). mi_vector &lt;- 1:4 lapply(mi_vector, sqrt) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 1.414214 #&gt; #&gt; [[3]] #&gt; [1] 1.732051 #&gt; #&gt; [[4]] #&gt; [1] 2 10.2.2 Usando lapply() en lugar de un bucle for En muchos casos es posible reemplazar un bucle for() por un lapply(). De hecho, lapply() está haciendo lo mismo que un for(), está iterando una operación en todos los elementos de una estructura de datos. Por lo tanto, el siguiente código con un for() mi_vector &lt;- 6:12 resultado &lt;- NULL posicion &lt;- 1 for(numero in mi_vector) { resultado[posicion] &lt;- sqrt(numero) posicion &lt;- posicion + 1 } resultado #&gt; [1] 2.449490 2.645751 2.828427 3.000000 3.162278 3.316625 3.464102  nos dará los mismos resultados que el siguiente código con lapply(). resultado &lt;- NULL resultado &lt;- lapply(mi_vector, sqrt) resultado #&gt; [[1]] #&gt; [1] 2.44949 #&gt; #&gt; [[2]] #&gt; [1] 2.645751 #&gt; #&gt; [[3]] #&gt; [1] 2.828427 #&gt; #&gt; [[4]] #&gt; [1] 3 #&gt; #&gt; [[5]] #&gt; [1] 3.162278 #&gt; #&gt; [[6]] #&gt; [1] 3.316625 #&gt; #&gt; [[7]] #&gt; [1] 3.464102 El código con lapply() es mucho más breve y más sencillo de entender, al menos para otros usuarios de R. El inconveniente es que obtenemos una lista como resultado en lugar de un vector, pero eso es fácil de resolver usando la función as.numeric() para hacer coerción a tipo numérico. as.numeric(resultado) #&gt; [1] 2.449490 2.645751 2.828427 3.000000 3.162278 3.316625 3.464102 El siguiente código es la manera en la que usamos for() si deseamos aplicar una función a todas sus columnas, tiene algunas partes que no hemos discutido, pero es sólo para ilustrar la diferencia simplemente usar trees_max &lt;- lapply(trees, max). trees_max &lt;- NULL i &lt;- 1 columnas &lt;- ncol(trees) for(i in 1:columnas) { trees_max[i] &lt;- max(trees[, i]) i &lt;- i +1 } trees_max #&gt; [1] 20.6 87.0 77.0 10.2.3 Usando lapply con listas Hasta hora hemos hablado de usar lapply() con objetos que pueden coercionarse a una lista, pero ¿qué pasa si usamos esta función con una lista que contiene a otros objetos? Pues la función se aplicará a cada uno de ellos. Por lo tanto, así podemos utilizar funciones que acepten todo tipo de objetos como argumento. Incluso podemos aplicar funciones a listas recursivas, es decir, listas de listas. Por ejemplo, obtendremos el coeficiente de correlación de cuatro data frames contenidos en una sola lista. Esto no es posible con apply(), porque sólo podemos usar funciones que aceptan vectores como argumentos, pero con lapply() no es ningún problema. Empezaremos creando una lista de data frames. Para esto, usaremos las función rnorm(), que genera números al azar y set.seed(), para que obtengas los mismos resultados aquí mostrados. rnorm() creara n números al azar (pseudoaleatorios, en realidad), sacados de una distribución normal con media 0 y desviación estándar 1. set.seed() es una función que fija los resultados de una generación de valores al azar. Cada que ejecutas rnorm() obtienes resultados diferentes, pero si das un número como argumento seed a set.seed(), siempre obtendrás los mismos números. # Fijamos seed set.seed(seed = 2018) # Creamos una lista con tres data frames dentro tablas &lt;- list( df1 = data.frame(a = rnorm(n = 5), b = rnorm(n = 5), c = rnorm(n = 5)), df2 = data.frame(d = rnorm(n = 5), e = rnorm(n = 5), f = rnorm(n = 5)), df3 = data.frame(g = rnorm(n = 5), h = rnorm(n = 5), i = rnorm(n = 5)) ) # Resultado tablas #&gt; $df1 #&gt; a b c #&gt; 1 -0.42298398 -0.2647112 -0.6430347 #&gt; 2 -1.54987816 2.0994707 -1.0300287 #&gt; 3 -0.06442932 0.8633512 0.7124813 #&gt; 4 0.27088135 -0.6105871 -0.4457721 #&gt; 5 1.73528367 0.6370556 0.2489796 #&gt; #&gt; $df2 #&gt; d e f #&gt; 1 -1.0741940 1.2638637 -0.2401222 #&gt; 2 -1.8272617 0.2501979 -1.0586618 #&gt; 3 0.0154919 0.2581954 0.4194091 #&gt; 4 -1.6843613 1.7855342 -0.2709566 #&gt; 5 0.2044675 -1.2197058 -0.6318248 #&gt; #&gt; $df3 #&gt; g h i #&gt; 1 -0.2284119 -0.4897908 -0.3594423 #&gt; 2 1.1786797 1.4105216 -1.2995363 #&gt; 3 -0.2662727 -1.0752636 -0.8698701 #&gt; 4 0.5281408 0.2923947 1.0543623 #&gt; 5 -1.7686592 -0.2066645 -0.1486396 Para obtener el coeficiente de correlación usaremos la función cor(). Esta función acepta como argumento una data frame o una matriz. Con este objeto, calculará el coeficiente de correlación R de Pearson existente entre cada una de sus columnas. Como resultado obtendremos una matriz de correlación. Por ejemplo, este es el resultado de aplicar cor() a iris. cor(iris[1:4]) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Sepal.Length 1.0000000 -0.1175698 0.8717538 0.8179411 #&gt; Sepal.Width -0.1175698 1.0000000 -0.4284401 -0.3661259 #&gt; Petal.Length 0.8717538 -0.4284401 1.0000000 0.9628654 #&gt; Petal.Width 0.8179411 -0.3661259 0.9628654 1.0000000 Con lapply aplicaremos cor() a cada uno de los data frames contenidos en nuestra lista. El resultado será una lista de matrices de correlaciones. Esto lo logramos con una línea de código. lapply(X = tablas, FUN = cor) #&gt; $df1 #&gt; a b c #&gt; a 1.0000000 -0.4427336 0.6355358 #&gt; b -0.4427336 1.0000000 -0.1057007 #&gt; c 0.6355358 -0.1057007 1.0000000 #&gt; #&gt; $df2 #&gt; d e f #&gt; d 1.0000000 -0.6960942 0.4709283 #&gt; e -0.6960942 1.0000000 0.2624429 #&gt; f 0.4709283 0.2624429 1.0000000 #&gt; #&gt; $df3 #&gt; g h i #&gt; g 1.0000000 0.6228793 -0.1472657 #&gt; h 0.6228793 1.0000000 -0.1211321 #&gt; i -0.1472657 -0.1211321 1.0000000 De esta manera puedes manipular información de múltiples data frames, matrices o listas con muy pocas líneas de código y, en muchos casos, más rápidamente que con las alternativas existentes. Finalmente, si asignamos los resultados de las última operación a un objeto, podemos usarlos y manipularlos de la misma manera que cualquier otra lista. correlaciones &lt;- lapply(tablas, cor) # Extraemos el primer elemento de la lista correlaciones[[1]] #&gt; a b c #&gt; a 1.0000000 -0.4427336 0.6355358 #&gt; b -0.4427336 1.0000000 -0.1057007 #&gt; c 0.6355358 -0.1057007 1.0000000 "],["11-importar-y-exportar-datos.html", "Capítulo 11 Importar y exportar datos", " Capítulo 11 Importar y exportar datos Hasta ahora, hemos trabajado con datos ya existentes en R base o que hemos generado nosotros mismos, sin embargo, lo usual es que usemos datos almacenados en archivos fuera de R. R puede importar datos de una amplia variedad de tipos de archivo con las funciones en base además de que esta capacidad es ampliada con el uso de paquetes específicos. Cuando importamos un archivo, estamos guardando su contenido en nuestra sesión como un objeto. Dependiendo del procedimiento que usemos será el tipo de objeto creado. De manera análoga, podemos exportar nuestros objetos de R a archivos en nuestra computadora. "],["11-1-descargando-datos.html", "11.1 Descargando datos", " 11.1 Descargando datos Antes de empezar a importar datos, vale la pena señalar que podemos descargar archivos de internet usando R con la función download.file(). De esta manera tendremos acceso a una vasta diversidad de fuentes de datos. Entre otras, podrás descargar los archivos La función download.file() nos pide como argumento url, la dirección de internet del archivo que queremos descargar y destfile el nombre que tendrá el archivo en nuestra computadora. Ambos argumentos como cadenas de texto, es decir, entre comillas. Por ejemplo, para descargar una copia del set iris disponible en el UCI Machine Learning Repository usamos la siguiente dirección como argumento url: https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data Y asignamos iris.data al argumento dest. download.file( url = &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&quot;, destfile = &quot;iris.data&quot; ) El resultado es un archivo llamado iris.data en nuestro directorio de trabajo. Este método funciona con prácticamente todo tipo de archivos, aunque en algunos casos será necesario agregar el argumento method = \"wb\", por asegurar que el archivo obtenido funcione correctamente. "],["11-2-tablas-datos-rectangulares.html", "11.2 Tablas (datos rectangulares)", " 11.2 Tablas (datos rectangulares) Como vimos en el capítulo 7, las estructura rectangular, en renglones y columnas, es común y conveniente para el análisis de datos. Nos referiremos a esta forma de organizar datos como tabla. R cuenta con la función genérica read.table(), que puede leer cualquier tipo de archivo que contenga una tabla. La condición para que R interprete un archivo como una tabla es que tenga renglones y en cada renglón, los datos estén separados por comas, o algún otro carácter, indicando columnas. Es decir, algo que luzca de la siguiente manera. 1, 20, 8, 5 1, 31, 6, 5 2, 18, 9, 5 2, 25, 10, 5 Por supuesto, en lugar de comas podemos tener puntos y coma, dos puntos, tabuladores o cualquier otro signo de puntuación como separador de columnas. La función read.table() acepta un número considerable de argumentos. Los más importantes son los siguientes. file: La ruta del archivo que importaremos, como cadena de texto. Si el archivo se encuentra en nuestro directorio de trabajo, es suficiente dar el nombre del archivo, sin la ruta completa. header: Si nuestro archivo tiene encabezados, para ser interpretados como nombres de columna, definimos este argumento como TRUE. sep: El carácter que es usado como separador de columnas. Por defecto es ; col.names: Un vector opcional, de tipo carácter, con los nombres de las columnas en la tabla. stringsAsFactors: Esta función convierte automáticamente los datos de texto a factores. Si este no es el comportamiento que deseamos, definimos este argumento como FALSE. Puedes consultar todos los argumentos de esta función ejecutando ?read.table en la consola. Es importante señalar que el objeto obtenido al usar esta función es siempre un data frame. Probemos con un archivo con extensión .data, descargado desde el repositorio de Github de este libro. download.file( url = &quot;https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.data&quot;, dest = &quot;breast-cancer-wis.data&quot; ) Estos datos pertenecen a una base de diagnósticos de cáncer mamario de la Universidad de Wisconsin, usado para probar métodos de aprendizaje automático. Puedes encontrar la información completa sobre este conjunto de datos en el siguiente enlace: https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29 Nos damos cuenta de que hemos tenido éxito en la descarga si aparece un mensaje en la consola de R indicando los resultados de nuestra operación. Usamos sin especificar ningún otro argumento. bcancer &lt;- read.table(file = &quot;datos/breast-cancer-wis.data&quot;) Veamos los primeros renglones de nuestros datos usando la función head() head(bcancer) #&gt; V1 #&gt; 1 1000025,5,1,1,1,2,1,3,1,1,2 #&gt; 2 1002945,5,4,4,5,7,10,3,2,1,2 #&gt; 3 1015425,3,1,1,1,2,2,3,1,1,2 #&gt; 4 1016277,6,8,8,1,3,4,3,7,1,2 #&gt; 5 1017023,4,1,1,3,2,1,3,1,1,2 #&gt; 6 1017122,8,10,10,8,7,10,9,7,1,4 Nuestros datos no lucen particularmente bien. Necesitamos ajustar algunos parámetros al importarlos. No hay datos de encabezado, por lo que header será igual a FALSE y el separador de columnas es una coma, así que el valor de sep será , No conocemos cuál es el nombre de las columnas, así que por el momento no proporcionaremos uno. bcancer &lt;- read.table(file = &quot;datos/breast-cancer-wis.data&quot;, header = FALSE, sep = &quot;,&quot;) # Resultado head(bcancer) #&gt; V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 #&gt; 1 1000025 5 1 1 1 2 1 3 1 1 2 #&gt; 2 1002945 5 4 4 5 7 10 3 2 1 2 #&gt; 3 1015425 3 1 1 1 2 2 3 1 1 2 #&gt; 4 1016277 6 8 8 1 3 4 3 7 1 2 #&gt; 5 1017023 4 1 1 3 2 1 3 1 1 2 #&gt; 6 1017122 8 10 10 8 7 10 9 7 1 4 Luce mejor, pero los nombres de las columnas son poco descriptivos. Si no damos nombres de variables, cada columna tendrá como nombre V seguida de números del 1 adelante. Para este ejemplo, contamos con un archivo de información, que describe el contenido de los datos que hemos importado. https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.names Si descargas este archivo, puedes abrirlo usando el bloc o navegador de internet de tu computadora. Guardaremos en un vector las abreviaturas de los nombres de columna descritos en el documento anterior. nombres &lt;- c(&quot;id&quot;, &quot;clump_t&quot;, &quot;u_csize&quot;, &quot;u_cshape&quot;, &quot;m_adh&quot;, &quot;spcs&quot;, &quot;b_nuc&quot;, &quot;b_chr&quot;, &quot;n_nuc&quot;, &quot;mit&quot;, &quot;class&quot;) Ahora usaremos este vector como argumento col.names en read.table(), para importar nuestros datos con nombres de columna. bcancer &lt;- read.table(file = &quot;datos/breast-cancer-wis.data&quot;, header = FALSE, sep = &quot;,&quot;, col.names = nombres) # Resultado head(bcancer) #&gt; id clump_t u_csize u_cshape m_adh spcs b_nuc b_chr n_nuc mit class #&gt; 1 1000025 5 1 1 1 2 1 3 1 1 2 #&gt; 2 1002945 5 4 4 5 7 10 3 2 1 2 #&gt; 3 1015425 3 1 1 1 2 2 3 1 1 2 #&gt; 4 1016277 6 8 8 1 3 4 3 7 1 2 #&gt; 5 1017023 4 1 1 3 2 1 3 1 1 2 #&gt; 6 1017122 8 10 10 8 7 10 9 7 1 4 Nuestros datos han sido importados correctamente. Además, el objeto resultante es un data frame, listo para que trabajemos con él. class(bcancer) #&gt; [1] &quot;data.frame&quot; 11.2.1 Archivos CSV Un caso particular de las tablas, son los archivos separados por comas, con extensión .csv, por Comma Separated Values, sus siglas en inglés. Este es un tipo de archivo comúnmente usado para compartir datos, pues es compatible con una amplia variedad de sistemas diferentes además de que ocupa relativamente poco espacio de almacenamiento. Este tipo de archivos también se pueden importar usando la función read.table(). Probemos descargando los mismos datos que en el ejemplo anterior, pero almacenados en un archivo con extensión .csv. download.file( url = &quot;https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/breast-cancer-wis.csv&quot;, dest = &quot;breast-cancer-wis.csv&quot; ) Podemos usar read.table() con los mismos argumentos que en el ejemplo anterior, con la excepción de que este archivo sí tiene encabezados de columna, por lo que cambiamos header de FALSE a TRUE. bcancer &lt;- read.table(file = &quot;datos/breast-cancer-wis.csv&quot;, header = TRUE, sep = &quot;,&quot;, col.names = nombres) # Resultado head(bcancer) #&gt; id clump_t u_csize u_cshape m_adh spcs b_nuc b_chr n_nuc mit class #&gt; 1 1000025 5 1 1 1 2 1 3 1 1 2 #&gt; 2 1002945 5 4 4 5 7 10 3 2 1 2 #&gt; 3 1015425 3 1 1 1 2 2 3 1 1 2 #&gt; 4 1016277 6 8 8 1 3 4 3 7 1 2 #&gt; 5 1017023 4 1 1 3 2 1 3 1 1 2 #&gt; 6 1017122 8 10 10 8 7 10 9 7 1 4 Una ventaja de usar documentos con extensión .csv es la posibilidad de usar la función read.csv(). Esta es una es una versión de read.table(), optimizada para importar archivos .csv. read.csv() acepta los mismos argumentos que read.table(), pero al usarla con un archivo .csv, en casi todo los casos, no hará falta especificar nada salvo la ruta del archivo. bcancer &lt;- read.csv(&quot;datos/breast-cancer-wis.csv&quot;) # Resultado head(bcancer) #&gt; id clump_t u_csize u_cshape m_adh spcs b_nuc b_chr n_nuc mit class #&gt; 1 1000025 5 1 1 1 2 1 3 1 1 2 #&gt; 2 1002945 5 4 4 5 7 10 3 2 1 2 #&gt; 3 1015425 3 1 1 1 2 2 3 1 1 2 #&gt; 4 1016277 6 8 8 1 3 4 3 7 1 2 #&gt; 5 1017023 4 1 1 3 2 1 3 1 1 2 #&gt; 6 1017122 8 10 10 8 7 10 9 7 1 4 read.csv() también devuelve un data frame como resultado "],["11-3-archivos-con-una-estructura-desconocida.html", "11.3 Archivos con una estructura desconocida", " 11.3 Archivos con una estructura desconocida Habrá ocasiones en las que no estamos seguros del contenido de los archivos que deseamos importar. En estos casos, podemos pedirle a R que intente abrir el archivo en cuestión, usando la función file.show(). Por ejemplo, intentamos abrir el archivo con extensión .csv que importamos antes. file.show(&quot;datos/breast-cancer-wis.csv&quot;) R intentará usar el programa que en nuestro equipo, por defecto, abre el tipo de archivo que le hemos indicado. Si no tenemos un programa configurado para abrir el tipo de archivo que deseamos, nuestro sistema operativo nos pedirá que elijamos uno. Lo anterior puede ocurrir si intentas abrir el archivo con extensión .data que hemos importado en este capítulo. file.show(&quot;datos/breast-cancer-wis.data&quot;) Podemos usar la función readLines() para leer un archivo línea por línea. Establecemos el argumento n = 4 para obtener sólo los primeros cuatro renglones del documento. readLines(&quot;datos/breast-cancer-wis.data&quot;, n = 4) #&gt; [1] &quot;1000025,5,1,1,1,2,1,3,1,1,2&quot; &quot;1002945,5,4,4,5,7,10,3,2,1,2&quot; #&gt; [3] &quot;1015425,3,1,1,1,2,2,3,1,1,2&quot; &quot;1016277,6,8,8,1,3,4,3,7,1,2&quot; La salida es una lista de vectores, uno por linea en el archivo. Observando la salida de readLines() podremos determinar si el archivo que nos interesa puede ser importado usando con los métodos que hemos revisado o necesitaremos de herramientas diferentes. El documento R Data Import/Export (R Core Team, 2018) contiene una guía avanzada sobre el proceso de importar y exportar todo tipo de datos. Puedes consultarlo en el siguiente enlace: https://cran.r-project.org/doc/manuals/r-release/R-data.pdf "],["11-4-exportar-datos.html", "11.4 Exportar datos", " 11.4 Exportar datos Un paso muy importante en el trabajo con R es exportar los datos que hemos generado, ya sea para que sean usados por otras personas o para almacenar información en nuestro disco duro en lugar de nuestro RAM. Dependiendo del tipo de estructura de dato en el que se encuentran contenidos nuestros datos son las opciones que tenemos para exportarlos. 11.4.1 Data frames y matrices Si nuestros datos se encuentran contenidos en una estructura de datos rectangular, podemos exportarlos con diferentes funciones. De manera análoga a read.table(), la función write.table() nos permite exportar matrices o data frames, como archivos de texto con distintas extensiones. Los argumentos más usados de write.table() son los siguientes. x: El nombre del data frame o matriz a exportar. file: El nombre, extensión y ruta del archivo creado con esta función. Si sólo escribimos el nombre del archivo, este será creado en nuestro directorio de trabajo. sep: El carácter que se usará como separador de columnas. row.names: Si deseamos incluir el nombre de los renglones en nuestro objeto al exportarlo, establecemos este argumento como TRUE. En general, es recomendable fijarlo como FALSE, para conservar una estructura tabular más fácil de leer. col.names: Si deseamos que el archivo incluya los nombres de las columnas en nuestro objeto, establecemos este argumento como TRUE. Es recomendable fijarlo como TRUE para evitar la necesidad de almacenar los nombres de columna en documentos distintos. Puedes consultar todos los argumentos de esta función ejecutando ?write.table. Probemos exportando el objeto iris a un documento de texto llamado iris.txt a nuestro directorio de trabajo, usando como separador la coma, con nombres de columnas y sin nombre de renglones. write.table(x = iris, file = &quot;iris.txt&quot;, sep = &quot;,&quot;, row.names = FALSE, col.names = TRUE) Importemos el archivo que hemos creado usando read.table(). iris_txt &lt;- read.table(file = &quot;iris.txt&quot;, header = TRUE, sep = &quot;,&quot;) # Resultado head(iris_txt) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa También podemos exportar datos a archivos con extensión .csv con la función write.csv(). Vamos a exportar iris como un documento .csv. En este caso, sólo especificamos que no deseamos guardar los nombres de los renglones con row.names = FALSE. write.csv(x = iris, file = &quot;iris.csv&quot;, row.names = FALSE) Importamos el archivo creado. iris_csv &lt;- read.csv(&quot;iris.csv&quot;) # Resultado head(iris_csv) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa 11.4.2 Listas La manera más sencilla de exportar listas es guardarlas en archivos RDS. Este es un tipo de archivo nativo de R que puede almacenar cualquier objeto a un archivo en nuestro disco duro. Además, RDS comprime los datos que almacena, por lo que ocupa menos espacio en disco duro que otros tipos de archivos, aunque contengan la misma información. Para exportar un objeto a un archivo RDS, usamos la función saveRDS() que siempre nos pide dos argumentos: object: El nombre del objeto a exportar. file: El nombre y ruta del archivo que crearemos. Los archivos deben tener la extensión .rds. Si no especificamos una ruta completa, el archivo será creado en nuestro directorio de trabajo. Creamos una lista de ejemplo que contiene dos vectores y dos matrices mi_lista &lt;- list(&quot;a&quot; = c(TRUE, FALSE, TRUE), &quot;b&quot; = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;c&quot; = matrix(1:4, ncol = 2), &quot;d&quot; = matrix(1:6, ncol = 3)) # Resultado mi_lista #&gt; $a #&gt; [1] TRUE FALSE TRUE #&gt; #&gt; $b #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; #&gt; #&gt; $c #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; $d #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 Aunque podemos intentar write.table() para exportar listas, por lo general obtendremos un error como resultado. Tratamos de exportar la lista anterior como un archivo .txt. write.table(x = mi_lista, file = &quot;mi_lista.txt&quot;) #&gt; Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 2 Usamos la función saveRDS() para exportar al archivo mi_lista.rds. saveRDS(object = mi_lista, file = &quot;mi_lista.rds&quot;) Si deseamos importar un archivo RDS a R, usamos la función readRDS(), indicando la ruta en la que se encuentra el archivo que deseamos. Intentemos importar el archivo mi_lista.rds. mi_lista_importado &lt;- readRDS(file = &quot;mi_lista.rds&quot;) Vamos el resultado. mi_lista_importado #&gt; $a #&gt; [1] TRUE FALSE TRUE #&gt; #&gt; $b #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; #&gt; #&gt; $c #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 #&gt; #&gt; $d #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 # El resultado es una lista, al igual que el objeto original class(mi_lista) #&gt; [1] &quot;list&quot; Los objetos importados usando un archivo RDS conservan los tipos y clases que tenían originalmente, lo cual previene pérdida de información. "],["11-5-hojas-de-cálculo-de-excel.html", "11.5 Hojas de cálculo de Excel", " 11.5 Hojas de cálculo de Excel Un formato usado con mucha frecuencia para almacenar archivos son las hojas de cálculo, en particular las generadas por el paquete Microsoft Excel. R base no tiene una función para importar archivos almacenados en archivos con extensión .xsl y .xslx, creados con Excel. Para importar datos desde este tipo de archivos, necesitamos instalar el paquete readxl, que contiene funciones específicas para realizar esta tarea. Usamos la función installpackages(), como lo vimos en el capítulo 3 install.packages(&quot;readxl&quot;) Ya instalado, cargamos el readxl a nuestra sesión de trabajo. library(readxl) Usaremos, principalmente dos funciones de este paquete. read_excel(): Para importar archivos .xls y xlsx. excel_sheets(): Para obtener los nombres de las pestañas en una hoja de cálculo de Excel. Para probar estas funciones, descargaremos una hoja de cálculo de prueba. Nota que hemos establecido el argumento mode = \"wb\" para asegurar que el archivo se descargue correctamente. download.file( url = &quot;https://github.com/jboscomendoza/r-principiantes-bookdown/raw/master/datos/data_frames.xlsx&quot;, destfile = &quot;datos/data_frames.xlsx&quot;, mode = &quot;wb&quot; ) Si intentamos leer las primeras cinco líneas de data_frames.xlsx, confirmamos que este es un archivo que no tiene forma rectangular, de tabla. readLines(&quot;datos/data_frames.xlsx&quot;, n = 5) #&gt; [1] &quot;PK\\003\\004\\024&quot; #&gt; [2] &quot;\\177ßYTU,B õ(±çmöL\\177¸jêd\\t\\001\\215³¹èf\\035\\200-6v¯É{ú$\\022$eµª\\235\\\\¬\\001Åpp\\177×¬=`ÂÕ\\026sQ\\021ùg)±¨ Q\\2309\\017WJ\\027&quot; En caso de que tengamos instalado Excel o algún otro programa compatible con archivos de hoja de cálculo, como LibreOffice Calc o Number, podemos pedir a R que abra este archivo con file.show(). De este modo podemos explorar su contenido. file.show(&quot;datos/data_frames.xlsx&quot;) La función excel_sheets() nos devuelve el nombre de las pestañas como un vector. excel_sheets(&quot;datos/data_frames.xlsx&quot;) #&gt; [1] &quot;iris&quot; &quot;trees&quot; Este archivo tiene dos pestañas, llamadas iris y trees. Intentaremos importar la pestaña iris con read_excel(). Esta función tiene los siguientes argumentos principales. path: La ruta del archivo a importar. Si no especificamos una ruta completa, será buscado en nuestro directorio de trabajo. sheet: El nombre de la pestaña a importar. Si no especificamos este argumento, read_excel() intentará leer la primera pestaña de la hoja de cálculo. range: Cadena de texto con el rango de celdas a importar, escrito con el formato usado en Excel. Por ejemplo, A1:B:10. col_names: Con este argumento indicamos si la pestaña que vamos a importar tiene encabezados para usar como nombres de columna. Por defecto su valor es TRUE. Si no tenemos encabezados, podemos dar un vector con nombres para asignar a las columnas. Puedes consultar todos los argumentos de esta función ejecutando ?read_excel. Probemos read_excel(). iris_excel &lt;- read_excel(path = &quot;datos/data_frames.xlsx&quot;, sheet = &quot;iris&quot;) Nuestro resultado es un data frame. iris_excel #&gt; # A tibble: 150 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa #&gt; 7 4.6 3.4 1.4 0.3 setosa #&gt; 8 5 3.4 1.5 0.2 setosa #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 10 4.9 3.1 1.5 0.1 setosa #&gt; # ... with 140 more rows Si los datos en la hoja de cálculo tienen forma de tabla, read_excel() no tendrá problemas para importarlos. Cuando este no es el caso, usamos el argumento range para extraer sólo la información que nos interesa. Intentamos importar la pestaña trees. trees_excel &lt;- read_excel(path = &quot;datos/data_frames.xlsx&quot;, sheet = &quot;trees&quot;) # Resultado trees_excel #&gt; # A tibble: 34 x 6 #&gt; `Datos trees` ...2 ...3 ...4 ...5 ...6 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; #&gt; 1 &lt;NA&gt; NA NA NA NA &lt;NA&gt; #&gt; 2 &lt;NA&gt; 8.3 70 10.3 NA &lt;NA&gt; #&gt; 3 &lt;NA&gt; 8.6 65 10.3 NA &lt;NA&gt; #&gt; 4 &lt;NA&gt; 8.8 63 10.2 NA Los nombres de las variables son: Girt~ #&gt; 5 &lt;NA&gt; 10.5 72 16.4 NA &lt;NA&gt; #&gt; 6 &lt;NA&gt; 10.7 81 18.8 NA &lt;NA&gt; #&gt; 7 &lt;NA&gt; 10.8 83 19.7 NA &lt;NA&gt; #&gt; 8 &lt;NA&gt; 11 66 15.6 NA &lt;NA&gt; #&gt; 9 &lt;NA&gt; 11 75 18.2 NA &lt;NA&gt; #&gt; 10 &lt;NA&gt; 11.1 80 22.6 NA &lt;NA&gt; #&gt; # ... with 24 more rows Los resultados no lucen bien porque los datos en la pestaña no tienen forma de tabla. Ajustamos los argumentos de read_excel() para leer correctamente la información de la pestaña. Al explorar manualmente el archivo data.frames.xlsx, podemos localizar el rango en el que se encuentran los datos (de las celdas B3 a D33) y los nombres de las columnas (Girth, Height y Volume). Probemos importar de nuevo con esta información. trees_excel &lt;- read_excel(path = &quot;datos/data_frames.xlsx&quot;, sheet = &quot;trees&quot;, range = &quot;B3:D33&quot;, col_names = c(&quot;Girth&quot;, &quot;Height&quot;, &quot;Volume&quot;)) # Resultado trees_excel #&gt; # A tibble: 31 x 3 #&gt; Girth Height Volume #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 8.3 70 10.3 #&gt; 2 8.6 65 10.3 #&gt; 3 8.8 63 10.2 #&gt; 4 10.5 72 16.4 #&gt; 5 10.7 81 18.8 #&gt; 6 10.8 83 19.7 #&gt; 7 11 66 15.6 #&gt; 8 11 75 18.2 #&gt; 9 11.1 80 22.6 #&gt; 10 11.2 75 19.9 #&gt; # ... with 21 more rows Esta vez hemos tenido éxito y los datos importados son los correctos. El paquete readxl tiene más funciones para trabajar con hojas de cálculo además de read_excel() y excel_sheets(), pero revisar cada una de ellas sale del alcance de este libro. Puedes conocer más sobre ellas en la documentación de readxl, llamando help(package = \"readxl\"). "],["11-6-datos-de-paquetes-estadísticos-comerciales-spss-sas-y-stata.html", "11.6 Datos de paquetes estadísticos comerciales (SPSS, SAS y STATA)", " 11.6 Datos de paquetes estadísticos comerciales (SPSS, SAS y STATA) En ciertas disciplinas, el uso de determinados paquetes estadísticos comerciales es sumamente común. Si Por ejemplo, en Psicología el paquete SPSS Statistics de IBM es el paquete estadístico comercial más usado. Si eres psicólogo o psicóloga, o colaboras con psicólogos, es altamente probable que te encuentres con datos contenidos en archivos con extensión .sav, el tipo de archivo nativo de SPSS Statistics. Por lo tanto, es conveniente ser capaces de importar y exportar datos almacenados en archivos compatibles con paquetes estadísticos comerciales, pues esto nos permitirá usar datos ya existentes compatibles con ellos y colaborar con otras personas. Para este fin, usamos el paquete haven. install.packages(&quot;haven&quot;) Para usar las funciones de haven, lo cargamos a nuestra sesión de trabajo. library(haven) Las siguientes funciones de haven son usadas para importar datos. Todas estas funciones nos piden como argumento file la ruta y nombre del archivo a importar, si no especificamos ruta, será buscado en nuestro directorio de trabajo. read_spss(): SPSS Statistics, archivos con extensión sav, zsav y por. read_sav(): SPSS Statistics, sólo archivos sav, zsav. read_sas(): SAS, archivos sas7bdat. read_xpt: SAS, archivos xpt. read_stata(): Stata, archivos dta. Todas importan los datos como un data frame. También podemos exportar nuestros data frames creados en R como archivos compatibles con estos programas con las siguientes funciones. Todas piden el argumento file, con la ruta y nombre del archivo a crear. Es muy importante que demos como nombre de archivo uno con la extensión correcta para cada paquete. write_sav(): SPSS Statistics, archivos sav, zsav o por. write_sas(): SAS, archivos sas7bda. write_xpt(): SAS, archivos xpt. write_dta(): Stata, archivos dta. Como siempre, puedes leer sobre las demás funciones en el paquete haven en su documentación, llamando help(package = \"haven\"). "],["12-gráficas.html", "Capítulo 12 Gráficas", " Capítulo 12 Gráficas R cuenta con un sistema de generación de gráficas poderoso y flexible. Sin embargo, tener estar cualidades hace que este sistema sea un tanto complejo para aprender. En este capítulo revisaremos como crear las gráficas más comunes con R base, así como algunos de los parámetros que podemos ajustar para mejorar su presentación. Al crear gráficas, notarás que ponemos en práctica todo lo que hemos visto en los capítulos anteriores, incluyendo importar datos, hacer subconjuntos de un objeto y uso de funciones. "],["12-1-datos-usados-en-el-capítulo.html", "12.1 Datos usados en el capítulo", " 12.1 Datos usados en el capítulo Para las siguientes secciones utilizaremos de nuevo una copia de los datos disponibles en el UCI Machine Learning Repository. Usaremos un conjunto de datos llamado Bank Marketing Data Set, que contiene información de personas contactadas en una campaña de marketing directo puesta en marcha por un banco de Portugal. Comenzamos con la descarga de la copia del archivo csv desde el sitio de Github de este libro. download.file( url = &quot;https://raw.githubusercontent.com/jboscomendoza/r-principiantes-bookdown/master/datos/bank.csv&quot;, destfile = &quot;datos/bank.csv&quot; ) Damos un vistazo al contenido del archivo bank.csv con readLines(). readLines(&quot;datos/bank.csv&quot;, n = 4) #&gt; [1] &quot;\\&quot;age\\&quot;;\\&quot;job\\&quot;;\\&quot;marital\\&quot;;\\&quot;education\\&quot;;\\&quot;default\\&quot;;\\&quot;balance\\&quot;;\\&quot;housing\\&quot;;\\&quot;loan\\&quot;;\\&quot;contact\\&quot;;\\&quot;day\\&quot;;\\&quot;month\\&quot;;\\&quot;duration\\&quot;;\\&quot;campaign\\&quot;;\\&quot;pdays\\&quot;;\\&quot;previous\\&quot;;\\&quot;poutcome\\&quot;;\\&quot;y\\&quot;&quot; #&gt; [2] &quot;30;\\&quot;unemployed\\&quot;;\\&quot;married\\&quot;;\\&quot;primary\\&quot;;\\&quot;no\\&quot;;1787;\\&quot;no\\&quot;;\\&quot;no\\&quot;;\\&quot;cellular\\&quot;;19;\\&quot;oct\\&quot;;79;1;-1;0;\\&quot;unknown\\&quot;;\\&quot;no\\&quot;&quot; #&gt; [3] &quot;33;\\&quot;services\\&quot;;\\&quot;married\\&quot;;\\&quot;secondary\\&quot;;\\&quot;no\\&quot;;4789;\\&quot;yes\\&quot;;\\&quot;yes\\&quot;;\\&quot;cellular\\&quot;;11;\\&quot;may\\&quot;;220;1;339;4;\\&quot;failure\\&quot;;\\&quot;no\\&quot;&quot; #&gt; [4] &quot;35;\\&quot;management\\&quot;;\\&quot;single\\&quot;;\\&quot;tertiary\\&quot;;\\&quot;no\\&quot;;1350;\\&quot;yes\\&quot;;\\&quot;no\\&quot;;\\&quot;cellular\\&quot;;16;\\&quot;apr\\&quot;;185;1;330;1;\\&quot;failure\\&quot;;\\&quot;no\\&quot;&quot; Por la estructura de los datos, podremos usar la función read.csv(), con el argumento sep = \";\" para importarlos como un data frame. banco &lt;- read.csv(file = &quot;datos/bank.csv&quot;, sep = &quot;;&quot;) Vemos las primeras líneas del conjunto con head(), el número de renglones y columnas con dim(). # Primeros datos head(banco) #&gt; age job marital education default balance housing loan contact day #&gt; 1 30 unemployed married primary no 1787 no no cellular 19 #&gt; 2 33 services married secondary no 4789 yes yes cellular 11 #&gt; 3 35 management single tertiary no 1350 yes no cellular 16 #&gt; 4 30 management married tertiary no 1476 yes yes unknown 3 #&gt; 5 59 blue-collar married secondary no 0 yes no unknown 5 #&gt; 6 35 management single tertiary no 747 no no cellular 23 #&gt; month duration campaign pdays previous poutcome y #&gt; 1 oct 79 1 -1 0 unknown no #&gt; 2 may 220 1 339 4 failure no #&gt; 3 apr 185 1 330 1 failure no #&gt; 4 jun 199 4 -1 0 unknown no #&gt; 5 may 226 1 -1 0 unknown no #&gt; 6 feb 141 2 176 3 failure no # Dimensiones dim(banco) #&gt; [1] 4521 17 Usamos lapply() con la función class() para determinar el tipo de dato de cada columna en banco. Conocer esto nos será muy útil más adelante. lapply(banco, class) #&gt; $age #&gt; [1] &quot;integer&quot; #&gt; #&gt; $job #&gt; [1] &quot;character&quot; #&gt; #&gt; $marital #&gt; [1] &quot;character&quot; #&gt; #&gt; $education #&gt; [1] &quot;character&quot; #&gt; #&gt; $default #&gt; [1] &quot;character&quot; #&gt; #&gt; $balance #&gt; [1] &quot;integer&quot; #&gt; #&gt; $housing #&gt; [1] &quot;character&quot; #&gt; #&gt; $loan #&gt; [1] &quot;character&quot; #&gt; #&gt; $contact #&gt; [1] &quot;character&quot; #&gt; #&gt; $day #&gt; [1] &quot;integer&quot; #&gt; #&gt; $month #&gt; [1] &quot;character&quot; #&gt; #&gt; $duration #&gt; [1] &quot;integer&quot; #&gt; #&gt; $campaign #&gt; [1] &quot;integer&quot; #&gt; #&gt; $pdays #&gt; [1] &quot;integer&quot; #&gt; #&gt; $previous #&gt; [1] &quot;integer&quot; #&gt; #&gt; $poutcome #&gt; [1] &quot;character&quot; #&gt; #&gt; $y #&gt; [1] &quot;character&quot; Y por último, pedimos un resumen de nuestros datos con la función summary(). Esta función acepta cualquier tipo de objeto como argumento y nos devuelve un resumen descriptivo de los datos de cada uno de sus elementos. summary(banco) #&gt; age job marital education #&gt; Min. :19.00 Length:4521 Length:4521 Length:4521 #&gt; 1st Qu.:33.00 Class :character Class :character Class :character #&gt; Median :39.00 Mode :character Mode :character Mode :character #&gt; Mean :41.17 #&gt; 3rd Qu.:49.00 #&gt; Max. :87.00 #&gt; default balance housing loan #&gt; Length:4521 Min. :-3313 Length:4521 Length:4521 #&gt; Class :character 1st Qu.: 69 Class :character Class :character #&gt; Mode :character Median : 444 Mode :character Mode :character #&gt; Mean : 1423 #&gt; 3rd Qu.: 1480 #&gt; Max. :71188 #&gt; contact day month duration #&gt; Length:4521 Min. : 1.00 Length:4521 Min. : 4 #&gt; Class :character 1st Qu.: 9.00 Class :character 1st Qu.: 104 #&gt; Mode :character Median :16.00 Mode :character Median : 185 #&gt; Mean :15.92 Mean : 264 #&gt; 3rd Qu.:21.00 3rd Qu.: 329 #&gt; Max. :31.00 Max. :3025 #&gt; campaign pdays previous poutcome #&gt; Min. : 1.000 Min. : -1.00 Min. : 0.0000 Length:4521 #&gt; 1st Qu.: 1.000 1st Qu.: -1.00 1st Qu.: 0.0000 Class :character #&gt; Median : 2.000 Median : -1.00 Median : 0.0000 Mode :character #&gt; Mean : 2.794 Mean : 39.77 Mean : 0.5426 #&gt; 3rd Qu.: 3.000 3rd Qu.: -1.00 3rd Qu.: 0.0000 #&gt; Max. :50.000 Max. :871.00 Max. :25.0000 #&gt; y #&gt; Length:4521 #&gt; Class :character #&gt; Mode :character #&gt; #&gt; #&gt; "],["12-2-la-función-plot.html", "12.2 La función plot()", " 12.2 La función plot() En R, la función plot() es usada de manera general para crear gráficos. Esta función tiene un comportamiento especial, pues dependiendo del tipo de dato que le demos como argumento, generará diferentes tipos de gráfica. Además, para cada tipo de gráfico, podremos ajustar diferentes parámetros que controlan su aspecto, dentro de esta misma función. Puedes imaginar a plot() como una especie de navaja Suiza multi-funcional, con una herramienta para cada ocasión. plot() siempre pide un argumento x, que corresponde al eje X de una gráfica. x requiere un vector y si no especificamos este argumento, obtendremos un error y no se creará una gráfica. El resto de los argumentos de plot() son opcionales, pero el más importante es y. Este argumento también requiere un vector y corresponde al eje Y de nuestra gráfica. Dependiendo del tipo de dato que demos a x y y será el gráfico que obtendremos, de acuerdo a las siguientes reglas: x y Gráfico Continuo Continuo Diagrama de dispersión (Scatterplot) Continuo Discreto Diagrama de dispersión, y coercionada a numérica Continuo Ninguno Diagrama de dispersión, por número de renglón Discreto Continuo Diagrama de caja (Box plot) Discreto Discreto Gráfico de mosaico (Diagrama de Kinneman) Discreto Ninguno Gráfica de barras Ninguno Cualquiera Error En donde los tipos de dato son: Continuo: Un vector numérico, entero, lógico o complejo. Discreto: Un vector de factores o cadenas de texto. Además de plot(), hay funciones que generan tipos específicos de gráfica. Por ejemplo, podemos crear una gráfica de barras con plot() pero existe también la función barplot(). También existen también casos como el de los histogramas, que sólo pueden ser creados con la función hist(). Cuando llamas a la función plot() o alguna otra similar, R abre una ventana mostrando ese gráfico. Si estás usando RStudio, el gráfico aparece en el panel Plot. Si llamas de nuevo la función plot(), el gráfico generado más reciente reemplazará al más antiguo y en RStudio se creará una nueva pestaña en en el panel Plot. El gráfico reemplazado se perderá. Por lo tanto, a menos que nosotros los indiquemos, nuestros gráficos se pierden al crear uno nuevo. Al final de este capítulo veremos cómo exportar gráficos de manera más permanente. "],["12-3-histogramas.html", "12.3 Histogramas", " 12.3 Histogramas Un histograma es una gráfica que nos permite observar la distribución de datos numéricos usando barras. Cada barra representa el número de veces (frecuencia) que se observaron datos en un rango determinado. Para crear un histograma usamos la función hist(), que siempre nos pide como argumento x un vector numérico. El resto de los argumentos de esta función son opcionales. Si damos un vector no numérico, se nos devolverá un error. Ya hemos trabajado con esta función en el capítulo 8, pero ahora profundizaremos sobre ella. Probemos creando un histograma con las edades (age) de las personas en nuestro data frame banco. Sabemos que age Daremos como argumento a hist() la columna age como un vector, extraído de banco usando el signo de dolar $, aunque también podemos usar corchetes e índices. hist(x = banco$age) Nuestro histograma luce bastante bien para habernos costado tan poco trabajo crearlo, aunque puede mejorar su presentación. Podemos agregar algunos argumentos a la función hist() para modificar ciertos parámetros gráficos. Vamos a cambiar el título del gráfico con el argumento main, y el nombre de los ejes X y Y con xlab y ylab, respectivamente. Estos argumentos requiere una cadena de texto y pueden agregados también a gráficos generados con plot(). hist(x = banco$age, main = &quot;Histograma de Edad&quot;, xlab = &quot;Edad&quot;, ylab = &quot;Frecuencia&quot;) Probemos cambiando el color de las barras del histograma agregando el argumento col. Este argumento acepta nombres de colores genéricos en inglés como red, blue o purple; y también acepta colores hexadecimales, como #00FFFF, #08001a o #1c48b5. Puedes ver una lista de los nombres de colores válidos en R en el siguiente enlace: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf El tema de los colores hexadecimales sale del alcance de este libro, pero en el siguiente enlace encontrarás una web app para generar y elegir fácilmente colores de este tipo. https://www.w3schools.com/colors/colors_picker.asp Probemos con columnas de color púrpura (purple). hist(x = banco$age, main = &quot;Histograma de Edad&quot;, xlab = &quot;Edad&quot;, ylab = &quot;Frecuencia&quot;, col = &quot;purple&quot;) Nuestro histograma ya luce presentable. Creamos ahora un histograma con los mismos argumentos, pero con los datos de la columna duration, con barras de color marfil (ivory) y los títulos apropiados. hist(x = banco$duration, main = &quot;Histograma de Duration&quot;, xlab = &quot;Duration&quot;, ylab = &quot;Frecuencia&quot;, col = &quot;ivory&quot;) Como es usual, puedes consultar los demás argumentos de esta función llamando ?hist(). "],["12-4-gráficas-de-barras.html", "12.4 Gráficas de barras", " 12.4 Gráficas de barras Este es quizás el tipo de gráfico mejor conocido de todos. Una gráfica de este tipo nos muestra la frecuencia con la que se han observado los datos de una variable discreta, con una barra para cada categoría de esta variable. La función plot() puede generar gráficos de barra si damos como argumento x un vector de factor o cadena de texto, sin dar un argumento y. Por ejemplo, creamos una gráfica de barras de la variable educación (education) de banco #plot(x = banco$education) Al igual que con los histogramas, obtenemos un resultado aceptable no obstante el esfuerzo mínimo que hemos hecho para generar nuestra gráfica de barras. Podemos ajustar los parámetros gráficos con los argumentos main, xlab, ylab y col. En este caso, podemos darle a col un vector de colores, uno por barra, para que cada una sea distinta. #plot(x = banco$education, main = &quot;Gráfica de Educacíón&quot;, # xlab = &quot;Nivel educativo&quot;, ylab = &quot;Frecuencia&quot;, # col = c(&quot;royalblue&quot;, &quot;seagreen&quot;, &quot;purple&quot;, &quot;grey&quot;)) La combinación de colores puede mejorar, pero ya tenemos una gráfica de barras presentable. Sin embargo, hay ocasiones en las que deseamos usar gráficas de barras para presentar proporciones, que deseamos barras apiladas. Para esos casos, usamos la función barplot(). 12.4.1 La función barplot() Además de usar plot(), podemos crear gráficas de barra con la función barplot(). barplot pide como argumento una matriz, que represente una tabla de contingencia con los datos a graficar. Este tipo de tablas pueden ser generadas con la función table(). table() pide como argumento uno o más vectores, de preferencia variables discretas. Si damos sólo un vector como argumento, devuelve un conteo, si damos dos o más variables, devuelve tablas de contingencia. Por ejemplo, el conteo de la variable education, table(banco$education) #&gt; #&gt; primary secondary tertiary unknown #&gt; 678 2306 1350 187 Si damos como argumentos la variable education y la variable loan (préstamo), obtenemos una tabla de contingencia, que asignaremos al objeto tab_banco. tab_banco &lt;- table(banco$loan, banco$education) # Resultado tab_banco #&gt; #&gt; primary secondary tertiary unknown #&gt; no 584 1890 1176 180 #&gt; yes 94 416 174 7 Damos como argumento tab_banco a barplot() y nos devuelve una gráfica de barras apiladas. barplot(tab_banco) Si deseamos graficar proporciones en lugar de conteos, usamos la función prop.table(). Esta función nos pide como argumento una tabla de contingencia generada por table(). y un número para margin. El argumento margin es similar a MARGIN de apply() (como vimos en el capítulo 10). Si damos como argumento 1, las proporciones se calcularán agrupadas por renglón. La suma de proporciones por renglón será igual a 1. Si damos como argumento 2, las proporciones se calcularán agrupadas por columna. La suma de proporciones por columna será igual a 1 Si no damos ningún argumento, las proporciones se calcularán usando toda la tabla como grupo. La suma de proporciones de todas las celdas en la tabla será igual a 1. Para ilustrar esto, veamos los tres casos para margin usando como argumento nuestro objeto tab_banco. # Proporción por renglón prop.table(tab_banco, margin = 1) #&gt; #&gt; primary secondary tertiary unknown #&gt; no 0.15248042 0.49347258 0.30704961 0.04699739 #&gt; yes 0.13603473 0.60202605 0.25180897 0.01013025 # Porporción por columna prop.table(tab_banco, margin = 2) #&gt; #&gt; primary secondary tertiary unknown #&gt; no 0.86135693 0.81960104 0.87111111 0.96256684 #&gt; yes 0.13864307 0.18039896 0.12888889 0.03743316 # Porporción por tabla prop.table(tab_banco) #&gt; #&gt; primary secondary tertiary unknown #&gt; no 0.12917496 0.41804910 0.26011944 0.03981420 #&gt; yes 0.02079186 0.09201504 0.03848706 0.00154833 Nosotros queremos obtener las proporciones por columna, así que usaremos margin = 2. ptab_banco &lt;- prop.table(tab_banco, margin = 2) Damos el resultado de la operación anterior a barplot(). barplot(ptab_banco) Hemos obtenido el resultado esperado, pero podemos mejorar la presentación. Nota que con barras apiladas el argumento col se puede usar para colorear las categorías al interior de las barras. barplot(ptab_banco, main = &quot;Préstamos por nivel educativo&quot;, xlab = &quot;Nivel educativo&quot;, ylab = &quot;Proporción&quot;, col = c(&quot;royalblue&quot;, &quot;grey&quot;)) Luce bien, pero tenemos un problema: no sabemos qué representan las categorías en nuestras barras apiladas viendo solamente nuestra gráfica. Nosotros podemos consultar directamente con los datos, pero una persona que vea por primera vez esta gráfica no tendrá esa opción, reduciendo con ello su utilidad. Para solucionar este problema, usamos leyendas. "],["12-5-leyendas.html", "12.5 Leyendas", " 12.5 Leyendas Las leyendas son usadas para identificar con mayor claridad los distintos elementos en un gráfico, tales como colores y formas. En R usamos la función legend() para generar leyendas. Esta función debe ser llamada después de crear un gráfico. En cierto modo es una anotación a un gráfico ya existente. legend() es una función relativamente compleja, así que sólo revisaremos lo esencial. legend() siempre nos pide siempre los siguientes argumentos. legend: Las etiquetas de los datos que queremos describir con la leyenda. Por ejemplo, si tenemos cuatro categorías a describir, proporcionamos un vector de cuatro cadenas de texto. fill: Los colores que acompañan a las etiquetas definidas con legend. Estos colores tienen que coincidir con los que hemos usado en el gráfico. x y y: Las coordenadas en pixeles, en las que estará ubicada la leyenda. Podemos dar como argumento a x alguno de los siguientes, para ubicar automáticamente la leyenda: bottomright, bottom, bottomleft, left, topleft, top, topright, right, center. title: Para poner título a la leyenda. Además, tenemos muchos otros argumentos opcionales, que puedes consultar en la documentación llamando ?legend(). Vamos a agregar una leyenda a la última gráfica de barras que creamos en la sección anterior de este capítulo. Entonces necesitamos conocer las etiquetas que daremos como argumento legend y a qué colores corresponden al vector banco$loan. Usamos la función unique para determinar cuántos valores únicos hay en este vector. Cada uno de estos valores corresponde a una etiqueta. Esta función, si la aplicamos a un vector de tipo factor, nos devuelve sus niveles. unique(banco$loan) #&gt; [1] &quot;no&quot; &quot;yes&quot; Tenemos dos etiquetas, no y yes (no y sí, respectivamente), en ese orden, por lo que ese será nuestro argumento legend. Nosotros determinamos los colores en la sección anterior como royalblue y grey, en ese orden. Por lo tanto, tendremos que no será coloreado con royalblue, y yes con grey. como vamos a rellenar una barra, esto colores los daremos al argumento fill. Por último, daremos como topright como argumento x para que nuestra leyenda se unique en la parte superior derecha de nuestro gráfico. Aplicamos todo, incluido generar el gráfico al que agregaremos la leyenda. barplot(ptab_banco, main = &quot;Préstamos por nivel educativo&quot;, xlab = &quot;Nivel educativo&quot;, ylab = &quot;Proporción&quot;, col = c(&quot;royalblue&quot;, &quot;grey&quot;)) legend(x = &quot;topright&quot;, legend = c(&quot;No&quot;, &quot;Yes&quot;), fill = c(&quot;royalblue&quot;, &quot;grey&quot;), title = &quot;Loan&quot;) Se ve mucho más clara la información, pues ahora estamos mostrando a qué categoría corresponden los colores que hemos empleado en el gráfico. En las secciones siguientes agregaremos leyendas a otros gráficos, con lo cual quedará un poco más claro el uso de legend(). "],["12-6-diagramas-de-dispersión.html", "12.6 Diagramas de dispersión", " 12.6 Diagramas de dispersión Este tipo de gráfico es usado para mostrar la relación entre dos variables numéricas continuas, usando puntos. Cada punto representa la intersección entre los valores de ambas variables. Para generar un diagrama de dispersión, damos vectores numéricos como argumentos x y y a la función plot(). Veamos la relación entre las variables age y balance de banco. plot(x = banco$age, y = banco$balance) Tenemos algunos datos extremos tanto en balance. Para fines de tener una gráfica más informativa, vamos a recodificarlos usando ifelse(), cambiando todos los valores mayores a 15 000. banco$balance &lt;- ifelse(banco$balance &gt; 15000, 15000, banco$balance) plot(x = banco$age, y = banco$balance) En los diagramas de dispersión, podemos usar el argumento col para camiar el color de los puntos usando como referencia una tercera variable. La variable que usaremos será, de nuevo, loan # plot(x = banco$age, y = banco$balance, col= banco$loan) Nos sería de utilidad una leyenda para interpretar más fácilmente los colores. Ya sabemos que los niveles de loan son no y yes, además de que los colores han sido rojo y negro, así que agregar una leyenda será relativamente fácil. #plot(x = banco$age, y = banco$balance, col= banco$loan) #legend(x = &quot;topleft&quot;, legend = c(&quot;No&quot;, &quot;Yes&quot;), fill = c(&quot;Black&quot;, &quot;Red&quot;), title = &quot;Loan&quot;) Desafortunadamente esta gráfica no es muy informativa para nuestros datos. Por fortuna, podemos probar con un conjunto de datos diferente. Si usamos diagramas de dispersión con iris obtendremos gráficos mucho más interesantes. Creamos un gráfico con las medidas de pétalo, aplicando lo que hemos visto para generar diagramas de dispersión. plot(x = iris$Petal.Length, y = iris$Petal.Width, col = iris$Species, main = &quot;Iris - Pétalo&quot;, xlab = &quot;Largo&quot;, ylab = &quot;Ancho&quot;) legend(x = &quot;topleft&quot;, legend = c(&quot;Setosa&quot;, &quot;Versicolor&quot;, &quot;Virginica&quot;), fill = c(&quot;black&quot;, &quot;red&quot;, &quot;green&quot;), title = &quot;Especie&quot;) "],["12-7-diagramas-de-caja.html", "12.7 Diagramas de caja", " 12.7 Diagramas de caja Los diagrama de caja, también conocidos como de caja y bigotes son gráficos que muestra la distribución de una variable usando cuartiles, de modo que de manera visual podemos inferir algunas cosas sobre su dispersión, ubicación y simetría. Una gráfica de este tipo dibuja un rectángulo cruzado por una línea recta horizontal. Esta linea recta representa la mediana, el segundo cuartil, su base representa el primer cuartil y su parte superior el tercer cuartil. Al rango entre el primer y tercer cuartil se le conoce como intercuartílico (RIC). Esta es la caja. Además, de la caja salen dos líneas. Una que llega hasta el mínimo valor de los datos en la variable o hasta el primer cuartil menos hasta 1.5 veces el RIC; y otra que llegar hasta el valor máximo de los datos o el tercer cuartil más hasta 1.5 veces el RIC. Estos son los bigotes. Usamos la función plot() para crear este tipo de gráfico, dando como argumento x un vector de factor o cadena de texto, y como argumento y un vector numérico. Una ventaja de este tipo de gráfico es que podemos comparar las distribución de una misma variable para diferentes grupos. Vamos a ver cómo se distribuye la edad por nivel de educación en nuestro objeto banco, esto es, las variables education y age. #plot(x = banco$education, y = banco$age) Podemos ver que las personas con menor nivel educativo tienden a tener una edad mayor. La mayoría de las personas con educación primaria tienen entre 40 y 50 años, mientras que la mayoría con educación terciaria tiene entre 35 y 45 años, aproximadamente. Por supuesto, podemos cambiar los parámetros gráficos a un diagrama de caja. #plot(x = banco$education, y = banco$age, main = &quot;Edad por nivel educativo&quot;, # xlab = &quot;Nivel educativo&quot;, ylab = &quot;Edad&quot;, # col = c(&quot;orange3&quot;, &quot;yellow3&quot;, &quot;green3&quot;, &quot;grey&quot;)) También podemos crear diagramas de caja con la función boxplot(). Esta función puede generar diagramas de caja de dos maneras distintas. En la primera manera, si damos como argumento x un vector numérico, nos dará un diagrama de caja de esa variable. boxplot(x = banco$age) En la segunda manera necesitamos dar dos argumentos: formula: Para esta función las fórmulas tienen el formato y ~ x, donde x es el nombre de la variable continua a graficar, y la x es la variable que usaremos como agrupación. data: Es el data frame del que serán tomadas las variables. Por ejemplo, para mostrar diagramas de caja por nivel educativo, nuestra variable y es age y nuestra variable x es education, por lo tanto, formula será age ~ education. boxplot(formula = age ~ education, data = banco) "],["12-8-gráficos-de-mosaico.html", "12.8 Gráficos de mosaico", " 12.8 Gráficos de mosaico Los gráficos de mosaico o diagramas de Marimekko son usados para mostrar la relación entre dos variables discretas, ya sean factores o cadenas de texto. Este tipo de gráfico recibe su nombre porque consiste en una cuadricula, en la que cada rectángulo representa el numero de casos que corresponden a un cruce específico de variables. Entre más casos se encuentren en ese cruce, más grande será el rectángulo. Para obtener un gráfico de mosaico, damos como vectores de factor o cadena de texto como argumentos x y y a la función plot(). Por ejemplo, intentemos graficar el estado marital con el nivel educativo de las personas en banco #plot(x = banco$marital, y = banco$education) Podemos cambiar el color de los mosaicos con el argumento col. Debemos proporcionar un color por cada nivel del vector en el eje Y. #plot(x = banco$marital, y = banco$education, # col = c(&quot;#99cc99&quot;, &quot;#cc9999&quot;, &quot;#9999cc&quot;, &quot;#9c9c9c&quot;)) De esta manera es más claro que el grupo más numeroso de personas son las casadas con educación secundaria y el más pequeño, divorciadas con educación primaria. "],["12-9-exportar-gráficos.html", "12.9 Exportar gráficos", " 12.9 Exportar gráficos Exportar los gráficos que hemos creado es un proceso que puede parecer un poco confuso. Cuando llamamos una de estas funciones, le estamos indicando a R que mande nuestro gráfico a un dispositivo gráfico (graphic device) en nuestra computadora, donde podemos verlo, que por defecto es una ventana en nuestro escritorio o el panel Plot si estás usando RStudio. Una consecuencia de esto es que si creas y lo mandas a un dispositivo gráfico en uso, el gráfico nuevo reemplazará al anterior. Por ejemplo, si usas plot() para crear un gráfico, se mostrará en una ventana de tu escritorio, pero si usas plot() de generar un gráfico distinto, el contenido de esta ventana será reemplazada con este nuevo gráfico. Lo mismo pasa con todos los dispositivos gráficos. Además, los gráficos no pueden ser guardados en un objetos para después ser exportados. Es necesario mandar nuestros gráficos a un dispositivo como JPG, PNG o algún otro tipo de archivo que pueda ser almacenado en nuestro disco duro. Para exportar un gráfico usamos alguna de las siguientes funciones, cada una corresponde con un tipo de archivo distinto. No son las únicas, pero son las más usadas. bpm() jpeg() pdf() png() tiff() Cada una de estas funciones tiene los siguientes argumentos tres argumentos principales. filename: El nombre y ruta del archivo de imagen a crear. Si no especificamos una ruta completa, entonces el el archivo será creado en nuestro directorio de trabajo. width: El ancho del archivo de imagen a crear, por defecto en pixeles. height: El alto del archivo de imagen a crear, por defecto en pixeles. La manera de utilizar estas funciones llamándolas antes de llamar a una función que genere una gráfica. Al hacer esto, le indicamos a R que en lugar de mandar nuestro gráfico a una ventana del escritorio, lo mande a un dispositivo gráfico distinto. Finalmente, llamamos a la función dev.off(), para cerrar el dispositivo gráfico que hemos elegido, de este modo se creará un archivo y podremos crear más gráficos después. Por ejemplo, para exportar un gráfico con leyenda como un archivo PNG llamamos lo siguiente. Nota que tenemos que dar la misma extensión de archivo que la función que estamos llamando, en este caso .png. #png(filename = &quot;loan_age.png&quot;, width = 800, height = 600) #plot(x = banco$age, y = banco$duration, col = banco$loan, # main = &quot;Edad y Duración&quot;, xlab = &quot;Edad&quot;, ylab = &quot;Duración&quot;) #legend(x = &quot;top&quot;, legend = c(&quot;No&quot;, &quot;Yes&quot;), fill = c(&quot;Black&quot;, &quot;Red&quot;), # title = &quot;Loan&quot;) #dev.off() Si aparece un mensaje como el siguiente, es que hemos tenido éxito. null device 1 Podemos ver el resultado usando file.show(). file.show(&quot;loan_age.png&quot;) De esta manera podemos exportar cualquier tipo de gráfico generado con R. "],["13-conclusión.html", "Capítulo 13 Conclusión", " Capítulo 13 Conclusión Al haber concluido este libro tendrás las herramientas básicas para utilizar R como un lenguaje de programación. Desde los conceptos más básicos, hasta la definición de funciones para exportar gráficos. Lo que hemos visto en este libro te será de utilidad sin importar el uso de R que tengas previsto, pues son conceptos fundamentales que te permitirán acceder a otros más complejos y avanzado. El siguiente paso es aplicar lo que hemos revisado hasta este momento, ya sea en algún proyecto propio o para aprender más sobre R y sus aplicaciones. En caso de que desees profundizar más sobre el uso de R, la siguiente sección te presenta una selección de materiales de referencia que te facilitarán continuar con tu aprendizaje, dependiendo de tus intereses personales. Todas las referencias incluyen un enlace para que las consultes en línea, sin costo y legalmente. ¡Suerte! Material de referencia Probabilidad y estadística (introductorio a medio) Diez, D., Barr, C., Çetinkaya-Rundel, M. (2015). OpenIntro Statistics, segunda edición. OpenIntro. https://www.openintro.org/stat/textbook.php?stat_book=os Navarro, D. (2015). Learning statistics with R: A tutorial for psychology students and other beginners. University of Adelaide. http://www.fon.hum.uva.nl/paul/lot2015/Navarro2014.pdf R aplicado a Data Science (medio a avanzado) Peng, R. D. (2016). R Programming for Data Science. Leanpub. https://leanpub.com/rprogramming Wickham. H. y Grolemund, G. (2017). R for Data Science. OReilly. http://r4ds.had.co.nz/ Programación con R (avanzado) Wickham, H. (2014). Tidy Data. Journal of Statistical Software. https://www.jstatsoft.org/article/view/v059i10/v59i10.pdf Wickham, H. (2014). Advanced R. OReilly. http://adv-r.had.co.nz/ Referencias sobre RStudio RStudio Cheat Sheets. https://www.rstudio.com/resources/cheatsheets/ "]]
