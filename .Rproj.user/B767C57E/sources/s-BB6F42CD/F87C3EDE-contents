# La familia apply
La familia de funciones `apply` es usada para aplicar una funci?n a cada elemento de una estructura de datos. En particular, es usada para aplicar funciones en matrices, data frames, arrays y listas.

Con esta familia de funciones podemos automatizar tareas complejas usando poca l?neas de c?digo y es una de las caracter?sticas distintivas de R como lenguaje de programaci?n.

La familia de funciones `apply` es una expresi?n de los rasgos del paradigma funcional de programaci?n presentes en R. Sobre esto no profundizaremos demasiado, pero se refiere saber que en R las funciones son "ciudadanos de primera", con la misma importancia que los objetos, y por lo tanto, operamos en ellas. 

La familia de funciones apply no s?lo recibe datos como argumentos, tambi?n recibe funciones.

### Un recordatorio sobre vectorizaci?n
Para entender m?s f?cilmente el uso de la familia 0, recordemos la [vectorizaci?n de operaciones](###vectorizaci?n-de-operaciones).

Hay operaciones que, si las aplicamos a un vector, son aplicadas a todos sus elementos.

```r
mi_vector <- 1:10

mi_vector
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
mi_vector ^ 2
```

```
##  [1]   1   4   9  16  25  36  49  64  81 100
```

Lo anterior es, generalmente, preferible a escribir una operaci?n para cada elemento o a usar un bucle **for**, como se describi? en  el cap?tulo sobre [estructuras de control](#estructuras-de-control).

Como todo lo que ocurre en R es una funci?n, podemos decir que **al vectorizar estamos aplicando una funci?n a cada elemento de un vector**. La familia de funciones **apply** nos permite implementar esto en estructuras de datos distintas a los vectores.

### Las funciones de la familia apply
La familia apply esta formada por las siguientes funciones:

* `apply()`
* `eapply()`
* `lapply()`
* `mapply()`
* `rapply()`
* `sapply()`
* `tapply()`
* `vapply()`

Es una familia numerosa y esta variedad de funciones se debe a que varias de ellas tienen aplicaciones sumamente espec?ficas.

Todas las funciones de esta familia tienen una caracter?stica en com?n: **reciben como argumentos a un objeto y al menos una funci?n**. 

Hasta ahora, todas las funciones que hemos usado han recibido como argumentos estructuras de datos, sean vectores, data frames o de otro tipo. Las funciones de la familia apply tienen la particularidad que pueden recibir a otra funci?n como un argumento. Lo anterior puede sonar confuso, pero es m?s bien intuitivo al verlo implementado.

Nosotros trabajaremos con las funciones m?s generales y de uso com?n de esta familia:

* `apply()`
* `lapply()`

Estas dos funciones nos permitir?n solucionar casi todos los problemas a los que nos encontremos. Adem?s, conociendo su uso, las dem?s funciones de la familia **apply** ser?n relativamente f?ciles de entender.

## apply
`apply` aplica una funci?n a todos los elementos de una **matriz**.

La estructura de esta funci?n es la siguiente.

```r
apply(X, MARGIN, FUN)
```

`apply` tiene tres argumentos:

* `X`: Una matriz o un objeto que pueda coercionarse a una matriz, generalmente, un data frame.
* `MARGIN`: La dimensi?n (margen) que agrupar? los elementos de la matriz `X`, para aplicarles una funci?n. Son identificadas con n?meros, **1** son renglones y **2** son columnas.
* `FUN`: La funci?n que aplicaremos a la matriz `X` en su dimensi?n `MARGIN`.

### ?Qu? es X
`X` es una matriz o cualquier otro objeto que sea posible coercionar a una matriz. Esto es, principalmente, vectores y data frames. 

Recuerda que puedes coercionar objetos a matriz usando `as.matrix()` y puedes comprobar si un objeto es de esta clase con `is.matrix()`.

```r
# Creamos un data frame
mi_df <- data.frame(v1 = 1:3, v2 = 4:6)

mi_df
```

```
##   v1 v2
## 1  1  4
## 2  2  5
## 3  3  6
```

```r
# Coerci?n a matriz
mi_matriz <- as.matrix(mi_df)

# Verificamos que sea matriz
is.matrix(mi_matriz)
```

```
## [1] TRUE
```

```r
# Resultado
mi_matriz
```

```
##      v1 v2
## [1,]  1  4
## [2,]  2  5
## [3,]  3  6
```

Aunque tambi?n podemos coercionar listas y arrays a matrices, los resultados que obtenemos no siempre son apropiados para `apply()`, por lo que no es recomendable usar estos objetos como argumentos.

### ?Qu? es MARGIN?
Recuerda que las matrices y los data frames est?n formadas por vectores y que estas estructuras tienen dos dimensiones, ordenadas en renglones y columnas. Esto lo vimos en en [Matrices y arrays](##matrices-y-arrays) y [Data frames](##data-frames).

Para `MARGIN`:

* 1 es renglones.
* 2 es columnas.

Por ejemplo, podemos usar `apply()` para obtener la sumatoria de los elementos de una matriz, por rengl?n.

Creamos una matriz de cuatro renglones.

```r
matriz <- matrix(1:14, nrow = 4) 
```

```
## Warning in matrix(1:14, nrow = 4): la longitud de los datos [14] no es un
## subm?ltiplo o m?ltiplo del n?mero de filas [4] en la matriz
```

Aplicamos `apply()`, dando la funci?n `sum()` el argumento `FUN`, nota que s?lo necesitamos el nombre de la funci?n, sin par?ntesis.

Por ?ltimo, damos el argumento `MARGIN = 1`, para aplicar la funci?n por rengl?n.

```r
apply(X = matriz, MARGIN = 1, FUN = sum)
```

```
## [1] 28 32 22 26
```

Esto es equivalente a hacer lo siguiente.

```r
sum(matriz[1, ])
```

```
## [1] 28
```

```r
sum(matriz[2, ])
```

```
## [1] 32
```

```r
sum(matriz[3, ])
```

```
## [1] 22
```

```r
sum(matriz[4, ])
```

```
## [1] 26
```

Y naturalmente, es equivalente a hacer lo siguiente.



























































